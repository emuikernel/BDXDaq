h64695
s 00011/00000/00681
d D 1.56 09/06/08 11:36:57 boiarino 57 56
c *** empty log message ***
e
s 00141/00091/00540
d D 1.55 09/06/08 11:12:59 boiarino 56 55
c *** empty log message ***
e
s 00001/00021/00630
d D 1.54 09/05/29 11:09:47 boiarino 55 54
c *** empty log message ***
e
s 00008/00006/00643
d D 1.53 07/10/12 10:04:00 boiarino 54 53
c *** empty log message ***
e
s 00025/00011/00624
d D 1.52 01/11/12 13:31:39 wolin 53 52
c Try both archive and eor scaler files
e
s 00006/00006/00629
d D 1.51 01/01/03 11:12:46 wolin 52 51
c is_open()
e
s 00020/00019/00615
d D 1.50 00/11/29 13:28:29 wolin 51 50
c New CC
e
s 00002/00002/00632
d D 1.49 00/10/27 09:54:05 wolin 50 49
c const, not finished
e
s 00009/00009/00625
d D 1.48 00/09/08 13:11:13 wolin 49 48
c New clon_root
e
s 00002/00002/00632
d D 1.47 00/03/09 09:23:53 wolin 48 47
c Got default session correct
e
s 00008/00009/00626
d D 1.46 00/01/20 13:02:01 wolin 47 46
c Changed dd2scaler
e
s 00013/00010/00622
d D 1.45 99/09/23 10:04:12 clasrun 46 45
c Now checks current run in recovery mode
c 
e
s 00004/00004/00628
d D 1.44 99/08/31 09:58:45 wolin 45 44
c Do file first
c 
e
s 00001/00001/00631
d D 1.43 99/05/17 16:09:22 wolin 44 43
c TRGS00, not TRGS
c 
e
s 00004/00004/00628
d D 1.42 99/05/11 09:57:15 wolin 43 42
c Now using dd2scaler file for everything
c 
e
s 00001/00003/00631
d D 1.41 99/01/11 15:34:08 wolin 42 41
c Fixed info_server msg
c 
e
s 00012/00015/00622
d D 1.40 98/07/23 12:00:21 wolin 41 40
c Using BOR instead of file age
c 
e
s 00022/00001/00615
d D 1.39 98/07/23 11:44:17 wolin 40 39
c Skips files less than min_file_age hours old
c 
e
s 00007/00001/00609
d D 1.38 98/05/18 12:31:02 wolin 39 38
c Dies if no run file, more warning msg
c 
e
s 00002/00002/00608
d D 1.37 98/05/06 10:40:45 wolin 38 37
c Changed dd2scaler file name
c 
e
s 00002/00003/00608
d D 1.36 98/03/18 16:43:53 wolin 37 36
c Last bug in archive file in recovery mode, I hope
c 
e
s 00017/00011/00594
d D 1.35 98/03/18 16:23:56 wolin 36 35
c Bug in append file name for recovery
c 
e
s 00000/00003/00605
d D 1.34 98/03/18 15:56:53 wolin 35 34
c nlong now in kwords
c 
e
s 00031/00019/00577
d D 1.33 98/03/17 17:47:18 wolin 34 33
c Many bug fixes
c 
e
s 00003/00000/00593
d D 1.32 98/03/16 16:18:00 wolin 33 32
c Added debug output when unable to open files
c 
e
s 00087/00146/00506
d D 1.31 98/03/03 16:46:43 wolin 32 31
c Now reads eor scalers from eor file, combined collect_data and collect_recovery_data
c 
e
s 00002/00002/00650
d D 1.30 98/03/02 14:47:39 wolin 31 30
c Better file doc
c 
e
s 00009/00000/00643
d D 1.29 98/03/02 14:10:24 wolin 30 29
c Bug...forgot to reset nfile,nlong,etc in recovery mode
c 
e
s 00001/00001/00642
d D 1.28 98/02/19 10:23:22 wolin 29 28
c Minor mods
c 
e
s 00001/00000/00642
d D 1.27 98/02/13 12:43:54 wolin 28 27
c Filename not set properly for update of run_file
c 
e
s 00010/00005/00632
d D 1.26 98/02/12 11:38:27 wolin 27 26
c Bug in recovery mode...did not reset sqlstring
c 
e
s 00001/00001/00636
d D 1.25 98/02/12 09:46:30 wolin 26 25
c Typo in ER output file name
c 
e
s 00006/00035/00631
d D 1.24 98/02/11 17:35:35 wolin 25 24
c Minor file format changes
c 
e
s 00014/00000/00652
d D 1.23 98/02/11 17:08:22 wolin 24 23
c Added bit counts to file
c 
e
s 00006/00005/00646
d D 1.22 98/02/11 17:01:25 wolin 23 22
c Minor mods
c 
e
s 00001/00001/00650
d D 1.21 98/02/11 16:11:31 wolin 22 21
c Typo in insert_into_file
c 
e
s 00016/00030/00635
d D 1.20 98/02/11 12:40:37 wolin 21 20
c Switched fcup,clock scalers, other mods
c 
e
s 00008/00006/00657
d D 1.19 98/01/20 11:47:00 wolin 20 19
c Minor mods, seems to work correctly
c 
e
s 00253/00223/00410
d D 1.18 98/01/19 17:54:17 wolin 19 18
c Major upgrade, new columns, env vars, etc
c 
e
s 00015/00007/00618
d D 1.17 97/12/12 11:08:56 wolin 18 17
c Now gets end date from file correctly
c 
e
s 00001/00014/00624
d D 1.16 97/11/17 16:11:26 wolin 17 16
c create_header args now include name1,name2
c 
e
s 00033/00037/00605
d D 1.15 97/09/23 12:22:36 wolin 16 15
c Now handles both old and new ER file formats
c 
e
s 00081/00032/00561
d D 1.14 97/08/19 17:06:21 wolin 15 14
c Added mapmanager calls, etc.
c 
e
s 00028/00019/00565
d D 1.13 97/06/24 09:23:43 wolin 14 13
c Numerous minor improvements
e
s 00198/00067/00386
d D 1.12 97/06/20 15:25:05 wolin 13 12
c More improvements to recovery scheme
e
s 00015/00006/00438
d D 1.11 97/06/11 17:28:37 wolin 12 11
c Now appends sql string to run file
e
s 00036/00019/00408
d D 1.10 97/06/06 17:26:01 wolin 11 10
c Now reads run file summary to get file and event stats
e
s 00019/00016/00408
d D 1.9 97/06/05 13:29:47 wolin 10 9
c Handles new vme file format
e
s 00059/00016/00365
d D 1.8 97/06/03 17:17:50 wolin 9 8
c Now reads scalers from vme, no epics, does cmlog
e
s 00007/00123/00374
d D 1.7 97/05/28 13:28:21 wolin 8 7
c No dd needed, ER shut down before this runs
e
s 00020/00028/00477
d D 1.6 97/05/28 13:20:39 wolin 7 6
c No insert_msg, otherwise working with new epics channels, etc.
e
s 00006/00001/00499
d D 1.5 97/05/06 11:40:15 wolin 6 5
c Updated documentation
e
s 00025/00013/00475
d D 1.4 97/04/17 14:08:32 wolin 5 4
c Added filebase, now reads run_file_summary.txt
e
s 00001/00001/00487
d D 1.3 97/04/10 17:42:02 wolin 4 3
c Type
c 
e
s 00004/00005/00484
d D 1.2 97/04/10 13:32:30 wolin 3 1
c Minor cdev improvements, etc.
e
s 00000/00000/00000
d R 1.2 97/04/10 12:46:12 Codemgr 2 1
c SunPro Code Manager data about conflicts, renames, etc...
c Name history : 2 1 run_log/s/run_log_end.cc
c Name history : 1 0 s/run_log_end.cc
e
s 00489/00000/00000
d D 1.1 97/04/10 12:46:11 wolin 1 0
c Makes end run logbook entry
e
u
U
f e 0
t
T
I 1
//
//  run_log_end
//
D 8
//  collects and inserts run log end info into database and datastream
E 8
I 8
D 16
//  collects and inserts run log end info into database
E 16
I 16
D 25
//  collects and inserts run log end info into ingres and mapmgr databases
E 25
I 25
D 54
//  collects and inserts run log end info into ingres database
E 54
I 54
//  collects and inserts run log end info into database
E 54
I 32
//  assumes get_eor_scalers already run (looks for file in archive area)
E 32
E 25
E 16
E 8
//
I 13
D 16
//  If optional file list given, makes belated run_log_end entries in recovery mode
//  Appends info to the file written by the ER, as a backup
//  Also tags ER file when done 
E 16
I 16
D 25
//  If optional file list given, makes belated run_log_end entries (no mapmgr) in "recovery" mode
E 25
I 25
//  If optional file list given, makes belated run_log_end entries in "recovery" mode
E 25
// 
D 19
//  Appends info to file written by ER (for backup), and tags ER file
E 19
I 19
//  Appends info to file written by ER (for backup), tags ER file
D 32
//  In normal mode, also creates info_server message, writes to archive file
E 32
I 32
D 39
//  In normal mode, also creates info_server message
E 39
I 39
//  In normal mode, also creates info_server message,
//     dies if no ER file
E 39
E 32
E 19
E 16
E 13
//
I 20
D 35
//  still to do:
I 21
D 29
//     why read eor scalers instead of using file???
E 29
I 29
D 34
//     need nlong in kbytes
E 34
I 34
//     need nlong in kwords
E 35
E 34
E 29
E 21
E 20
D 13
//  usage:
//     run_log_end [-a application] [-u uniq_dgrp] [-i id_string] [-debug]
D 5
//                   [-d destination] [-t tk_script] [-m msql_database]
E 5
I 5
D 8
//                   [-d destination] [-t tk_script] [-m msql_database] [-f run_summary_file]
E 5
//                   [-s session]     [-no_dbr]      [-no_dd]  [-g gmd_time] [-c cdev_pend_time]
E 8
I 8
D 11
//                 [-d destination] [-t tk_script] [-m msql_database] [-f run_summary_file]
E 11
I 11
//                 [-d destination] [-t tk_script] [-m msql_database] [-f run_file_summary]
E 11
//                 [-s session]     [-no_dbr]      [-g gmd_time] [-c cdev_pend_time]
E 8
//
E 13
D 16
//      use -no_dbr to NOT insert data into database
D 8
//      use -no_dd  to NOT insert data into DD system
E 8
//      use -debug to just dump SQL string to stdout
E 16
I 16
D 19
//  Note:  assumes get_eor_scalers run previously
E 19
E 16
//
I 56
// Usage: run_log_end -a clasprod (from rcscript)
//        run_log_end -a clasprod -s clasprod -debug *.txt (if recovering and debugging)
//        cd $CLON_PARMS/run_files; run_log_end -a clasprod -s clasprod -debug runfile_clasprod_060067.txt
//        run_log_end -a clasprod -s clasprod *.txt (if recovering)
//
I 57
//  Recovery mode:
//    NOTE: only 'clasprod' files will be processed, the rest will be ignored
E 57
//
//
E 56
I 20
D 35
//
E 35
E 20
D 19
//
D 8
//   still to do:
//       get header ctl words, event class correct
//       bombproofing:  no msqld, etc.
E 8
I 8
D 12
//  Note...can't insert event into DD as event recorder is shut down by
//         the time this is run...see end_run_events.cc
E 12
I 12
D 13
//  Note...Can't insert event into DD as event recorder is shut down by
//          the time this is run...see end_run_events.cc, which is run just 
//          before the ER shuts down
//         Thus this program appends info to the file written by the ER, as a backup
E 12
E 8
//
//
E 13
D 6
//  ejw, 20-mar-97
E 6
I 6
//  Note...currently stores:
D 7
//    coda:   run, end time, file base name, nevent, nlong, nbad, nfile
E 7
I 7
D 12
//    coda:   run, end time, file base name, nevent, nlong, nerror, nfile
E 7
D 9
//    epics:  faraday cup
E 9
I 9
D 10
//    vme:    faraday cup, gated clock, ungated clock
E 10
I 10
//    vme:    faraday cup gated and ungated, clock gated and ungated
E 12
I 12
//    coda:     run, end time, file base name, nevent, nlong, nerror, nfile
D 16
//    scalers:  faraday cup gated and ungated, clock gated and ungated
E 12
E 10
//    epics:  ???
E 16
I 16
//    scalers:  faraday cup, clock
//    epics:    nothing yet...
E 16
E 9
//
//
D 8
//  ejw, 6-may-97
E 8
I 8
D 13
//  ejw, 28-may-97
E 13
I 13
D 15
//  ejw, 20-jun-97
E 15
I 15
//  still to do:
//     get event class, flags correct
//
//
D 16
//  ejw, 7-aug-97
E 16
I 16
//  ejw, 25-aug-97
E 19
I 19
D 32
//  ejw, 19-jan-98
E 32
I 32
D 34
//  ejw, 3-mar-98
E 34
I 34
//  ejw, 17-mar-98
I 56
// Sergey Boyarinov: fix recovery part June 2009
E 56
E 34
E 32
E 19
E 16
E 15
E 13
E 8
E 6


// for posix
#define _POSIX_SOURCE_ 1
#define __EXTENSIONS__


D 8
// sql string and DD buffer sizes
#define DDBUFFERSIZE  1200     // longwords


E 8
// system stuff
I 54

using namespace std;
#include <strstream>

E 54
#include <iostream.h>
I 23
#include <iomanip.h>
E 23
I 5
#include <fstream.h>
E 5
D 54
#include <strstream.h>
E 54
I 13
#include <sys/time.h>
I 40
D 41
#include <sys/types.h>
#include <sys/stat.h>
E 41
E 40
E 13


// for ipc
#include <rtworks/cxxipc.hxx>


D 55
// for cdev
#include <cdev.h>
#include <cdevData.h>
#include <cdevDevice.h>
#include <cdevRequestObject.h>
#include <cdevSystem.h>


E 55
// online and coda stuff
extern "C"{
#include <clas_ipc_prototypes.h>
D 8
#include <dd_user.h>
E 8
D 7
#include <msql.h>
E 7
}


D 21
// for record segment header
static int nevnt  = 0;
static int nphys  = 0;
static int trig   = 20;               // fpack class, 17 for prestart event, 0 for normal event, etc.


// constants for head bank
static int nvers  = 0;
static int type   = 1;
static int rocst  = 0;
static int evcls  = 20;               // fpack class again?
static int presc  = 1;


E 21
D 8
// DD event control words
static int ddctl[4] = {-1,-1,-1,-1};


E 8
// flags to inhibit event recording, etc.
D 15
static int no_dbr = 0;
D 8
static int no_dd  = 0;
E 8
static int debug  = 0;
E 15
I 15
static int no_dbr    = 0;
D 19
static int debug     = 0;
E 19
I 19
static int no_info   = 0;
static int no_file   = 0;
E 19
D 25
static int no_mapmgr = 0;
E 25
I 19
static int debug     = 0;
E 19
E 15


D 13
// parameters resettable on command line
E 13
I 13
// misc variables
E 13
D 5
static char *application    = "clastest";
static char *uniq_dgrp      = "run_log_end";
static char *id_string      = "run_log_end";
static char *dest           = "dbrouter";
static char *msql_database  = "clasrun";
static char *session        =  getenv("DD_NAME");
static int gmd_time         =  5;
static int cdev_pend_time   =  5;
E 5
I 5
D 19
static char *application      = "clastest";
static char *uniq_dgrp        = "run_log_end";
static char *id_string        = "run_log_end";
static char *dest             = "dbrouter";
static char *msql_database    = "clasrun";
static char *session          =  getenv("DD_NAME");
static int gmd_time           =  5;
static int cdev_pend_time     =  5;
D 7
static char *run_summary_file = "/usr/local/clas/parms/run_log/run_file_summary.txt";
E 7
I 7
D 11
static char *run_summary_file = "/usr/local/clas/parms/run_log/run_summary_%s.txt";
E 11
I 11
static char *run_file_summary = "/usr/local/clas/parms/run_files/runfile_%s_%06d.txt";
I 15
D 16
static char *get_eor_scalers  = "/usr/local/clas/bin/get_eor_scalers";
E 16
static char *eor_scaler_file  = "/usr/local/clas/parms/run_log/eor_scalers.txt";
static char *mapmgr_file_name = "/usr/local/clas/parms/Maps/RUN_CONTROL.map";
E 15
I 13
static int filep              = 0;
I 14
static int force              = 0;
I 15
static char line[500];
E 19
I 19
D 51
static char *application      	 = "clastest";
static char *uniq_dgrp        	 = "run_log_end";
static char *id_string        	 = "run_log_end";
static char *dest             	 = "dbrouter";
static char *msql_database    	 = "clasrun";
D 32
static char *session          	 =  getenv("DD_NAME");
E 32
I 32
D 48
static char session[50];
E 48
I 48
static char session[50]          =  "";
E 51
I 51
static char *application      	 = (char*)"clastest";
static char *uniq_dgrp        	 = (char*)"run_log_end";
static char *id_string        	 = (char*)"run_log_end";
static char *dest             	 = (char*)"dbrouter";
static char *msql_database    	 = (char*)"clasrun";
static char session[50]          = "";
E 51
E 48
E 32
static int gmd_time           	 =  5;
D 55
static int cdev_pend_time     	 =  5;
E 55
static int filep              	 = 0;
static int force              	 = 0;
I 40
static int min_file_age          = 5;   // hours
static time_t now                = time(NULL);
E 40
E 19
E 15
E 14
E 13
E 11
E 7
E 5

I 19
D 49
static char *archive_file_name   = "parms/run_log/archive/end_%s_%06d.txt";
static char *run_file_summary 	 = "parms/run_files/runfile_%s_%06d.txt";
D 32
static char *scaler_archive_name = "parms/scalers/archive/scal%06d.txt";
E 32
I 32
static char *scaler_eor_name     = "parms/scalers/archive/eor_%s_%06d.txt";
D 38
static char *dd2scaler_file_name = "parms/scalers/archive/scal%06d.txt";
E 38
I 38
D 47
static char *dd2scaler_file_name = "parms/scalers/archive/dd2scaler_%s_%06d.txt";
E 47
I 47
static char *scaler_file_name    = "parms/scalers/archive/scalers_%s_%06d.txt";
E 49
I 49
D 51
static char *archive_file_name   = "run_log/archive/end_%s_%06d.txt";
static char *run_file_summary 	 = "run_files/runfile_%s_%06d.txt";
static char *scaler_eor_name     = "scalers/archive/eor_%s_%06d.txt";
static char *scaler_file_name    = "scalers/archive/scalers_%s_%06d.txt";
E 51
I 51
static char *archive_file_name   = (char*)"run_log/archive/end_%s_%06d.txt";
static char *run_file_summary 	 = (char*)"run_files/runfile_%s_%06d.txt";
static char *scaler_eor_name     = (char*)"scalers/archive/eor_%s_%06d.txt";
static char *scaler_file_name    = (char*)"scalers/archive/scalers_%s_%06d.txt";
E 51
E 49
E 47
E 38
I 34
static char *envrun              = getenv("RUN_NUMBER");
E 34
E 32
D 25
static char *mapmgr_file_name 	 = "parms/Maps/RUN_CONTROL.map";
E 25
E 19

I 15
D 19
// vme scalers
static unsigned long fcup_all, fcup_active, fcup_live, clock_all, clock_active, clock_live;
E 19
I 19
static char line[1024];
static char filename[128];
I 27
static char temp[128];
E 27
E 19


E 15
D 19
// epics channel names, etc.
I 3
D 9
char *db_name[] = {"faraday_cup"}; 
E 9
I 9
D 13
char *db_name[] = {"junk"}; 
E 9
E 3
char *epics_chan[] = {"scaler"};
D 3
char *epics_name[] = {"faraday_cup"}; 
E 3
I 3
D 7
char *epics_get[]  = {"get"}; 
E 7
I 7
D 9
char *epics_get[]  = {"get S1"}; 
E 9
I 9
char *epics_get[]  = {"scaler"};
E 13
I 13
static char *db_name[]      = {"junk"}; 
static char *epics_chan[]   = {"scaler"};
static char *epics_get[]    = {"scaler"};
E 13
E 9
E 7
E 3
static int epics_val[sizeof(epics_chan)/sizeof(char *)];
D 13
static int ncallback = 0;
E 13
I 13
static int ncallback        = 0;
E 19
I 19
// end data
static int run;
I 46
static int current_run;
E 46
static char end_date[30];
static char location[80];
static char filebase[80];
static long nfile  = 0;
static long nevent = 0;
static long nlong  = 0;
static long nerror = 0;
E 19
E 13


I 19
// scalers
static unsigned long eor_scalers[64];
D 21
static unsigned long fcup_all, fcup_active, fcup_live, clock_all, clock_active, clock_live;
E 21
I 21
static unsigned long clock_all, clock_active, clock_live;
static unsigned long fcup_all, fcup_active, fcup_live;
E 21
static unsigned long trig_presc[13], trig_event[13], trig_file[13];


E 19
// prototypes
void decode_command_line(int argc, char **argv);
D 14
void collect_data(int &run, strstream &sql_string);
I 13
void collect_recovery_data(char *name_in, int &run, strstream &sql);
E 14
I 14
D 19
int collect_data(int &run, strstream &sql_string);
int collect_recovery_data(char *name_in, int &run, strstream &sql);
E 14
E 13
void get_epics_data(void);
I 9
D 10
void get_vme_data(long &faraday_cup, float &livetime);
E 10
I 10
D 13
void get_vme_data(long &fcup_ungated, long &fcup_gated, long &clock_ungated, long &clock_gated);
E 13
I 13
D 15
void get_vme_data(long &fcup, long &fcup_active, long &fcup_live, 
		  long &clock, long &clock_active, long &clock_live);
E 15
I 15
void get_vme_data(void);
E 15
E 13
E 10
E 9
void epics_callback_func(int status, void *userarg, cdevRequestObject &epics_req_obj,
			    cdevData& result);
void insert_into_database(char *entry);
E 19
I 19
D 32
void collect_data(strstream &sql_string);
void collect_recovery_data(char *name_in, strstream &sql_string);
E 32
I 32
D 34
void collect_data(strstream &sql_string, int recover);
E 34
I 34
void collect_data(strstream &sql_string, int recover, char *recovery_filename);
E 34
E 32
void get_scaler_data(void);
void insert_into_ipc(char *sql);
void insert_into_file();
E 19
I 15
D 25
void insert_into_mapmgr(int &run);
E 25
E 15
I 13
D 50
int find_tag_line(ifstream &file, char *tag, char buffer[], int buflen);
E 50
I 50
int find_tag_line(ifstream &file, const char *tag, char buffer[], int buflen);
E 50
E 13
D 8
void insert_into_dd(int &run, char *entry);
E 8
D 11

E 11
I 11
int get_next_line(ifstream &file, char buffer[], int buflen);
I 19
D 51
char *env_name(char *env, char *name);
E 51
I 51
char *env_name(const char *env, char *name);
E 51
E 19
E 11
extern "C" {
D 8
int create_header(int *p, int fevlen, int &banksize,
		  int nrun, int nevnt, int nphys, int trig);
int add_bank(int *p2fev, int fevlen, 
      char *name, int num, char *format, int ncol, int nrow, int ndata, int &banksize, int *data);
int va_add_bank(int *p2fev, int fevlen, 
      char *name, int num, char *format, int ncol, int nrow, int ndata, int &banksize, ...);
E 8
I 7
D 50
int get_run_number(char *msql_database, char *session);
E 50
I 50
int get_run_number(const char *msql_database, const char *session);
E 50
I 9
D 15
int fork_and_wait(char *command);
E 15
I 15
D 16
int fork_and_wait(char *command, int timeout=0);
E 16
E 15
D 17
int insert_msg(char *name, char *facility, char *process, char *msgclass, 
	       int severity, char *status, int code, char *text);
E 17
I 15
D 25
int map_put_float(const char filename[], const char subsystemname[],
		  const char itemname[], int arraylength,
		  const float farray[], int firsttime);
E 25
I 19
D 54
void DP_cmd_init(char *msql_tcp_host);
void DP_cmd(char *roc, char *cmd, char *buf, int timeout);
E 54
E 19
E 15
E 9
E 7
}


// program start time
static time_t start=time(NULL);


I 7
D 55
// ref to cdev system object
cdevSystem &cdevsys = cdevSystem::defaultSystem ();
E 7

I 7

E 55
I 13
// ref to server (connection created later)
TipcSrv &server=TipcSrv::Instance();
E 13

I 13


E 13
E 7
//--------------------------------------------------------------------------

D 56

main(int argc,char **argv){

D 19
  int nrun=0;
D 9
  strstream sql_string;
E 9
I 9
  int status;
E 19
I 19
D 27
  strstream sql_string;
E 27
E 19
D 13
  strstream sql_string,temp;
E 13
I 13
D 17
  strstream temp;
E 17
E 13
E 9

E 56
I 56
int
main(int argc,char **argv)
{
E 56
D 27

E 27
  // decode command line
  decode_command_line(argc,argv);

I 19
  // no ipc or file in recovery mode
D 56
  if(filep!=0) {
E 56
I 56
  if(filep!=0)
  {
E 56
    no_info=1;
    no_file=1;
  }

E 19
  // set session name if not specified via env variable or on command line
D 32
  if(session==NULL)session="clasprod";

E 32
I 32
D 56
  if(filep==0) {
E 56
I 56
  if(filep==0)
  {
E 56
D 47
    char *s = getenv("DD_NAME");
    if(s==NULL)strcpy(session,"clasprod"); else strcpy(session,s);
E 47
I 47
D 48
    if(session==NULL)strcpy(session,"clasprod");
E 48
I 48
    if(strlen(session)==0)strcpy(session,"clasprod");
E 48
E 47
  }
    
E 32
I 7
D 55
  // only print cdev error messages
  cdevsys.setThreshold(CDEV_SEVERITY_ERROR);

E 55
I 13
  // disable GMD timeout and connect to server
D 19
  if((debug==0)&&(no_dbr==0)){
    T_OPTION opt=TutOptionLookup("Server_Delivery_Timeout");
    TutOptionSetNum(opt,0.0);
E 19
I 19
D 56
  if(debug==0) {
    if(no_dbr==0) {
E 56
I 56
  if(debug==0)
  {
    if(no_dbr==0)
    {
E 56
D 51
      T_OPTION opt=TutOptionLookup("Server_Delivery_Timeout");
E 51
I 51
      T_OPTION opt=TutOptionLookup((T_STR)"Server_Delivery_Timeout");
E 51
      TutOptionSetNum(opt,0.0);
    }
E 19
    dbr_init(uniq_dgrp,application,id_string);
  }

I 19

E 19
E 13
I 9
D 17
  // post startup message
  temp << "Process startup:    run_log_end" << ends;
  status=insert_msg("run_log_end","online","run_log_end","status",0,"START",0,temp.str());

E 9
E 7
D 13
  // collect data (returns run number and sql string)
  collect_data(nrun,sql_string);
E 13

E 17
D 8
  // insert sql string into DD system as special database event
  if((no_dd ==0)&&(debug==0))insert_into_dd(nrun,sql_string.str());

E 8
D 13
  // ship sql string to database router
  if((no_dbr==0)&&(debug==0))insert_into_database(sql_string.str());
E 13
I 13
  // normal mode
D 56
  if(filep==0){
E 56
I 56
  if(filep==0)
  {
E 56
E 13

D 13
  // debug...just print sql string
  if(debug!=0){
    cout << "\nsql string for run " << nrun << " is:\n\n" << sql_string.str() << endl << endl;
E 13
I 13
D 19
    // collect data (returns run number and sql string)
    strstream sql_string;
D 14
    collect_data(nrun,sql_string);
E 14
I 14
    status=collect_data(nrun,sql_string);
E 19
I 19
D 32
    // collect data (returns sql string)
E 32
I 32
D 34
    // get run number 
    run=get_run_number(msql_database,session);
E 34
I 34
    // get run number from env var if it exists, otherwise try msql
D 56
    if(envrun!=NULL) {
E 56
I 56
    if(envrun!=NULL)
    {
E 56
      run=atoi(envrun);
D 56
    } else {
E 56
I 56
    }
    else
    {
E 56
      cerr << "?No RUN_NUMBER env var...using msql" << endl;
      run=get_run_number(msql_database,session);
    }
E 34

D 34

E 34
    // collect data in normal mode (returns sql string)
E 32
I 27
    strstream sql_string;
E 27
D 32
    collect_data(sql_string);
E 32
I 32
D 34
    collect_data(sql_string,0);
E 34
I 34
    collect_data(sql_string,0,NULL);
E 34
E 32
E 19
E 14

D 14
    // ship sql string to database router
    if((no_dbr==0)&&(debug==0))insert_into_database(sql_string.str());
E 14
I 14
D 19
    // ship sql string to database router if data ok
    if((no_dbr==0)&&(debug==0)&&(status=0))insert_into_database(sql_string.str());
E 19
E 14

I 19
D 45
    // ship sql string to database router and/or info_server
    if(debug==0)insert_into_ipc(sql_string.str());
    
    
E 45
D 21
    // write run begin info to file
E 21
I 21
    // write run end info to file
E 21
    if((no_file==0)&&(debug==0))insert_into_file();


I 45
    // ship sql string to database router and/or info_server
    if(debug==0)insert_into_ipc(sql_string.str());
    
    
E 45
D 25
    // write to mapmgr
    if((no_mapmgr==0)&&(debug==0))insert_into_mapmgr(run);


E 25
E 19
    // debug...just print sql string
    if(debug!=0){
D 19
      cout << "\nsql string for normal run " << nrun << " is:\n\n" << sql_string.str() << endl << endl;
E 19
I 19
      cout << "\nsql string for normal run " << run << " is:\n\n" << sql_string.str() << endl << endl;
E 19
    }

I 15
D 19
    // write to mapmgr
    if((no_mapmgr==0)&&(debug==0))insert_into_mapmgr(nrun);
E 19
E 15

I 15
D 19

E 19
E 15
  // recovery mode
D 56
  } else {
E 56
I 56
  }
  else
  {
E 56

D 32
    for(int i=filep; i<argc; i++){
E 32
I 32
D 56
    for(int i=filep; i<argc; i++) {
E 56
I 56
    for(int i=filep; i<argc; i++)
    {
E 56
E 32

I 40
D 41
      // skip file if not old enough
      struct stat buf;
      if(stat(argv[i],&buf)!=0) {
	cerr << "unable to read file stats for " << argv[i] << endl;
	continue;
      }
      if((now-buf.st_mtim.tv_sec)<min_file_age*3600) {
	cout << "skipping file " << argv[i] << " only " << (now-buf.st_mtim.tv_sec)/3600 
	     << " hours old" << endl;
	continue;
      }


E 41
E 40
D 32
      // collect data for recovery
I 27
      strstream sql_string;
E 27
D 19
      strstream sql_string;
D 14
      collect_recovery_data(argv[i],nrun,sql_string);
E 14
I 14
      status=collect_recovery_data(argv[i],nrun,sql_string);
E 19
I 19
      collect_recovery_data(argv[i],sql_string);
E 32
I 32
      ifstream file(argv[i]);
D 52
      if(!file.bad()) {
E 52
I 52
      if(file.is_open()) {
E 52
	
I 41
D 46
	// skip file if not old enough
E 46
I 46
D 56
	// extract run and session from filename
	strcpy(temp,argv[i]);
	char *p = strchr(strstr(temp,"runfile_"),'_')+1;
	*strchr(p,'_')=' ';
	sscanf(p,"%s %d.txt",session,&run);
E 56
I 56
	  // extract run and session from filename
	  strcpy(temp,argv[i]);
	  char *p = strchr(strstr(temp,"runfile_"),'_')+1;
	  *strchr(p,'_')=' ';
	  sscanf(p,"%s %d.txt",session,&run);
E 56
	
I 57
      if( strncmp(session,"clasprod",8) )
	  {
        /*printf("skip session >%s<\n",session);*/
        continue;
	  }
      else
	  {
        /*printf("run %d, session >%s<\n",run,session)*/;
	  }
E 57

D 56
	// skip file if current run and not old enough
	current_run=get_run_number(msql_database,session);
E 46
	if(find_tag_line(file,"*BOR*",line,sizeof(line))==0) {
	  get_next_line(file,line,sizeof(line));
	  int age = atoi(line);
D 46
	  if((now-age)<min_file_age*3600) {
	    cout << "skipping file " << argv[i] << " run only " << (now-age)/3600 
E 46
I 46
	  if((run==current_run)&&
	     ((now-age)<min_file_age*3600)) {
	    cout << "skipping file " << argv[i] << " current run file only " << (now-age)/3600 
E 46
		 << " hours old" << endl;
	    continue;
E 56
I 56
	  // skip file if current run and not old enough
	  current_run=get_run_number(msql_database,session);
	  if(find_tag_line(file,"*BOR*",line,sizeof(line))==0)
      {
	    get_next_line(file,line,sizeof(line));
	    int age = atoi(line);
	    if((run==current_run)&&
	       ((now-age)<min_file_age*3600))
        {
	      cout << "skipping file " << argv[i] << " current run file only " << (now-age)/3600 
		   << " hours old" << endl;
	      continue;
	    }
E 56
	  }
D 56
	}
E 56
	
	
E 41
D 56
	// don't process if already processed, unless forced
	if((force==0)&&(find_tag_line(file,"*run_log_end*",line,sizeof(line))==0)) {
	  file.close();
	  continue;
	}
E 56
I 56
	  // don't process if already processed, unless forced
	  if((force==0)&&(find_tag_line(file,"*run_log_end*",line,sizeof(line))==0))
      {
        cout << "skip: already processed" << endl;
	    file.close();
	    continue;
	  }
E 56
	
E 32
E 19
E 14

D 14
      // ship sql string to database router
      if((no_dbr==0)&&(debug==0))insert_into_database(sql_string.str());
E 14
I 14
D 16
      // ship sql string to database router...nrun=0 means file already processed or no data
E 16
I 16
D 32
      // ship sql string to database router
E 16
D 19
      if((no_dbr==0)&&(debug==0)&&(status==0))insert_into_database(sql_string.str());
E 19
I 19
      if(debug==0)insert_into_ipc(sql_string.str());
E 32
I 32
D 46
	// extract run and session from filename
	strcpy(temp,argv[i]);
	char *p = strchr(strstr(temp,"runfile_"),'_')+1;
	*strchr(p,'_')=' ';
	sscanf(p,"%s %d.txt",session,&run);
	

E 46
D 56
	// collect data for recovery mode
	strstream sql_string;
D 34
	collect_data(sql_string,1);
E 34
I 34
	collect_data(sql_string,1,argv[i]);
E 56
I 56
	  // collect data for recovery mode
	  strstream sql_string;
	  collect_data(sql_string,1,argv[i]);
E 56
E 34


D 56
	// ship sql string to database router
	if(debug==0)insert_into_ipc(sql_string.str());
E 56
I 56
	  // ship sql string to database router
	  if(debug==0)insert_into_ipc(sql_string.str());
E 56

E 32
E 19
E 14
      
D 32
      // debug...just print sql string
D 15
      if((debug!=0)&&(nrun>0)){ 
E 15
I 15
D 19
      if((debug!=0)&&(status==0)){ 
E 15
	cout << "\nsql string for recovery run " << nrun << " is:\n\n" << sql_string.str()<<endl<<endl;
E 19
I 19
      if(debug!=0){ 
	cout << "\nsql string for recovery run " << run << " is:\n\n" << sql_string.str()<<endl<<endl;
E 32
I 32
D 56
	// write run end info to file
	if((no_file==0)&&(debug==0))insert_into_file();
E 56
I 56
	  // write run end info to file
	  if((no_file==0)&&(debug==0))insert_into_file();
E 56


D 56
	// debug...just print sql string
	if(debug!=0){ 
	  cout << "\nsql string for recovery run " << run << " is:\n\n" << sql_string.str()<<endl<<endl;
	}
E 56
I 56
	  // debug...just print sql string
	  if(debug!=0)
      { 
	    cout << "\nsql string for recovery run " << run << " is:\n\n" << sql_string.str()<<endl<<endl;
	  }
E 56

E 32
E 19
      }
    }
E 13
  }

I 13

D 19

E 19
  // allow gmd to acknowledge receipt and close connection
D 19
  if((debug==0)&&(no_dbr==0)){
    dbr_check((double) gmd_time);
E 19
I 19
  if(debug==0) {
    if(no_dbr==0)dbr_check((double) gmd_time);
E 19
    dbr_close();
  }
I 19
  
E 19

D 19

E 19
E 13
I 9
D 17
  // post shutdown message
  temp << "Process shutdown:    run_log_end" << ends;
  status=insert_msg("run_log_end","online","run_log_end","status",0,"STOP",0,temp.str());

I 16

E 17
E 16
E 9
  // done
  exit(EXIT_SUCCESS);
D 16

E 16
}
       

//----------------------------------------------------------------


D 14
void collect_data(int &run, strstream &sql){
E 14
I 14
D 19
int collect_data(int &run, strstream &sql){
E 19
I 19
D 32
void collect_data(strstream &sql){
E 32
I 32
D 34
void collect_data(strstream &sql, int recover) {
E 34
I 34
D 56
void collect_data(strstream &sql, int recover, char *recovery_filename) {
E 34
E 32
E 19
E 14


E 56
I 56
void
collect_data(strstream &sql, int recover, char *recovery_filename)
{
E 56
D 7
  m_result *result;
  m_row row_out;
E 7
D 13
  ostrstream query;
E 13
D 19
  static char end_date[30];
I 5
D 11
  char filebase[50];
  char line[120];
E 5
D 7
  long nevent, nlong, nbad, nfile;
E 7
I 7
D 9
  long nevent, nlong, nerror,  nfile;
E 7
  long fcup;
E 9
I 9
  long nevent,nlong,nerror,nfile;
E 11
I 11
  char location[80];
  char filename[80];
I 13
  char erfilename[200];
E 19
E 13
D 12
  char line[200];
E 12
I 12
D 15
  char line[500];
E 15
E 12
  long nevt,nlng,nerr;
E 11
D 10
  long faraday_cup;
  float livetime;
E 10
I 10
D 13
  long fcup_ungated, fcup_gated, clock_ungated, clock_gated;
E 13
I 13
D 15
  long fcup, fcup_active, fcup_live, clock, clock_active, clock_live;
E 15
E 13
E 10
E 9
D 19
  char *comma = ", ";
E 19
I 19
D 51
  char *comma = ",", *prime = "'";
E 51
I 51
  const char *comma = ",", *prime = "'";
E 51
E 19
D 7
  int i;
E 7
I 7
D 11
  int i,runfile;
E 11
I 11
  int i;
D 19
  long nfile  = 0;
  long nevent = 0;
  long nlong  = 0;
  long nerror = 0;
E 19
E 11
E 7
D 56
  
E 56

D 7
  // connect to msql database
  int connNum = msqlConnect(getenv("MSQL_TCP_HOST"));
  msqlSelectDB(connNum,msql_database);
  

  // form msql query, execute, then close msql connection
  // ??? use current_run.txt ???
  query << "select runNumber from sessions where name='"
	<< session <<"'"<<ends;
  msqlQuery(connNum,query.str());
  result = msqlStoreResult();
  row_out = msqlFetchRow(result);
  msqlClose(connNum);
  

E 7
D 32
  // get run number 
D 7
  run=atoi(row_out[0]);
E 7
I 7
  run=get_run_number(msql_database,session);
E 32
E 7

D 32

  // form end date
  tm *tstruct = localtime(&start);
  strftime(end_date, 25, "%d-%b-%Y %H:%M", tstruct);
  

E 32
D 5
  // debug...need to read this info from file written by ER at end transition
  nevent = nlong = nbad = nfile = 0;
E 5
I 5
D 11
  // read run summary file info
D 7
  ifstream file(run_summary_file);
E 7
I 7
  sprintf(line,run_summary_file,session);
E 11
I 11
D 13
  // read run file summary info and sum up stats
E 13
I 13
  // read ER run file summary info and sum up stats
I 30
  nfile  = 0;
  nevent = 0;
  nlong  = 0;
  nerror = 0;
E 30
E 13
D 19
  filename[0]=NULL;
D 13
  sprintf(line,run_file_summary,session,run);
E 11
  ifstream file(line);
E 13
I 13
  sprintf(erfilename,run_file_summary,session,run);
  ifstream file(erfilename);
E 19
I 19
  filebase[0]=NULL;
D 34
  sprintf(filename,run_file_summary,session,run);
  ifstream file(env_name("CLON_ROOT",filename));
E 34
I 34
D 56
  if(recover==0) {
E 56
I 56
  if(recover==0)
  {
E 56
    sprintf(temp,run_file_summary,session,run);
D 49
    strcpy(filename,env_name("CLON_ROOT",temp));
E 49
I 49
    strcpy(filename,env_name("CLON_PARMS",temp));
E 49
D 56
  } else {
E 56
I 56
  }
  else
  {
E 56
    strcpy(filename,recovery_filename);
  }
D 56
  ifstream file(filename);
E 34
E 19
E 13
E 7
D 11
  file.getline(line,sizeof(line));
D 7
  sscanf(line,"%s %d %d %d %d",filebase,&nevent,&nlong,&nbad,&nfile);
E 7
I 7
  sscanf(line,"%d %s %d %d %d %d",&runfile,filebase,&nevent,&nlong,&nerror,&nfile);
E 7
  file.close();
I 7
  //  if(runfile!=run){ cerr << "illegal run in file" << endl;  exit(EXIT_FAILURE);}
E 11
I 11
D 16
  if(!file.bad()){
D 15
    while(!file.eof()){
      if(get_next_line(file,line,sizeof(line))==0){
E 15
I 15
    if(find_tag_line(file,"*FILES*",line,sizeof(line))==0){
      while(get_next_line(file,line,sizeof(line))==0) {
E 15
	sscanf(line,"%s %s %d %d %d",location,filename,&nlng,&nevt,&nerr);
	nfile++;
	nlong+=nlng;
	nevent+=nevt;
	nerror+=nerr;
      }
E 16
I 16
D 52
  if(!file.bad()) {
E 52
I 52
  if(file.is_open()) {
E 56
E 52

I 56
  ifstream file(filename);
  if(file.is_open())
  {
E 56
    // search for FILES tag...start at beginning if not there (n.b. old files don't have the tag)
I 34
    // n.b. count words in kbytes
E 34
    if(find_tag_line(file,"*FILES*",line,sizeof(line))!=0)file.seekg(0,ios::beg);
D 56
    while(get_next_line(file,line,sizeof(line))==0) {
E 56
I 56
    while(get_next_line(file,line,sizeof(line))==0)
    {
E 56
D 19
      sscanf(line,"%s %s %d %d %d",location,filename,&nlng,&nevt,&nerr);
E 19
I 19
      sscanf(line,"%s %s %d %d %d",location,filebase,&nlng,&nevt,&nerr);
E 19
      nfile++;
D 34
      nlong+=nlng;
E 34
I 34
      nlong+=nlng/1024;
E 34
      nevent+=nevt;
      nerror+=nerr;
E 16
    }
I 19

    // search for L1STAT tag
D 56
    if(find_tag_line(file,"*L1STAT*",line,sizeof(line))==0) {
E 56
I 56
    if(find_tag_line(file,"*L1STAT*",line,sizeof(line))==0)
    {
E 56
      get_next_line(file,line,sizeof(line));
      istrstream l1stat(line,sizeof(line));
      for(i=0; i<12; i++) l1stat >> trig_file[i];
      trig_file[12]=nevent;
    }

I 32
    // get end date (default is now if no time in file)
    time_t eortime = start;
D 56
    if(find_tag_line(file,"*EOR*",line,sizeof(line))==0) {
E 56
I 56
    if(find_tag_line(file,"*EOR*",line,sizeof(line))==0)
    {
E 56
      get_next_line(file,line,sizeof(line));
      sscanf(line,"%d",&eortime);
    } 
    tm *tstruct = localtime(&eortime);
D 54
    strftime(end_date, 25, "%d-%b-%Y %H:%M", tstruct);
E 54
I 54
    /*sergey strftime(end_date, 25, "%d-%b-%Y %H:%M", tstruct);*/
    strftime(end_date,25,"%Y-%m-%d %H:%M:%S",tstruct);
E 54

E 32
E 19
    file.close();
I 33

D 56
  } else {
E 56
I 56
  }
  else
  {
E 56
    cerr << "Unable to open " << filename << endl;
I 39
    if(recover==0)exit(EXIT_FAILURE);
E 39
E 33
  }
E 11
E 7
E 5


D 16
  // create epics callbacks and wait for data cdev_pend_time seconds
D 9
  get_epics_data();
E 9
I 9
  // get_epics_data();
E 16
I 16
D 19
  // collect epics data
  // get_epics_data();   nothing yet...
E 16
E 9


E 19
I 9
D 13
  // read scalers out of VME and calculate livetime
D 10
  get_vme_data(faraday_cup,livetime);
E 10
I 10
  get_vme_data(fcup_ungated, fcup_gated, clock_ungated, clock_gated);
E 13
I 13
D 32
  // read scalers out of VME
E 32
I 32
  // read scalers from archive file
E 32
D 15
  get_vme_data(fcup, fcup_active, fcup_live, clock, clock_active, clock_live);
E 15
I 15
D 19
  get_vme_data();
E 19
I 19
  get_scaler_data();
E 19
E 15
E 13
E 10
E 9

I 9

I 11
D 13
  // remove extension from filename to create filebase
  *strrchr(filename,'.')='\0';
E 13
I 13
  // remove extension from last data file name to create filebase (handles abc.def...xyz.a00)
D 19
  if(strrchr(filename,'.')!=NULL)*strrchr(filename,'.')='\0';
E 19
I 19
  if(strrchr(filebase,'.')!=NULL)*strrchr(filebase,'.')='\0';
E 19
E 13
E 11
I 10

I 11

E 11
E 10
E 9
  // create sql string
I 9
  sql.setf(ios::showpoint);
E 9
D 19
  sql << "insert into ingres.run_log_end"
D 5
      << "(run, end_date, nevent, nlong, nbad, nfile";
E 5
I 5
D 7
      << "(run, end_date, filebase, nevent, nlong, nbad, nfile";
E 7
I 7
D 9
      << "(run, end_date, filebase, nevent, nlong, nerror, nfile";
E 9
I 9
D 10
      << "(run, end_date, filebase, nevent, nlong, nerror, nfile, faraday_cup, livetime";
E 10
I 10
D 11
      << "(run, end_date, filebase, nevent, nlong, nerror, nfile,"
E 11
I 11
D 12
      << "(run, end_date, filebase, nfile, nlong, nevent, nerror,"
E 12
I 12
D 13
      << "(run, end_date, filebase, nfile, nlong, nevent, nerror, "
E 12
E 11
      << "fcup_ungated, fcup_gated, clock_ungated, clock_gated";
E 13
I 13
      << "(session_name, run, end_date, filebase, nfile, nlong, nevent, nerror, "
      << "fcup, fcup_active, fcup_live, clock, clock_active, clock_live";
E 19
I 19
D 54
  sql << "insert into ingres.run_log_end ("
E 54
I 54
  sql << "insert into run_log_end ("
E 54
      << "session_name,run,end_date,end_ok,filebase,nfile,nlong,nevent,nerror,"
D 21
      << "fcup,fcup_active,fcup_live,clock,clock_active,clock_live";
E 21
I 21
      << "clock,clock_active,clock_live,fcup,fcup_active,fcup_live";
E 21
  for(i=1; i<=12; i++) sql << comma << "trig_presc_bit" << i; 
  sql << comma << "trig_presc_all";
  for(i=1; i<=12; i++) sql << comma << "trig_event_bit" << i; 
  sql << comma << "trig_event_all";
  for(i=1; i<=12; i++) sql << comma << "trig_file_bit" << i; 
  sql << comma << "trig_file_all";
E 19
E 13
E 10
E 9
E 7
E 5

I 10
D 19

E 10
D 9
  for (i=0; i<sizeof(epics_chan)/sizeof(char *); i++){
D 3
    sql << comma << epics_name[i];
E 3
I 3
    sql << comma << db_name[i];
E 3
  }
E 9
I 9
//   for (i=0; i<sizeof(epics_chan)/sizeof(char *); i++){
//     sql << comma << db_name[i];
//   }
E 9

E 19
  sql << ") values ("
I 13
D 19
      << "'" << session << "'" << comma
E 13
      << run << comma
      << "'" << end_date << "'" << comma
I 5
D 11
      << "'" << filebase << "'" << comma
E 5
      << nevent << comma
E 11
I 11
      << "'" << filename << "'" << comma
      << nfile  << comma
E 11
      << nlong  << comma
I 11
      << nevent << comma
E 11
D 7
      << nbad   << comma
E 7
I 7
D 9
      << nerror   << comma
E 7
      << nfile;
E 9
I 9
      << nerror << comma
D 11
      << nfile  << comma
E 11
D 10
      << faraday_cup << comma
      << livetime;
E 10
I 10
D 13
      << fcup_ungated  << comma
      << fcup_gated    << comma
      << clock_ungated << comma
      << clock_gated;
E 13
I 13
D 15
      << fcup  << comma
E 15
I 15
      << fcup_all  << comma
E 15
      << fcup_active << comma
      << fcup_live    << comma
D 15
      << clock << comma
E 15
I 15
      << clock_all << comma
E 15
      << clock_active << comma
      << clock_live;
E 13
E 10
E 9

D 9
  for (i=0; i<sizeof(epics_chan)/sizeof(char *); i++){
    sql << comma << epics_val[i];
  }
E 9
I 9
//   for (i=0; i<sizeof(epics_chan)/sizeof(char *); i++){
//     sql << comma << epics_val[i];
//   }
E 19
I 19
      << prime << session << prime
      << comma << run
D 34
      << comma << prime << end_date << prime
      << ",'Y'"
      << comma << prime << filebase << prime
E 34
I 34
      << comma << prime << end_date << prime;
  if(recover==0) {sql << ",'Y'";} else {sql << ",'N'";}
  sql << comma << prime << filebase << prime
E 34
      << comma << nfile << comma << nlong << comma << nevent << comma << nerror
D 20
      << comma << fcup_all  << comma << fcup_active  << comma << fcup_live 
      << comma << clock_all << comma << clock_active << comma << clock_live;
E 20
I 20
D 21
      << comma << (long)fcup_all  << comma << (long)fcup_active  << comma << (long)fcup_live 
      << comma << (long)clock_all << comma << (long)clock_active << comma << (long)clock_live;
E 21
I 21
      << comma << (long)clock_all << comma << (long)clock_active << comma << (long)clock_live
      << comma << (long)fcup_all  << comma << (long)fcup_active  << comma << (long)fcup_live;
E 21
E 20
E 19
E 9
  
I 19
D 20
  for(i=0; i<13; i++) sql << comma << (T_INT4)trig_presc[i];
  for(i=0; i<13; i++) sql << comma << (T_INT4)trig_event[i];
  for(i=0; i<13; i++) sql << comma << (T_INT4)trig_file[i];
E 20
I 20
  for(i=0; i<13; i++) sql << comma << (long)trig_presc[i];
  for(i=0; i<13; i++) sql << comma << (long)trig_event[i];
  for(i=0; i<13; i++) sql << comma << (long)trig_file[i];
E 20

E 19
  sql << ")" << ends;
  

I 12
D 13
  // append sql string to file as backup
  sprintf(line,run_file_summary,session,run);
  ofstream ofile(line,ios::app);
  ofile << "\n\n#  " << sql.str() << endl;
  ofile.close();
E 13
I 13
  // append sql string to ER file as backup
D 36
  if(debug==0){
I 28
    sprintf(filename,run_file_summary,session,run);
E 28
D 19
    ofstream ofile(erfilename,ios::app);
E 19
I 19
D 26
    ofstream ofile(filename,ios::app);
E 26
I 26
    ofstream ofile(env_name("CLON_ROOT",filename),ios::app);
E 26
E 19
    ofile << "\n\n*run_log_end*" << endl;
E 36
I 36
D 56
  if(debug==0) {
E 36
D 31
    ofile << "#  Processed in normal mode on " << ctime(&start);
E 31
I 31
D 32
    ofile << "#  Processed in run_log_end normal mode on " << ctime(&start);
E 31
    ofile << sql.str() << endl << endl;
    ofile.close();
  }
E 13

I 13
D 14
  return;
E 14
I 14
D 19
  return(0);
E 19
I 19
  return;
E 19
E 14
}
E 13

I 13


//--------------------------------------------------------------------------


D 14
void collect_recovery_data(char *name_in, int &run, strstream &sql){
E 14
I 14
D 19
int collect_recovery_data(char *name_in, int &run, strstream &sql){
E 19
I 19
void collect_recovery_data(char *name_in, strstream &sql){
E 19
E 14


D 19
  char end_date[30];
  char location[80];
  char filename[80];
E 19
  char session_name[50];
D 15
  char line[500];
E 15
  long nevt,nlng,nerr;
D 19
  char *comma = ", ";
E 19
I 19
  char *comma = ",", *prime = "'";
E 19
  int i;
D 19
  long nfile  = 0;
  long nevent = 0;
  long nlong  = 0;
  long nerror = 0;
I 14
  int status  = 1;     // no data
E 19
E 14
D 27
  
E 27
I 27
  char *p;
E 27

I 27

I 30

E 30
E 27
D 14
  run=0;

E 14
  // read ER run file summary info and sum up stats
  ifstream file(name_in);
D 18
  if(!file.bad()){
E 18
I 18
  if(!file.bad()) {
E 18

D 14
    // check if file processed already
    if(find_tag_line(file,"*run_log_end*",line,sizeof(line))==0){
E 14
I 14
    // don't process if already processed, unless forced
D 18
    if((force==0)&&(find_tag_line(file,"*run_log_end*",line,sizeof(line))==0)){
E 18
I 18
    if((force==0)&&(find_tag_line(file,"*run_log_end*",line,sizeof(line))==0)) {
E 18
E 14
      file.close();
D 14
      return;
E 14
I 14
D 19
      return(1);
E 19
I 19
      return;
E 19
E 14
    }
    
D 15
    // rewind file and process
    file.seekg(0,ios::beg);
E 15
I 15
    // process file
E 15
D 19
    filename[0]=NULL;
E 19
I 19
    filebase[0]=NULL;
E 19
D 15
    while(!file.eof()){
      if(get_next_line(file,line,sizeof(line))==0){
E 15
I 15
D 16
    if(find_tag_line(file,"*FILES*",line,sizeof(line))==0){
      while(get_next_line(file,line,sizeof(line))==0){
E 15
I 14
	status=0;
E 14
	sscanf(line,"%s %s %d %d %d",location,filename,&nlng,&nevt,&nerr);
	nfile++;
	nlong+=nlng;
	nevent+=nevt;
	nerror+=nerr;
      }
E 16
I 16

    // search for FILES tag...start at beginning if not there (n.b. old files don't have the tag)
I 30
    nfile  = 0;
    nevent = 0;
    nlong  = 0;
    nerror = 0;
E 30
    if(find_tag_line(file,"*FILES*",line,sizeof(line))!=0)file.seekg(0,ios::beg);
    while(get_next_line(file,line,sizeof(line))==0){
D 19
      status=0;
      sscanf(line,"%s %s %d %d %d",location,filename,&nlng,&nevt,&nerr);
E 19
I 19
      sscanf(line,"%s %s %d %d %d",location,filebase,&nlng,&nevt,&nerr);
E 19
      nfile++;
      nlong+=nlng;
      nevent+=nevt;
      nerror+=nerr;
E 16
    }
I 18

I 19
    // search for L1STAT tag
    if(find_tag_line(file,"*L1STAT*",line,sizeof(line))==0) {
      get_next_line(file,line,sizeof(line));
      istrstream l1stat(line,sizeof(line));
      for(i=0; i<12; i++) l1stat >> trig_file[i];
      trig_file[12]=nevent;
    }
E 19

    // form end date using EOR tag in file, or current time if EOR tag not in file
    if(find_tag_line(file,"*EOR*",line,sizeof(line))==0) {
      get_next_line(file,line,sizeof(line));
      time_t eor=atoi(line);
      tm *tstruct = localtime(&eor);
      strftime(end_date, 25, "%d-%b-%Y %H:%M", tstruct);
E 32
I 32
    if(recover==0) {
E 56
I 56
  if(debug==0)
  {
    if(recover==0)
    {
E 56
D 36
      ofile << "#  Processed in run_log_end normal mode on " << ctime(&start);
E 36
I 36
      sprintf(temp,run_file_summary,session,run);
D 49
      strcpy(filename,env_name("CLON_ROOT",temp));
E 49
I 49
      strcpy(filename,env_name("CLON_PARMS",temp));
E 49
E 36
E 32
D 56
    } else {
E 56
I 56
    }
    else
    {
E 56
D 32
      tm *tstruct = localtime(&start);
      strftime(end_date, 25, "%d-%b-%Y %H:%M", tstruct);
E 32
I 32
D 36
      ofile << "#  Processed in run_log_end recovery mode on " << ctime(&start);
E 36
I 36
      strcpy(filename,recovery_filename);
E 36
E 32
    }
D 32
  
E 18
    file.close();
  }


  // extract run and session from filename
D 27
  char *name = strdup(name_in);
  char *p = strchr(strstr(name,"runfile_"),'_')+1;
E 27
I 27
  strcpy(temp,name_in);
  p = strchr(strstr(temp,"runfile_"),'_')+1;
E 27
  *strchr(p,'_')=' ';
  sscanf(p,"%s %d.txt",session_name,&run);


D 18
  // form end date
  tm *tstruct = localtime(&start);
  strftime(end_date, 25, "%d-%b-%Y %H:%M", tstruct);
  

E 18
  // remove extension from last data file name to create filebase (handles abc.def...xyz.a00)
D 19
  if(strrchr(filename,'.')!=NULL)*strrchr(filename,'.')='\0';
E 19
I 19
  if(strrchr(filebase,'.')!=NULL)*strrchr(filebase,'.')='\0';
E 19


  // create sql string
  sql.setf(ios::showpoint);
D 19
  sql << "insert into ingres.run_log_end"
      << "(session_name, run, end_date, filebase, nfile, nlong, nevent, nerror"
      << ") values ("
      << "'" << session_name << "'" << comma
      << run << comma
      << "'" << end_date << "'" << comma
      << "'" << filename << "'" << comma
      << nfile  << comma
      << nlong  << comma
      << nevent << comma
      << nerror;
E 19
I 19
  sql << "insert into ingres.run_log_end ("
      << "session_name,run,end_date,end_ok,filebase,nfile,nlong,nevent,nerror";
  for(i=1; i<=12; i++) sql << comma << "trig_file_bit" << i; 
  sql << comma << "trig_file_all";
  
  sql << ") values ("
      << prime << session_name << prime
      << comma << run
      << comma << prime << end_date << prime
      << ",'N'"
      << comma << prime << filebase << prime
      << comma << nfile << comma << nlong << comma << nevent << comma << nerror;
E 19

I 19
D 20
  for(i=0; i<13; i++) sql << comma << (T_INT4)trig_file[i];
E 20
I 20
  for(i=0; i<13; i++) sql << comma << (long)trig_file[i];
E 20

E 19
  sql << ")" << ends;
  

D 14
  // append sql string to ER file as backup
  if(debug==0){
E 14
I 14
  // append sql string to ER file as backup if found file data
D 19
  if((status==0)&&(debug==0)){
E 19
I 19
  if(debug==0) {
E 19
E 14
    ofstream ofile(name_in,ios::app);
    ofile << "\n\n*run_log_end*" << endl;
D 31
    ofile << "#  Processed in recovery mode on " << ctime(&start);
E 31
I 31
    ofile << "#  Processed in run_log_end recovery mode on " << ctime(&start);
E 32
E 31
D 36
    ofile << sql.str() << endl << endl;
    ofile.close();
E 36
I 36
    ofstream ofile(filename,ios::app);
D 52
    if(!ofile.bad()) {
E 52
I 52
D 56
    if(ofile.is_open()) {
E 56
I 56
    if(ofile.is_open())
    {
E 56
E 52
      ofile << "\n\n*run_log_end*" << endl;
D 56
      if(recover==0) {
	ofile << "#  Processed in run_log_end normal mode on " << ctime(&start);
      } else {
	ofile << "#  Processed in run_log_end recovery mode on " << ctime(&start);
E 56
I 56
      if(recover==0)
      {
	    ofile << "#  Processed in run_log_end normal mode on " << ctime(&start);
E 56
      }
I 56
      else
      {
	    ofile << "#  Processed in run_log_end recovery mode on " << ctime(&start);
      }
E 56
      ofile << sql.str() << endl << endl;
      ofile.close();
    }
D 37
    
    return;
E 37
E 36
  }

I 37
  return;
}
E 37
E 13
E 12
D 14
  return;
E 14
I 14
D 19
  return(status);
E 19
I 19
D 36
  return;
E 19
E 14
}
E 36

D 36

E 36
D 37

E 37
//--------------------------------------------------------------------------


I 9
D 10
void get_vme_data(long &faraday_cup, float &livetime){
E 10
I 10
D 13
void get_vme_data(long &fcup_ungated, long &fcup_gated, long &clock_ungated, long &clock_gated){
E 13
I 13
D 15
void get_vme_data(long &fcup, long &fcup_active, long &fcup_live, 
		  long &clock, long &clock_active, long &clock_live){
E 15
I 15
D 19
void get_vme_data(void){
E 19
I 19
D 56
void get_scaler_data(void){
E 19
E 15
E 13
E 10

E 56
I 56
void
get_scaler_data(void)
{
E 56
D 10
  int status,clock_ungated,clock_gated;
E 10
I 10
D 19
  int status;
E 19
I 19
D 32
  int i;
E 32
I 32
D 34
  int i,j;
E 34
I 34
  int i,j,k,ind;
E 34
E 32
E 19
E 10

I 15
D 56

E 56
D 19
  // default values
   fcup_all=-1;  fcup_active=-1;  fcup_live=-1;
  clock_all=-1; clock_active=-1; clock_live=-1;
E 19
I 19
D 32
  // get VME eor scalers using callable DP_ask
  DP_cmd_init(getenv("MSQL_TCP_HOST"));
  DP_cmd("scaler1","exec read_scaler1_eor()",line,3);
  istrstream scal_dp(line,sizeof(line));
  for(i=0; i<64; i++) scal_dp >> eor_scalers[i];
E 32
I 32
D 43
  // get eor scaler data from file
E 43
I 43
D 47
  // get scaler data from dd2scaler file
E 47
I 47
  // get scaler data from scaler file
E 47
E 43
  for(i=0; i<64; i++)eor_scalers[i]=0;
D 43
  sprintf(filename,scaler_eor_name,session,run);
E 43
I 43
D 47
  sprintf(filename,dd2scaler_file_name,session,run);
E 47
I 47
  sprintf(filename,scaler_file_name,session,run);
E 47
E 43
D 49
  ifstream eor_file(env_name("CLON_ROOT",filename));
E 49
I 49
D 53
  ifstream eor_file(env_name("CLON_PARMS",filename));
E 49
D 52
  if(!eor_file.bad()) {
E 52
I 52
  if(eor_file.is_open()) {
E 52
D 44
    if(find_tag_line(eor_file,"*TRGS*",line,sizeof(line))==0) {
E 44
I 44
    if(find_tag_line(eor_file,"*TRGS00*",line,sizeof(line))==0) {
E 44
      for(i=0; i<64; i+=8) {
	get_next_line(eor_file,line,sizeof(line));
	istrstream eor(line,sizeof(line));
	for(j=i; j<i+8; j++) eor >> eor_scalers[j];
E 53
I 53
  ifstream arch_file(env_name("CLON_PARMS",filename));
D 56
  if(arch_file.is_open()) {
      if(find_tag_line(arch_file,"*TRGS00*",line,sizeof(line))==0) {
	  for(i=0; i<64; i+=8) {
E 56
I 56
  if(arch_file.is_open())
  {
      if(find_tag_line(arch_file,"*TRGS00*",line,sizeof(line))==0)
      {
	    for(i=0; i<64; i+=8)
        {
E 56
	      get_next_line(arch_file,line,sizeof(line));
	      istrstream arch(line,sizeof(line));
	      for(j=i; j<i+8; j++) arch >> eor_scalers[j];
D 56
	  }
E 56
I 56
	    }
E 56
E 53
      }
D 53
    }
    eor_file.close();
E 53
I 53
      arch_file.close();
      
E 53
I 39
D 56
  } else {
D 43
    cerr << "Unable to open scaler file " << filename << endl;
E 43
I 43
D 47
    cerr << "Unable to open eor dd2scaler file " << filename << endl;
E 47
I 47
D 53
    cerr << "Unable to open eor scaler file " << filename << endl;
E 53
I 53
      sprintf(filename,scaler_file_name,session,run);
      ifstream eor_file(env_name("CLON_PARMS",filename));
      if(eor_file.is_open()) {
	  if(find_tag_line(eor_file,"*TRGS00*",line,sizeof(line))==0) {
	      for(i=0; i<64; i+=8) {
E 56
I 56
  }
  else
  {
    sprintf(filename,scaler_file_name,session,run);
    ifstream eor_file(env_name("CLON_PARMS",filename));
    if(eor_file.is_open())
    {
	  if(find_tag_line(eor_file,"*TRGS00*",line,sizeof(line))==0)
      {
	    for(i=0; i<64; i+=8)
        {
E 56
		  get_next_line(eor_file,line,sizeof(line));
		  istrstream eor(line,sizeof(line));
		  for(j=i; j<i+8; j++) eor >> eor_scalers[j];
D 56
	      }
E 56
I 56
	    }
E 56
	  }
	  eor_file.close();
D 56
      } else {
E 56
I 56
    }
    else
    {
E 56
	  cerr << "Unable to open scaler archive or eor file, run = " << run << endl;
D 56
      }
E 56
I 56
    }
E 56
E 53
E 47
E 43
E 39
  }
E 32
E 19
D 53

E 53
I 53
  
E 53
I 32

  // extract clocks and fcups
E 32
I 19
D 21
  fcup_all     = eor_scalers[ 0];
  clock_all    = eor_scalers[ 1];
  fcup_active  = eor_scalers[16];
  clock_active = eor_scalers[17];
  fcup_live    = eor_scalers[32];
  clock_live   = eor_scalers[33];
E 21
I 21
  clock_all    = eor_scalers[ 0];
  fcup_all     = eor_scalers[ 1];
  clock_active = eor_scalers[16];
  fcup_active  = eor_scalers[17];
  clock_live   = eor_scalers[32];
  fcup_live    = eor_scalers[33];
E 21
  for(i=0; i<13; i++) trig_presc[i]=eor_scalers[48+i];
  
E 19

E 15
D 16
  // read scalers and write to file
D 10
  status=fork_and_wait("/usr/local/clas/bin/get_eor_scalers");
E 10
I 10
D 15
  // status=fork_and_wait("/usr/local/clas/bin/get_eor_scalers");
E 15
I 15
  status=fork_and_wait(get_eor_scalers,10);
E 15
E 10

D 10
  // read file
E 10
I 10
D 15
  // read file...1st line is ungated, 2nd line is gated
E 10
  ifstream file("/usr/local/clas/parms/run_log/vme_eor_scalers.txt");
D 10
  file >> faraday_cup >> clock_ungated >> clock_gated;
E 10
I 10
D 13
  file >> fcup_ungated >> clock_ungated; 
E 13
I 13
  file >> fcup >> clock; 
E 13
  file.ignore(1000,'\n');    // skip remainder of this line
D 13
  file >> fcup_gated >> clock_gated; 
E 13
I 13
  file >> fcup_active >> clock_active; 
  file.ignore(1000,'\n');    // skip remainder of this line
  file >> fcup_live >> clock_live; 
E 13
E 10
  file.close();
E 15
I 15
  // read file
E 16
I 16
D 19
  // read get_eor_scalers output file
E 16
  ifstream file(eor_scaler_file);
  if(!file.bad()){
D 17
    if(find_tag_line(file,"*TRIG*",line,sizeof(line)==0)){
E 17
I 17
    if(find_tag_line(file,"*TRGS*",line,sizeof(line)==0)){
E 19
I 19
D 32
  // read event scaler info from scaler archive file (S1ST tag)
  sprintf(filename,scaler_archive_name,run);
E 32
I 32
D 47
  // read software scaler info from dd2scaler archive file (S1ST tag)
E 47
I 47
  // read software scaler info from scaler archive file (S1ST tag)
E 47
  for(i=0; i<13; i++) trig_event[i]=0;
D 38
  sprintf(filename,dd2scaler_file_name,run);
E 38
I 38
D 47
  sprintf(filename,dd2scaler_file_name,session,run);
E 47
I 47
  sprintf(filename,scaler_file_name,session,run);
E 47
E 38
E 32
D 49
  ifstream file(env_name("CLON_ROOT",filename));
E 49
I 49
  ifstream file(env_name("CLON_PARMS",filename));
E 49
D 52
  if(!file.bad()) {
E 52
I 52
  if(file.is_open()) {
E 52
D 34
    if(find_tag_line(file,"*S1ST*",line,sizeof(line))==0) {
E 34
I 34
    if(find_tag_line(file,"*S1ST00*",line,sizeof(line))==0) {
E 34
E 19
E 17
      get_next_line(file,line,sizeof(line));
D 19
      sscanf(line,"%u %u",&clock_all,&fcup_all);
      get_next_line(file,line,sizeof(line));
      sscanf(line,"%u %u",&clock_active,&fcup_active);
      get_next_line(file,line,sizeof(line));
      sscanf(line,"%u %u",&clock_live,&fcup_live);
E 19
I 19
D 34
      istrstream scal_file(line,sizeof(line));
      for(i=0; i<13; i++) scal_file >> trig_event[i];
E 34
I 34
      k=0; ind=0; for(i=0; i<8; i++) {k+=ind; sscanf(&line[k],"%d %n",&trig_event[i],&ind);}
      get_next_line(file,line,sizeof(line));
      k=0; ind=0; for(i=8; i<13; i++) {k+=ind; sscanf(&line[k],"%d %n",&trig_event[i],&ind);}
E 34
E 19
    }
I 51
    file.close();
E 51
I 39
  } else {
D 43
    cerr << "Unable to open scaler file " << filename << endl;
E 43
I 43
D 47
    cerr << "Unable to open dd2scaler file " << filename << endl;
E 47
I 47
    cerr << "Unable to open scaler file " << filename << endl;
E 47
E 43
E 39
D 19
    file.close();
E 19
  }
E 15

I 19

E 19
D 10
  // calculate livetime
  livetime=(clock_ungated>0)?((float)clock_gated/(float)clock_ungated):0.0;

E 10
  return;
}


//---------------------------------------------------------------------------


E 9
D 19
void get_epics_data(){
E 19
I 19
D 56
void insert_into_ipc(char *sql){
E 19

D 19
  cdevGroup group;
E 19

E 56
I 56
void
insert_into_ipc(char *sql)
{
E 56
I 27
  if(sql==NULL)return;


E 27
I 19
  // dbr message
  if(no_dbr==0) {
E 19

D 3
  // ??? need deferred group ???

E 3
D 19
  // count number of callbacks received
  ncallback=0;


  // create callback for each channel in one group (for efficiency in CA)
  group.start();
  for(int i=0; i<sizeof(epics_chan)/sizeof(char *); i++){
    epics_val[i]=-1;
D 3
    cdevRequestObject *obj = cdevRequestObject::attachPtr(epics_chan[i],"get");
E 3
I 3
    cdevRequestObject *obj = cdevRequestObject::attachPtr(epics_chan[i],epics_get[i]);
E 3
    cdevCallback cb(epics_callback_func,(void*)i);
    obj->sendCallback(NULL,cb);
E 19
I 19
D 51
    TipcMsg dbr = TipcMsg("dbr_request");
E 51
I 51
    TipcMsg dbr = TipcMsg((T_STR)"dbr_request");
E 51
    dbr.Dest(dest);
    dbr.Sender(uniq_dgrp);
    dbr.UserProp(0.0);
    dbr.DeliveryMode(T_IPC_DELIVERY_ALL);
    
    // fill and send message 
    dbr << (T_INT4) 1 << sql;
    server.Send(dbr);
E 19
  }


D 19
  // process group of callbacks
  group.pend((double)cdev_pend_time);
E 19
I 19
  // info server message
  if(no_info==0) {
E 19

D 19
  
  // check if all callbacks received
  if(ncallback<sizeof(epics_chan)/sizeof(char *))
    cerr << "?only received " << ncallback << " callbacks" << " out of " 
	 << sizeof(epics_chan)/sizeof(char *) << endl;
E 19
I 19
D 51
    TipcMsg info = TipcMsg("info_server");
D 42
    info.Dest("info_server");
E 42
I 42
    info.Dest("info_server/in/run_log_end");
E 51
I 51
    TipcMsg info = TipcMsg((T_STR)"info_server");
    info.Dest((T_STR)"info_server/in/run_log_end");
E 51
E 42
    info.Sender(uniq_dgrp);
D 42
    info.UserProp(0.0);
    info.DeliveryMode(T_IPC_DELIVERY_BEST_EFFORT);
E 42
    
    // fill and send msg
D 51
    info << "run_log_end"
E 51
I 51
    info << (T_STR)"run_log_end"
E 51
	 << session << (T_INT4) run << end_date 
	 << filebase << (T_INT4) nfile << (T_INT4) nlong << (T_INT4) nevent << (T_INT4) nerror
D 21
	 << (T_INT4) fcup_all << (T_INT4) fcup_active  << (T_INT4) fcup_live 
	 << (T_INT4) clock_all << (T_INT4) clock_active << (T_INT4) clock_live;
E 21
I 21
	 << (T_INT4) clock_all << (T_INT4) clock_active << (T_INT4) clock_live
	 << (T_INT4) fcup_all << (T_INT4) fcup_active  << (T_INT4) fcup_live;
E 21
    server.Send(info);
  }
E 19


D 19
  return;
}
E 19
I 19
  // flush messages
  server.Flush();
E 19


D 19
//---------------------------------------------------------------------------


void epics_callback_func(int status, void *userarg, cdevRequestObject &epics_req_obj,
			    cdevData& result){

  ncallback++;
  epics_val[(int)userarg] = (int) result;

E 19
  return;
}

I 19
//----------------------------------------------------------------
  
E 19

D 19
//---------------------------------------------------------------------------
E 19
I 19
D 56
void insert_into_file(){
E 19

E 56
I 56
void
insert_into_file()
{
E 56
I 24
  int i;
E 24
I 19
D 21
  char filename[200];
E 21
E 19

I 24

E 24
D 19
void insert_into_database(char *entry){
E 19
I 19
D 22
  sprintf(filename,archive_file_name,run,session);
E 22
I 22
  sprintf(filename,archive_file_name,session,run);
E 22
D 49
  ofstream file(env_name("CLON_ROOT",filename));
E 49
I 49
  ofstream file(env_name("CLON_PARMS",filename));
E 49
D 52
  if(file.bad()) return;
E 52
I 52
  if(!file.is_open()) return;
E 52
E 19


I 14
D 19
  // bombproof
  if(strlen(entry)==strspn(entry," \t\n\r\b"))return;
E 19
I 19
  file << "\n*SESSION*\n"  << session << endl;
  file << "\n*RUN*\n"      << run << endl;
  file << "\n*END_DATE*\n" << end_date << endl;
  file << "\n*FILEBASE*\n" << filebase << endl;
D 23
  file << "\n*FILES*\n"    << nfile << " " << nlong << " " << nevent << " " << nerror << endl;
E 19
D 21

E 21
I 19
  file << "\n*SCALERS\n" << filebase << endl;
D 21
  file << fcup_all  << " " << fcup_active  << " " << fcup_live   << endl;
E 21
  file << clock_all << " " << clock_active << " " << clock_live << endl;
I 21
  file << fcup_all  << " " << fcup_active  << " " << fcup_live   << endl;
E 23
I 23
  file << "\n*FILES* --- nfile,nlong,nevent,nerror" << endl;
D 25
  file << setw(15) << nfile << " " << nlong << " " << nevent << " " << nerror << endl;
E 25
I 25
  file << nfile << " " << nlong << " " << nevent << " " << nerror << endl;
E 25
  file << "\n*SCALERS* --- clock all,active,live; fcup all,active,live" << endl;
D 25
  file << setw(15) << clock_all << " " << clock_active << " " << clock_live << endl;
  file << setw(15) << fcup_all  << " " << fcup_active  << " " << fcup_live  << endl;
E 25
I 25
  file << clock_all << " " << clock_active << " " << clock_live << endl;
  file << fcup_all  << " " << fcup_active  << " " << fcup_live  << endl;
E 25
E 23
E 21
E 19

I 24
  file << "\n*PRESCALE_COUNT*" << endl;
  for(i=0; i<13; i++) file << trig_presc[i] << " ";
  file << endl;

  file << "\n*EVENT_COUNT*\n";
  for(i=0; i<13; i++) file << trig_event[i] << " ";
  file << endl;

  file << "\n*FILE_COUNT*\n";
  for(i=0; i<13; i++) file << trig_file[i] << " ";
  file << endl;

E 24
E 14
D 13
  // disable gmd timeout
  T_OPTION opt=TutOptionLookup("Server_Delivery_Timeout");
  TutOptionSetNum(opt,0.0);


  // connect to server
  TipcSrv &server=TipcSrv::Instance();
  dbr_init(uniq_dgrp,application,id_string);


E 13
D 19
  // construct dbr_request message
  TipcMsg msg = TipcMsg("dbr_request");
  msg.Dest(dest);
  msg.Sender(uniq_dgrp);
  msg.UserProp(0.0);
  msg.DeliveryMode(T_IPC_DELIVERY_ALL);
E 19
D 23

E 23
I 19
  file.close();
E 19

D 19
  // fill message 
  msg << (T_INT4) 1 << entry;


  // send, flush msg
  server.Send(msg);
  server.Flush();


E 19
D 13
  // allow gmd to acknowledge receipt
  dbr_check((double) gmd_time);


  // close ipc connection
  dbr_close();


E 13
  return;
}

I 19

E 19
//----------------------------------------------------------------
  

I 15
D 25
void insert_into_mapmgr(int &run){
  
  float flt;

D 19
  map_put_float(mapmgr_file_name, "Faraday_cup", "Q_all"    ,1, &(flt=fcup_all),    run);
  map_put_float(mapmgr_file_name, "Faraday_cup", "Q_active" ,1, &(flt=fcup_active), run);
  map_put_float(mapmgr_file_name, "Faraday_cup", "Q_live"   ,1, &(flt=fcup_live),   run);
E 19
I 19
  map_put_float(env_name("CLON_ROOT",mapmgr_file_name),"Faraday_cup","Q_all"   ,1,&(flt=fcup_all), run);
  map_put_float(env_name("CLON_ROOT",mapmgr_file_name),"Faraday_cup","Q_active",1,&(flt=fcup_active),run);
  map_put_float(env_name("CLON_ROOT",mapmgr_file_name),"Faraday_cup","Q_live"  ,1,&(flt=fcup_live), run);
E 19

  return;
}


//----------------------------------------------------------------
  

E 25
E 15
D 8
void insert_into_dd(int &run, char *entry){
  
  int status;
  int *p,i,nused,banksize,nhead,buflen;
  struct fifo_mode fmode;
  fifo_entry fev;
  int ctl[4] = {-1,-1,-1,-1};


  // connect to DD system INPUT fifo
  fmode.mode     = FMODE_ALL;
  fmode.wait     = FWAIT_SLEEP;
  fmode.suser    = FMODE_MULTI_USER;
  fmode.prescale = 1;
  fmode.p2ctl    = ctl;
  status=ddu_init("INPUT",fmode);
  if(status!=0){
    cerr << "?unable to attach to DD system INPUT fifo, status is: " << status << endl;
    return;
  }


  // get free fifo event
  status=ddu_req_fev(DDBUFFERSIZE,&fev);
  if(status!=0){
    cerr << "?unable to get fev, status is: " << status << endl;
    return;
  }


  // set pointer, reset counts, fill ctl words, etc.
  p=fev.p2da;
  nused=0;
  nhead=0;
  fev.ctlw1=ddctl[0];
  fev.ctlb1=ddctl[1];
  fev.ctlw2=ddctl[2];
  fev.ctlb2=ddctl[3];


  // create segment header, then update pointer and counters
  status=create_header(p,DDBUFFERSIZE-nused,nhead,run,nevnt,nphys,trig);
  if(status==0){
    p+=nhead;
    nused+=nhead;
  }  


  // head bank
  status=va_add_bank(p,DDBUFFERSIZE-nused,"HEAD",0,"I",8,1,8,banksize,
	      nvers,run,nevnt,start,type,rocst,evcls,presc);
  if(status==0){
    p+=banksize;
    nused+=banksize;
  }


  // fill data bank with logbook info
  buflen=strlen(entry)/4;
D 4
  status=add_bank(p,DDBUFFERSIZE-nused,"RNLG",2,"A",1,1,buflen,banksize,(int *)entry);
E 4
I 4
  status=add_bank(p,DDBUFFERSIZE-nused,"RNLG",3,"A",1,1,buflen,banksize,(int *)entry);
E 4
  if(status==0){
    p+=banksize;
    nused+=banksize;
  }


  // all banks added...set fev and fpack overall word counts
  fev.len=nused;
  *(fev.p2da+10)=nused-nhead;


  // insert event into DD system
  status=ddu_put_fev(fev);
  if(status!=0){
    cerr << "?unable to put fev, status is: " << status << endl;
    return;
  }


  // disconnect from DD system
  ddu_close();


  return;
}

  
//----------------------------------------------------------------


E 8
D 56
void decode_command_line(int argc, char **argv)
E 56
I 56
void
decode_command_line(int argc, char **argv)
E 56
{
D 56

E 56
  int i=1;
D 51
  char *help="\nusage:\n\n  run_log_end [-a application] [-u uniq_dgrp] [-i id_string] [-debug]\n"
E 51
I 51
  const char *help="\nusage:\n\n  run_log_end [-a application] [-u uniq_dgrp] [-i id_string] [-debug]\n"
E 51
D 5
               "        [-d destination]  [-m msql_database]\n"
E 5
I 5
D 11
               "        [-d destination]  [-m msql_database]  [-f run_summary_file]\n"
E 11
I 11
D 15
               "        [-d destination]  [-m msql_database]  [-f run_file_summary]\n"
E 11
E 5
D 8
               "        [-s session]      [-no_dbr]        [-no_dd]  [-g gmd_time] [-c cdev_pend_time]\n\n\n";
E 8
I 8
               "        [-s session]      [-no_dbr]        [-g gmd_time] [-c cdev_pend_time]\n\n\n";
E 15
I 15
D 19
               "        [-d destination] [-m msql_database]] [-f run_file_summary]\n"
               "        [-no_mapmgr] [-map mapmgr_file_name]\n"
               "        [-s session] [-no_dbr] [-g gmd_time] [-c cdev_pend_time] file1 file2 ...\n\n\n";
E 19
I 19
               "        [-d destination] [-m msql_database]]\n"
D 25
               "        [-no_dbr] [-no_info] [-no_file] [-no_mapmgr]\n"
E 25
I 25
D 40
               "        [-no_dbr] [-no_info] [-no_file] \n"
E 40
I 40
               "        [-no_dbr] [-no_info] [-no_file] [-mf min_file_age]\n"
E 40
E 25
D 55
               "        [-s session] [-g gmd_time] [-c cdev_pend_time] file1 file2 ...\n\n\n";
E 55
I 55
               "        [-s session] [-g gmd_time] file1 file2 ...\n\n\n";
E 55
E 19
E 15
E 8

D 56

E 56
  while(i<argc) {
    
    if(strncasecmp(argv[i],"-h",2)==0){
      printf(help);
      exit(EXIT_SUCCESS);
    }
I 13
    else if (strncasecmp(argv[i],"-",1)!=0){
      filep=i;
      return;
    }
E 13
    else if (strncasecmp(argv[i],"-debug",6)==0){
      debug=1;
      i=i+1;
    }
I 14
    else if (strncasecmp(argv[i],"-force",6)==0){
      force=1;
      i=i+1;
    }
E 14
    else if (strncasecmp(argv[i],"-no_dbr",7)==0){
      no_dbr=1;
      i=i+1;
    }
I 19
    else if (strncasecmp(argv[i],"-no_info",8)==0){
      no_info=1;
      i=i+1;
    }
    else if (strncasecmp(argv[i],"-no_file",8)==0){
      no_file=1;
      i=i+1;
    }
I 40
    else if (strncasecmp(argv[i],"-mf",3)==0){
      min_file_age=atoi(argv[i+1]);
      i=i+2;
    }
E 40
E 19
I 15
D 25
    else if (strncasecmp(argv[i],"-no_mapmgr",10)==0){
      no_mapmgr=1;
      i=i+1;
    }
E 25
D 19
    else if (strncasecmp(argv[i],"-map",4)==0){
      mapmgr_file_name=strdup(argv[i+1]);
      i=i+2;
    }
E 19
E 15
D 8
    else if (strncasecmp(argv[i],"-no_dd",6)==0){
      no_dd=1;
      i=i+1;
    }
E 8
    else if (strncasecmp(argv[i],"-a",2)==0){
      application=strdup(argv[i+1]);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-u",2)==0){
      uniq_dgrp=strdup(argv[i+1]);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-i",2)==0){
      id_string=strdup(argv[i+1]);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-d",2)==0){
      dest=strdup(argv[i+1]);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-g",2)==0){
      gmd_time=atoi(argv[i+1]);
      i=i+2;
    }
I 5
D 19
    else if (strncasecmp(argv[i],"-f",2)==0){
D 11
      run_summary_file=strdup(argv[i+1]);
E 11
I 11
      run_file_summary=strdup(argv[i+1]);
E 11
      i=i+2;
    }
E 19
E 5
D 55
    else if (strncasecmp(argv[i],"-c",2)==0){
      cdev_pend_time=atoi(argv[i+1]);
      i=i+2;
    }
E 55
    else if (strncasecmp(argv[i],"-s",2)==0){
D 32
      session=strdup(argv[i+1]);
E 32
I 32
      strcpy(session,argv[i+1]);
E 32
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-m",2)==0){
      msql_database=strdup(argv[i+1]);
      i=i+2;
    }
  }
}


D 19
/*---------------------------------------------------------------------*/
E 19
I 19
//---------------------------------------------------------------------
E 19

I 19

D 51
char *env_name(char *env, char *name) {
E 51
I 51
D 56
char *env_name(const char *env, char *name) {
E 51

E 56
I 56
char *
env_name(const char *env, char *name)
{
E 56
  static char bigname[200];
  char *e=getenv(env);

  if(e!=NULL) {
    strcpy(bigname,e);
    strcat(bigname,"/");
    strcat(bigname,name);
  } else {
    strcpy(bigname,name);
  }
  
  return(bigname);
}


//---------------------------------------------------------------------
E 19
E 1
