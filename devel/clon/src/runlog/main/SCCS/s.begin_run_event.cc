h18973
s 00263/00188/01453
d D 1.62 07/10/29 11:36:51 boiarino 67 66
c migrated from cdev to ca
c 
e
s 00077/00055/01564
d D 1.61 07/10/12 10:23:04 boiarino 66 65
c *** empty log message ***
e
s 00060/00010/01559
d D 1.60 04/02/26 11:00:00 wolin 65 64
c Added TRCF, trigger config bank
e
s 00012/00014/01557
d D 1.59 02/09/25 15:12:23 wolin 64 63
c Increased maximums
e
s 00047/00028/01524
d D 1.58 02/09/25 14:51:11 wolin 63 62
c New compiler, many fixes
e
s 00007/00007/01545
d D 1.57 02/08/27 13:36:18 wolin 62 61
c New ped names, etc
e
s 00001/00001/01551
d D 1.56 02/08/09 19:39:09 boiarino 61 60
c static BOSIO *descriptor;
c 
e
s 00010/00008/01542
d D 1.55 01/11/15 09:37:46 wolin 60 59
c l1prog file name incorrect
e
s 00002/00002/01548
d D 1.54 01/04/02 15:15:06 wolin 59 58
c Bombproof .eof()
e
s 00001/00001/01549
d D 1.53 01/02/13 10:29:56 wolin 58 57
c Added RVAL
e
s 00011/00011/01539
d D 1.52 01/01/03 10:54:47 wolin 57 56
c is_open()
e
s 00046/00046/01504
d D 1.51 00/12/05 17:26:01 wolin 56 55
c New CC
e
s 00013/00012/01537
d D 1.50 00/12/05 16:55:43 wolin 55 51
i 54
c Accepted child's version in workspace "/usr/local/clas/devel/source".
c 
e
s 00001/00001/01549
d D 1.48.1.3 00/12/05 15:11:22 wolin 54 53
c torus_current
e
s 00002/00002/01548
d D 1.48.1.2 00/10/27 09:58:40 wolin 53 52
c const
e
s 00011/00010/01539
d D 1.48.1.1 00/10/27 09:56:51 wolin 52 49
c const
e
s 00001/00001/01548
d D 1.49 00/12/05 15:13:58 wolin 51 49
c torus_current
e
s 00001/00001/01548
d D 1.47.1.1 00/09/05 14:42:28 wolin 50 48
c New CC
e
s 00001/00001/01548
d D 1.48 00/09/08 15:10:03 wolin 49 48
c New euphrates file name
e
s 00119/00072/01430
d D 1.47 99/11/03 12:49:16 wolin 48 47
c Epics channels same as in epics_monitor
e
s 00030/00006/01472
d D 1.46 99/09/30 11:54:51 wolin 47 46
c Finished mlu bank
c 
e
s 00046/00015/01432
d D 1.45 99/09/09 15:15:23 wolin 46 45
c IPM2C22A renamed to IPM2C21A
c 
e
s 00006/00002/01441
d D 1.44 99/05/05 15:54:01 wolin 45 44
c Increased pend to 6 sec
c 
e
s 00003/00004/01440
d D 1.43 98/09/24 11:00:47 wolin 44 43
c Using new bosIoctl
c 
e
s 00036/00000/01408
d D 1.42 98/09/09 14:11:35 wolin 43 42
c Added bpm constants
c 
e
s 00050/00017/01358
d D 1.41 98/09/09 13:45:26 wolin 42 41
c Switched to epics_struct
c 
e
s 00001/00001/01374
d D 1.40 98/06/18 14:33:56 wolin 41 40
c Added harp
c 
e
s 00019/00019/01356
d D 1.39 98/05/07 10:45:19 wolin 40 39
c New epics channels
c 
e
s 00001/00001/01374
d D 1.38 98/05/04 17:46:09 wolin 39 38
c Typo in epics channel names
c 
e
s 00033/00035/01342
d D 1.37 98/04/30 12:21:17 wolin 38 37
c BREP seems to be working, bosNprint does not like F format
c 
e
s 00113/00032/01264
d D 1.36 98/04/30 10:36:35 wolin 37 36
c Added BREP event
c 
e
s 00014/00008/01282
d D 1.35 98/04/30 10:00:45 wolin 36 35
c TS now working
c 
e
s 00103/00085/01187
d D 1.34 98/04/28 17:31:12 wolin 35 34
c discr stuff now working
c 
e
s 00062/00045/01210
d D 1.33 98/04/28 17:07:36 wolin 34 33
c 5, not 6 words in discr banks
c 
e
s 00035/00039/01220
d D 1.32 98/04/28 16:57:35 wolin 33 32
c Using new pretrig format
c 
e
s 00005/00005/01254
d D 1.31 98/04/28 14:37:02 wolin 32 31
c Added _hard.spar
c 
e
s 00014/00010/01245
d D 1.30 98/04/28 14:35:22 wolin 31 30
c Redid spar file names
c 
e
s 00029/00123/01226
d D 1.29 98/04/27 17:44:26 wolin 30 29
c Removed hv events, got everything working except ttbl
c 
e
s 00008/00008/01341
d D 1.28 98/04/27 17:05:24 wolin 29 28
c Added () to bos formats
c 
e
s 00091/00043/01258
d D 1.27 98/04/27 14:05:20 wolin 28 27
c Bombproof against missing links
c 
e
s 00021/00000/01280
d D 1.26 98/04/27 12:58:01 wolin 27 26
c Added RNPE for cped, not needed for spar
c 
e
s 00008/00008/01272
d D 1.25 98/04/27 12:43:58 wolin 26 25
c Seems to be working for tped,cped,spar
c 
e
s 00033/00000/01247
d D 1.24 98/04/24 18:00:25 wolin 25 24
c Added RNPE bank
c 
e
s 00048/00019/01199
d D 1.23 98/04/24 15:24:16 wolin 24 23
c Worked around bosio bug using larger buffer size
c 
e
s 00021/00017/01197
d D 1.22 98/04/23 17:41:13 wolin 23 22
c tped,cped,spar seem to work
c 
e
s 00034/00022/01180
d D 1.21 98/04/23 11:21:44 wolin 22 21
c Fixed head bank
c 
e
s 00168/00017/01034
d D 1.20 98/04/23 10:59:42 wolin 21 20
c Redid some tped banks
c 
e
s 00353/00072/00698
d D 1.19 98/04/21 17:43:17 wolin 20 19
c Implemented new ped/spar system, commented out everything else
c 
e
s 00001/00000/00769
d D 1.18 98/02/19 10:26:56 wolin 19 18
c *** empty log message ***
e
s 00079/00009/00690
d D 1.17 98/02/04 18:16:52 wolin 18 17
c Compiles and links...but will it run?
c 
e
s 00142/00664/00557
d D 1.16 98/02/04 17:17:56 wolin 17 16
c Still working on new file scheme...
c 
e
s 00002/00002/01219
d D 1.15 97/11/19 09:28:21 wolin 16 15
c New head bank scheme
c 
e
s 00007/00007/01214
d D 1.14 97/11/17 16:09:48 wolin 15 14
c create_header args now include name1,name2
c 
e
s 00001/00002/01220
d D 1.13 97/10/24 16:01:38 wolin 14 13
c Seems to be working...minor fpack problem with B32 format
c 
e
s 00136/00074/01086
d D 1.12 97/10/24 13:45:28 wolin 13 12
c Added debug, no_dd flags, changed bank formats
c 
e
s 00069/00077/01091
d D 1.11 97/08/25 13:55:34 wolin 12 11
c Added pretrig,discr events
c 
e
s 00342/00085/00826
d D 1.10 97/08/25 11:41:48 wolin 11 10
c Added discr and pretrig events, other minor reorganizations
c 
e
s 00370/00228/00541
d D 1.9 97/06/02 12:59:21 wolin 10 9
c Now adds L1PG bank
e
s 00101/00043/00668
d D 1.8 97/05/23 16:53:04 wolin 9 8
c New threshold stuff, now using find_tag_line, etc.
e
s 00098/00031/00613
d D 1.7 97/05/20 09:34:32 wolin 8 7
c Added ts program
e
s 00102/00018/00542
d D 1.6 97/05/12 13:20:49 wolin 7 6
c Added l1 thresholds
e
s 00214/00006/00346
d D 1.5 97/05/09 12:59:44 wolin 6 5
c Added HV event for BMTA
e
s 00073/00076/00279
d D 1.4 97/05/08 11:36:07 wolin 5 4
c Now creates sparsification threshold event
e
s 00002/00002/00353
d D 1.3 97/04/15 14:35:41 wolin 4 3
c Minor mods for testing
e
s 00077/00002/00278
d D 1.2 97/04/15 13:04:55 wolin 3 1
c Now adds 2 fake events, TS and L1
e
s 00000/00000/00000
d R 1.2 97/04/14 16:20:12 Codemgr 2 1
c SunPro Code Manager data about conflicts, renames, etc...
c Name history : 2 1 run_log/s/begin_run_event.cc
c Name history : 1 0 s/begin_run_event.cc
e
s 00280/00000/00000
d D 1.1 97/04/14 16:20:11 wolin 1 0
c Inserts begin run events (ts, l1, etc.)
e
u
U
f e 0
t
T
I 1
D 18
//
E 18
//  begin_run_event
//
I 18
D 20
//   Inserts begin run events into special parameter file, run at BOR
E 20
I 20
D 30
//   Inserts begin run events into special bos/fpack parameter file, run at BOR
E 30
I 30
//   Inserts parameter events into special bos/fpack parameter file
E 30
E 20
E 18
D 5
//   inserts begin run event info into datastream, including:
//        trigger supervisor program
//        level 1 trigger settings
//        discriminator settings
//        sparsification thresholds
//
//
E 5
D 11
//  usage:
D 10
//     begin_run_event  [-m msql_database] [-s session]
E 10
I 10
//     begin_run_event  [-m msql_database] [-s session] [-debug]
E 11
E 10
//
I 34
//  still to do:
//    RUNPARMS
D 38
//    SCPT
I 36
//    check ALL banks...TS, etc.
E 38
E 36
E 34
I 22
D 30
//  still to do:
//    run number for each ped file
E 30
E 22
I 11
D 13
//   Inserts begin run event in datastream
E 13
I 13
D 17
//   Gigantic program inserts ALL begin run events into datastream
E 13
//   Note:  assumes pretrig and discr data previously read out into files
E 17
I 17
D 18
//   Gigantic program inserts begin run events into special parameter file
//   Should execute at BOR
E 18
E 17
E 11
//
I 22
D 30
//
E 30
E 22
D 11
//   still to do:
//       get header ctl words, event class correct
E 11
D 18
//
E 18
I 11
D 20
//     Currently stores                            source
//     ----------------                            ------
D 17
//     sparsification thresholds                   5 files downloaded into hardware
//     pretrigger settings                         hardware (via pre-existing intermediate file)
//     discriminatior settings                     hardware (via pre-existing intermediate file)
//     trigger supervisor program                  hardware (via intermediate file created here)
E 17
I 17
//     sparsification thresholds                   hardware 
//     pretrigger settings                         hardware 
//     discriminatior settings                     hardware 
//     trigger supervisor program                  hardware 
E 17
//     level 1 trigger program                     file downloaded into hardware
//     bmta (LeCroy) HV settings                   epics (via cdev) using file of channel names
//     ccecsc (LeCroy) HV setings                  epics (via cdev) using file of channel names
E 11
//
D 5
//  ejw, 14-apr-97
E 5
I 5
D 9
//  Currently stores:
//        sparsification thresholds
I 7
//        bmta (LeCroy) HV settings
I 8
//        level 1 threshold settings
E 9
I 9
D 11
//     Currently stores                            from
D 10
//     -----------------                            ----
E 10
I 10
//     ----------------                            ----
E 10
//     sparsification thresholds                   file at download
D 10
//     bmta and ccescc (LeCroy) HV settings        epics from file of channel names
//     level 1 threshold settings                  file at download
E 10
I 10
//     bmta (LeCroy) HV settings                   epics using file of channel names
//     pretrigger threshold settings               file at download
E 10
//     trigger supervisor program                  hardware via intermediate file
E 11
E 9
E 8
E 7
//
E 20
D 11
//
E 11
D 9
//  Note...one day will store in datastream:
I 8
//        trigger supervisor program 
E 8
I 7
//        CAEN high voltage settings
//        remaining LeCroy high voltage settings
E 9
I 9
D 21
//  Still to do:
D 10
//        pretrigger thresholds, widths, masks
E 10
I 10
D 11
//        insert_msg
//        ccecsc (LeCroy) HV setings
//        remaining pretrigger thresholds, widths, masks
E 10
E 9
E 7
D 8
//        trigger supervisor program 
E 8
D 7
//        level 1 trigger file 
//        discriminator file 
//        contents of level 1 threshold files
//        high voltage settings
E 7
I 7
//        level 1 trigger 
E 11
D 9
//        discriminator settings
E 9
I 9
D 20
//        CAEN high voltage settings
E 9
D 8
//        level 1 threshold settings
E 8
E 7
D 11
//        translation tables
E 11
I 11
D 17
//        translation tables (???)
D 13
//        insert_msg
//        enable all event code (split?)
E 13
//        get header ctl words, event class correct
E 17
I 17
//        translation tables
//        pedestal data???
E 20
E 17
I 12
D 13
//        silently drops ndisc>MAXDISCR
E 13
I 13
//        silently drops ndisc>MAXDISCR, same for other banks???
D 17
//        split this program up?
E 17
E 13
E 12
E 11
//
D 17
//
D 7
//  ejw, 8-may-97
E 7
I 7
D 11
//  ejw, 9-may-97
E 11
I 11
//  ejw, 25-aug-97
E 17
I 17
//  ejw, 4-feb-98
E 21
I 21
//  ejw, 23-apr-98
I 67
// sergey 29-oct-2007 migrate from cdev to ca
E 67
E 21
E 17
E 11
E 7
E 5


// for posix
#define _POSIX_SOURCE_ 1
#define __EXTENSIONS__


D 6
//  DD buffer size
#define DDBUFFERSIZE  5000     // longwords
E 6
I 6
D 17
//  DD buffer sizes in longwords
D 7
#define SPBUFFERSIZE   5000
#define HVBUFFERSIZE  40000
E 7
I 7
D 13
#define SPBUFFERSIZE         5000
E 13
I 13
#define SPBUFFERSIZE        10000
E 13
#define HVBUFFERSIZE        40000
D 9
#define L1THRESHBUFFERSIZE   1000
I 8
#define TSBUFFERSIZE        40000
E 9
I 9
D 10
#define THRESHBUFFERSIZE   1000
E 10
I 10
D 11
#define THRESHBUFFERSIZE     1000
E 11
I 11
#define PRETRIGBUFFERSIZE    5000
#define DISCRBUFFERSIZE      5000
E 11
E 10
#define TSBUFFERSIZE        20000
I 10
#define L1BUFFERSIZE        10000
E 17
I 17
D 20
// sizes of temporary arrays
E 20
I 20
// temporary array sizes
E 20
D 64
#define MAXPRETRIG     200  
#define MAXHV         5000
D 35
#define MAXDISCR       100
E 35
I 35
#define MAXDISCR      1000
E 35
D 20
#define L1SIZE       20000
E 20
I 20
#define MAXL1        20000
#define MAXPED       20000
I 47
#define MAXMLU       20000
E 64
I 64
#define MAXPRETRIG    1000  
#define MAXHV        10000
#define MAXDISCR      5000
#define MAXL1        50000
I 65
#define MAXTRIG      50000
E 65
#define MAXPED       50000
#define MAXMLU       50000
E 64
E 47
E 20
E 17
I 12
D 13
#define MAXPRETRIG          200  
E 13
E 12
E 10
E 9
E 8
E 7
E 6

I 13
D 17
#define MAXPRETRIG            200  
E 17
E 13

I 13
D 17

E 17
E 13
// system stuff
I 66

using namespace std;
#include <strstream>

E 66
#include <iostream.h>
#include <fstream.h>
D 66
#include <strstream.h>
E 66
#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
I 18
#include <stdarg.h>
E 18
I 6
D 66
#include <macros.h>
E 66
I 25
#include <unistd.h>
E 25
E 6

I 67
#include "epicsutil.h"
E 67
I 17

E 17
I 9
D 14

E 14
E 9
I 6
D 67
// for cdev
#include <cdev.h>
#include <cdevData.h>
#include <cdevDevice.h>
#include <cdevRequestObject.h>
#include <cdevSystem.h>
E 6

I 6

E 67
I 18
// for bosio
#define NBCS 100000
D 20
extern "C"{
E 20
I 20
extern "C" {
E 20
D 67
#include <bosio.h>
#include <bos.h>
#include <bcs.h>
E 67
I 67
#include "bosio.h"
#include "bos.h"
#include "bcs.h"
E 67
D 20
int bosNprint(int*, char*, int);
E 20
}


E 18
E 6
D 17
// online and coda stuff
extern "C"{
#include <dd_user.h>
D 10
#include <msql.h>
E 10
}


// for record segment header
static int nevnt  = 0;
static int nphys  = 0;
D 11
static int trig   = 17;               // fpack class, 17 for prestart event, 0 for normal event, etc.
E 11
I 11
static int trig   = 0;
E 11


// constants for head bank
static int nvers  = 0;
D 11
static int type   = 1;
E 11
I 11
D 16
static int type   = 0;
E 16
I 16
static int type   = 102;
E 16
E 11
static int rocst  = 0;
D 11
static int evcls  = 17;               // fpack class again?
static int presc  = 1;
E 11
I 11
static int evcls  = 0;
D 16
static int presc  = 100;
E 16
I 16
static int presc  = 0;
E 16
E 11


// DD event control words
static int ddctl[4] = {-1,-1,-1,-1};


E 17
D 20
// parameters resettable on command line
E 20
I 20
// misc 
E 20
D 52
D 55
static char *msql_database  = "clasrun";
E 55
I 55
static char *msql_database  = (char*)"clasrun";
E 55
E 52
I 52
static char *msql_database  = (char*)"clasrun";
E 52
D 13
static char *session        =  getenv("DD_NAME");
I 10
static int debug            =  0;
E 13
I 13
D 62
static char *session        = getenv("DD_NAME");
E 62
I 62
static char *session        = (char*)"clastest";
E 62
I 20
static char *clon_parms     = getenv("CLON_PARMS");
D 52
D 55
static char *file_loc       = "/raid/stage_in";
E 55
I 55
static char *file_loc       = (char*)"/raid/stage_in";
I 65
static char *trig_name      = (char*)"/trigger/current_trig_config.cfg";
E 65
E 55
E 52
I 52
static char *file_loc       = (char*)"/raid/stage_in";
E 52
E 20
D 17
static int no_dd            = 0;
E 17
static int debug            = 0;
I 20
static int run;
D 61
static int descriptor;
E 61
I 61
static BOSIO *descriptor;
E 61
D 64
static char buffer[200];
static char filename[200];
E 64
I 64
static char buffer[512];
static char filename[512];
E 64
D 60
static char temp[64];
E 60
I 60
D 63
static char temp[1024];
E 63
I 63
static char temp[4096];
E 63
E 60
I 25
static char temp2[128];
I 63
static char temp3[128];
E 63
E 25
E 20
E 13
E 10

I 6

D 37
// for epics hv
D 17
#define MAX_HV 5000
D 13
static int cdev_pend_time      	       = 60;
E 13
I 13
D 14
static int cdev_pend_time      	       = 10;
E 14
I 14
static int cdev_pend_time      	       = 7;
E 14
E 13
static int ncallback           	       = 0;
static char channel[MAX_HV][29];             // 32(32A) - 4(.DVI) + 1 (/0)
static char channel_get[MAX_HV][10];
static int channel_val[MAX_HV];
E 17
I 17
D 20
static int cdev_pend_time      	   = 7;
E 20
I 20
static int cdev_pend_time      	   = 4;
E 20
static int ncallback           	   = 0;
static char channel[MAXHV][29];            // 32(32A) - 4(.DVI) + 1 (null)
static char channel_get[MAXHV][10];
static int channel_val[MAXHV];
E 37
I 37
// for epics channels
D 42
static int ncallback        = 0;
E 42
D 45
static int cdev_pend_time   = 2;
E 45
I 45
D 67
static int cdev_pend_time   = 6;
E 67
E 45
D 42
static char *epics_chan[] = {
D 40
  "MBSY2C_energy", "IGT0I00BIASET", "unknown",
E 40
I 40
  "MBSY2C_energy", "IGT0I00BIASET", "IGL1I00DAC2",
E 40
D 41
  "SMRPOSA", "SMRPOSB", "SMRPOSC", "unknown",
E 41
I 41
  "SMRPOSA", "SMRPOSB", "SMRPOSC", "Harp",
E 41
D 38
  "hallb_sf_xy560_0_5", "MTIRDBK", "MTVRBCK", "TMIRDBK", "TMVRBCK",
E 38
I 38
D 39
  "hallb_sf_xy560_0_5", "MTSETI", "MTIRDBK", "MTVRBCK", "TMSETI", "TMIRDBK", "TMVRBCK",
E 39
I 39
  "hallb_sf_xy560_0_5", "MTSETI", "MTIRBCK", "MTVRBCK", "TMSETI", "TMIRBCK", "TMVRBCK",
E 39
E 38
  "B_cryotarget_pressure", "B_cryotarget_temperature", "B_cryotarget_status",
D 40
  "unknown","unknown",
E 40
I 40
  "VCG2C24","VCG2H01",
E 40
  "scalerS2o", "scalerS3o", "scalerS4o", "scalerS5o", 
  "scalerS6o", "scalerS7o", "scalerS8o", "scalerS9o", 
  "IPM2H01.XPOS","IPM2H01.YPOS","IPM2H01",
  "IPM2C24A.XPOS","IPM2C24A.YPOS","IPM2C24A",
  "IPM2C22A.XPOS","IPM2C22A.YPOS","IPM2C22A",
E 42
I 42
struct epics_struct {
D 52
D 55
  char *name;
  char *chan;
  char *get;
E 55
I 55
  const char *name;
  const char *chan;
  const char *get;
E 55
E 52
I 52
  const char *name;
  const char *chan;
  const char *get;
E 52
E 42
};
D 42
static float epics_val[sizeof(epics_chan)/sizeof(char *)];
static int nepics    = sizeof(epics_chan)/sizeof(char *);
cdevRequestObject *obj[sizeof(epics_chan)/sizeof(char *)];
cdevCallback *cb[sizeof(epics_chan)/sizeof(char *)];
E 42
E 37
E 17

I 42
D 67
static epics_struct epics[] = {
D 48
"beam_energy",            "MBSY2C_energy",              "get",
"thermionic_gun",	  "IGT0I00BIASET",              "get",
"polarized_gun",	  "IGL1I00DAC2",                "get",
"a_slit_position",	  "SMRPOSA", 			"get",
"b_slit_position",	  "SMRPOSB",                    "get",
"c_slit_position",	  "SMRPOSC", 			"get",
"radiator_position",	  "harp", 			"get",
"torus_current",	  "hallb_sf_xy560_0_5", 	"get",
"mini_current_set",	  "MTSETI",                     "get",
"mini_current",		  "MTIRBCK", 			"get",
"mini_voltage", 	  "MTVRBCK", 			"get",
"tagger_current_set",	  "TMSETI", 			"get",
"tagger_current",	  "TMIRBCK", 			"get",
"tagger_voltage",	  "TMVRBCK", 			"get",
"cryo_pressure",	  "B_cryotarget_pressure", 	"get",
"cryo_temperature",	  "B_cryotarget_temperature", 	"get",
"cryo_status",		  "B_cryotarget_status",        "get",
"upstream_beam_vac",	  "VCG2C24", 			"get",
"target_vac",		  "VCG2H01", 			"get",
"halo_up_up",		  "scalerS2o", 			"get",
"halo_up_down",		  "scalerS3o", 			"get",
"halo_up_left",		  "scalerS4o", 			"get",
"halo_up_right", 	  "scalerS5o", 			"get",
"halo_down_up",		  "scalerS6o", 			"get",
"halo_down_down",	  "scalerS7o", 			"get",
"halo_down_left",	  "scalerS8o", 			"get",
"halo_down_right",	  "scalerS9o", 			"get",
"bpm_1_x",		  "IPM2H01",   			"get XPOS",
"bpm_1_y",		  "IPM2H01", 			"get YPOS",
"bpm_1_i",		  "IPM2H01", 			"get",
"bpm_2_x",		  "IPM2C24A", 			"get XPOS",
"bpm_2_y",		  "IPM2C24A", 			"get YPOS",
"bpm_2_i", 		  "IPM2C24A",                   "get",
D 46
"bpm_3_x",		  "IPM2C22A", 			"get XPOS",
"bpm_3_y",		  "IPM2C22A", 			"get YPOS",
"bpm_3_i",		  "IPM2C22A", 			"get",
E 46
I 46
"bpm_3_x",		  "IPM2C21A", 			"get XPOS",
"bpm_3_y",		  "IPM2C21A", 			"get YPOS",
"bpm_3_i",		  "IPM2C21A", 			"get",
E 46
I 43
"bpm_1_x_kmf",		  "IPM2H01", 			"get XKMF",
"bpm_1_y_kmf",		  "IPM2H01", 			"get YKMF",
"bpm_1_i_kmf",		  "IPM2H01", 			"get IKMF",
"bpm_1_x_pho",		  "IPM2H01", 			"get XPHO",
"bpm_1_y_pho",		  "IPM2H01", 			"get YPHO",
"bpm_1_i_pho",		  "IPM2H01", 			"get IPHO",
"bpm_1_x_ghi",		  "IPM2H01", 			"get XGHI",
"bpm_1_y_ghi",		  "IPM2H01", 			"get YGHI",
"bpm_1_i_ghi",		  "IPM2H01", 			"get IGHI",
"bpm_2_x_kmf",		  "IPM2C24A", 			"get XKMF",
"bpm_2_y_kmf",		  "IPM2C24A", 			"get YKMF",
"bpm_2_i_kmf",		  "IPM2C24A", 			"get IKMF",
"bpm_2_x_pho",		  "IPM2C24A", 			"get XPHO",
"bpm_2_y_pho",		  "IPM2C24A", 			"get YPHO",
"bpm_2_i_pho",		  "IPM2C24A", 			"get IPHO",
"bpm_2_x_ghi",		  "IPM2C24A", 			"get XGHI",
"bpm_2_y_ghi",		  "IPM2C24A", 			"get YGHI",
"bpm_2_i_ghi",		  "IPM2C24A", 			"get IGHI",
D 46
"bpm_3_x_kmf",		  "IPM2C22A", 			"get XKMF",
"bpm_3_y_kmf",		  "IPM2C22A", 			"get YKMF",
"bpm_3_i_kmf",		  "IPM2C22A", 			"get IKMF",
"bpm_3_x_pho",		  "IPM2C22A", 			"get XPHO",
"bpm_3_y_pho",		  "IPM2C22A", 			"get YPHO",
"bpm_3_i_pho",		  "IPM2C22A", 			"get IPHO",
"bpm_3_x_ghi",		  "IPM2C22A", 			"get XGHI",
"bpm_3_y_ghi",		  "IPM2C22A", 			"get YGHI",
"bpm_3_i_ghi",		  "IPM2C22A", 			"get IGHI",
E 46
I 46
"bpm_3_x_kmf",		  "IPM2C21A", 			"get XKMF",
"bpm_3_y_kmf",		  "IPM2C21A", 			"get YKMF",
"bpm_3_i_kmf",		  "IPM2C21A", 			"get IKMF",
"bpm_3_x_pho",		  "IPM2C21A", 			"get XPHO",
"bpm_3_y_pho",		  "IPM2C21A", 			"get YPHO",
"bpm_3_i_pho",		  "IPM2C21A", 			"get IPHO",
"bpm_3_x_ghi",		  "IPM2C21A", 			"get XGHI",
"bpm_3_y_ghi",		  "IPM2C21A", 			"get YGHI",
"bpm_3_i_ghi",		  "IPM2C21A", 			"get IGHI",
E 46
"bpm_1_x_scale",	  "IPM2H01XSENrbstr",		"get STR1",
"bpm_1_y_scale",	  "IPM2H01YSENrbstr",		"get STR1",
"bpm_1_i_scale",	  "IBC2H01ISENrbstr",		"get STR1",
"bpm_2_x_scale",	  "IPM2C24AXSENrbstr",		"get STR1",
"bpm_2_y_scale",	  "IPM2C24AYSENrbstr",		"get STR1",
"bpm_2_i_scale",	  "IBC2C24AISENrbstr",		"get STR1",
D 46
"bpm_3_x_scale",	  "IPM2C22AXSENrbstr",		"get STR1",
"bpm_3_y_scale",	  "IPM2C22AYSENrbstr",		"get STR1",
"bpm_3_i_scale",	  "IBC2C22AISENrbstr",		"get STR1",
E 46
I 46
"bpm_3_x_scale",	  "IPM2C21AXSENrbstr",		"get STR1",
"bpm_3_y_scale",	  "IPM2C21AYSENrbstr",		"get STR1",
"bpm_3_i_scale",	  "IBC2C21AISENrbstr",		"get STR1",
E 48
I 48
  "Hall A energy",         	 	    	  "MBSY1C_energy",             "get",
  "Hall B energy",         	 	    	  "MBSY2C_energy",             "get",
  "Hall C energy",         	 	    	  "MBSY3C_energy",             "get",
  "Hall A beam current",                          "IBC1H03AAVG",               "get",
  "Hall B beam current",       	 	    	  "IBC2C24AVG",                "get",
  "Hall C beam current",                          "IBC3H00AVG",                "get",
  "A Laser Duty Factor",                          "IGL1I00HALLADF",            "get",
  "B Laser Duty Factor",                          "IGL1I00HALLBDF",            "get",
  "C Laser Duty Factor",                          "IGL1I00HALLCDF",            "get",
  //  "Hall A status",                                "PLC_HLA",                   "get",
  //  "Hall B status",                                "PLC_HLB",                   "get",
  //  "Hall C status",                                "PLC_HLC",                   "get",
  "A slit position",           	 	    	  "SMRPOSA",                   "get",
  "B slit position",           	 	    	  "SMRPOSB",                   "get",
  "C slit position",           	 	    	  "SMRPOSC",                   "get",
  "A polarized gun",           	 	    	  "IGL1I00DAC0",               "get",
  "B polarized gun",           	 	    	  "IGL1I00DAC2",               "get",
  "C polarized gun",           	 	    	  "IGL1I00DAC4",               "get",
  "e2_target_a_status",                           "e2_target_a_status",        "get",
  "e2_target_b_status",				  "e2_target_b_status",        "get",
  "e2_target_c_status",				  "e2_target_c_status",        "get",
  "thermionic gun",          	 	    	  "IGT0I00BIASET",             "get",
D 58
  "beam phase",                                   "IGL1I00OD16_16",            "get",
E 58
I 58
  "beam phase",                                   "IGL1I00OD16_16",            "get RVAL",
E 58
D 51
D 54
  "torus current",	     	 	    	  "hallb_sf_xy560_0_5",        "get",
E 51
I 51
  "torus current",	     	 	    	  "torus_current",             "get",
E 51
E 54
I 54
  "torus current",	     	 	    	  "torus_current",             "get",
E 54
  "mini current setpoint",     	 	    	  "MTSETI",                    "get",
  "mini current readback",     	 	    	  "MTIRBCK",                   "get",
  "mini voltage",	     	 	    	  "MTVRBCK",                   "get",
  "tagger current setpoint",   	 	    	  "TMSETI",                    "get",
  "tagger current readback",	 	    	  "TMIRBCK",                   "get",
  "tagger voltage",	     	 	    	  "TMVRBCK",                   "get",
  "Hall B Helicity",     			  "hallb:helicity",  	       "get",    
  "Harp",	        	 	    	  "harp",                      "get DRBV",
  "Scaler clock",	     	 	    	  "scalerS1o",                 "get",
  "Faraday cup",	     	 	    	  "scaler_calc1",              "get",
  "Halo U upstream",	     	 	    	  "scalerS2o",                 "get",
  "Halo D upstream",	     	 	    	  "scalerS3o",                 "get",
  "Halo L upstream",	     	 	    	  "scalerS4o",                 "get",
  "Halo R upstream",	     	 	    	  "scalerS5o",                 "get",
  "Halo U downstream",	     	 	    	  "scalerS6o",                 "get",
  "Halo D downstream",	     	 	    	  "scalerS7o",                 "get",
  "Halo L downstream",	     	 	    	  "scalerS8o",                 "get",
  "Halo R downstream",	     	 	    	  "scalerS9o",                 "get",
  "CC O2 monitor lamp",	     	 	    	  "cc_o2_ref",                 "get",
  "CC O2 monitor gas",	     	 	    	  "cc_o2_sig",                 "get",
  "Tagger turbo speed (%)",    	    	          "VMP2C24SPD",                "get",
  "Moeller vacuum (V)",	     	 	    	  "VCG2C21",                   "get",
  "Upstream beam vacuum (V)",  	 	    	  "VCG2C24",                   "get",
  "Target vacuum (V)",	     	 	    	  "VCG2H01",                   "get",
  "Faraday cup ion pump (KV)",  	    	  "VIP2H01DV",                 "get",
  "Faraday cup ion pump (ma)",    	          "VIP2H01DI",                 "get",
  "bpm_1_x",     	     	 	    	  "IPM2H01.XPOS",              "get",
  "bpm_1_y",     	     	 	    	  "IPM2H01.YPOS",              "get",
  "bpm_1_i",     	     	 	    	  "IPM2H01",                   "get",
  "bpm_1_x_gain",     	     	 	    	  "IPM2H01",                   "get XKMF",
  "bpm_1_y_gain",     	     	 	    	  "IPM2H01",                   "get YKMF",
  "bpm_1_i_gain",     	     	 	    	  "IPM2H01",                   "get IKMF",
  "bpm_1_x_scale",	  			  "IPM2H01XSENrbstr",	       "get STR1",
  "bpm_1_y_scale",	  			  "IPM2H01YSENrbstr",	       "get STR1",
  "bpm_1_i_scale",	  			  "IBC2H01ISENrbstr",	       "get STR1",
  "bpm_2_x",     	     	 	    	  "IPM2C24A.XPOS",             "get",
  "bpm_2_y",     	     	 	    	  "IPM2C24A.YPOS",             "get",
  "bpm_2_i",     	     	 	    	  "IPM2C24A",                  "get",
  "bpm_2_i_gain",     	     	 	    	  "IPM2C24A",                  "get XKMF",
  "bpm_2_x_gain",     	     	 	    	  "IPM2C24A",                  "get YKMF",
  "bpm_2_y_gain",     	     	 	    	  "IPM2C24A",                  "get IKMF",
  "bpm_2_x_scale",	  			  "IPM2C24AXSENrbstr",	       "get STR1",
  "bpm_2_y_scale",	  			  "IPM2C24AYSENrbstr",	       "get STR1",
  "bpm_2_i_scale",	  			  "IBC2C24AISENrbstr",	       "get STR1",
  "bpm_3_x",     	     	 	    	  "IPM2C21A.XPOS",             "get",
  "bpm_3_y",     	     	 	    	  "IPM2C21A.YPOS",             "get",
  "bpm_3_i",     	     	 	    	  "IPM2C21A",                  "get",
  "bpm_3_x_gain",     	     	 	    	  "IPM2C21A",                  "get XKMF",
  "bpm_3_y_gain",     	     	 	    	  "IPM2C21A",                  "get YKMF",
  "bpm_3_i_gain",     	     	 	    	  "IPM2C21A",                  "get IKMF",
  "bpm_3_x_scale",	  			  "IPM2C21AXSENrbstr",	       "get STR1",
  "bpm_3_y_scale",	  			  "IPM2C21AYSENrbstr",	       "get STR1",
  "bpm_3_i_scale",	  			  "IBC2C21AISENrbstr",	       "get STR1",
  "Moller Quad1 current",   			  "hallb_sf_xy560_0_14",       "get",
  "Moller Quad2 current",   			  "hallb_sf_xy560_0_18",       "get",
  "Helmholtz Coils current",			  "hallb_sf_xy560_0_19",       "get",
  "Moller target position", 			  "moeller_target",            "get RBV",
  "Raster set energy",   			  "RASTSETENERGY",   	       "get",
  "Raster set pattern X",			  "RASTSETPATTERNX", 	       "get",
  "Raster set pattern Y",			  "RASTSETPATTERNY", 	       "get",
  "Raster X offset",     			  "RASTSETXOFFSET",  	       "get",
  "Raster Y offset",     			  "RASTSETYOFFSET",  	       "get",    
  "cryo target pressure",	 	    	  "B_cryotarget_pressure",     "get",
  "cryo target temperature",   	 	    	  "B_cryotarget_temperature",  "get",
  "cryo target status",	     	 	    	  "B_cryotarget_status",       "get",
  "torus he buf p (atm)",    	 	    	  "hallb_sf_xy560_0_6",        "get",
  "torus he tank p (atm)",   	 	    	  "hallb_sf_xy560_0_7",        "get",
  "torus cold he t (kelvin)",	 	    	  "hallb_sf_xy560_0_8",        "get",
  "torus ln2 tank pres (atm)", 	 	    	  "hallb_sf_xy560_0_9",        "get",
  "torus ln2 tank level (%)",    	    	  "hallb_sf_xy560_0_10",       "get",
  "torus he tank level (%)",     	    	  "hallb_sf_xy560_0_11",       "get",
  "torus svc module vac (-log torr)",	    	  "hallb_sf_xy560_0_12",       "get",
  "cryo target heat exch pressure",          	  "B_cryotarget_PT_2KH",       "get",
  "cryo target cryostat pressure",          	  "B_cryotarget_PT_5KH",       "get",
  "cryo target He3 tank pressure",          	  "B_cryotarget_PT_HES",       "get",
  "cryo target target pressure",            	  "B_cryotarget_PT_T",         "get",
  "cryo target beam screen temperature",    	  "B_cryotarget_TT_EBP",       "get",
  "cryo target 20k heater temperature",     	  "B_cryotarget_TT_E1",        "get",
  "cryo target 300k heater temperature",    	  "B_cryotarget_TT_ECR",       "get",
  "cryo target D2 tank pressure",           	  "B_cryotarget_PT_D2S",       "get",
  "cryo target H2 tank pressure",           	  "B_cryotarget_PT_H2S",       "get",
  "cryo target He cryostat level",          	  "B_cryotarget_LT_CR",        "get",
  "cryo target primary target vac",         	  "B_cryotarget_PT_VT",        "get",
  "cryo target primary chamber vac",        	  "B_cryotarget_PT_CVP",       "get",
  "cryo target secondary chamber vac",      	  "B_cryotarget_PT_CVS",       "get",
  "cryo target joule-thompson exch",    	  "B_cryotarget_JT_2K",        "get",
  "cryo target temperature",                	  "B_cryotarget_TT_T",         "get",
  "cryo target heat exch temperature",       	  "B_cryotarget_TT_ET",        "get",
  "cryo target heat exch exhaust temperature",	  "B_cryotarget_TT_ER1",       "get",
  "cryo target level low",                  	  "B_cryotarget_LS_TB",        "get",
  "cryo target level high",                 	  "B_cryotarget_LS_TH",        "get",
  "cryo target level low display",          	  "B_cryotarget_NIV_C_BAS",    "get",
  "cryo target level high display",         	  "B_cryotarget_NIV_C_HAUT",   "get",
  "cryo target level high by PT_T",         	  "B_cryotarget_NIV_BAS",      "get",
  "cryo target level low by PT_T",          	  "B_cryotarget_NIV_HAUT",     "get",
E 67
I 67
static char *epics_name[] = {
  "Hall A energy",
  "Hall B energy",
  "Hall C energy",
  "Hall A beam current",
  "Hall B beam current",
  "Hall C beam current",
  "A Laser Duty Factor",
  "B Laser Duty Factor",
  "C Laser Duty Factor",
  //  "Hall A status",
  //  "Hall B status",
  //  "Hall C status",
  "A slit position",
  "B slit position",
  "C slit position",
  "A polarized gun",
  "B polarized gun",
  "C polarized gun",
  "e2_target_a_status",
  "e2_target_b_status",
  "e2_target_c_status",
  "thermionic gun",
  "beam phase", 
  "torus current",
  "mini current setpoint",
  "mini current readback",
  "mini voltage",
  "tagger current setpoint",
  "tagger current readback",
  "tagger voltage",
  "Hall B Helicity",
  "Harp",
  "Scaler clock",
  "Faraday cup",
  "Halo U upstream",
  "Halo D upstream",
  "Halo L upstream",
  "Halo R upstream",
  "Halo U downstream",
  "Halo D downstream",
  "Halo L downstream",
  "Halo R downstream",
  "CC O2 monitor lamp",
  "CC O2 monitor gas",
  "Tagger turbo speed (%)",
  "Moeller vacuum (V)",
  "Upstream beam vacuum (V)",
  "Target vacuum (V)",
  "Faraday cup ion pump (KV)",
  "Faraday cup ion pump (ma)",
  "bpm_1_x",
  "bpm_1_y",
  "bpm_1_i", 
  "bpm_1_x_gain",
  "bpm_1_y_gain",
  "bpm_1_i_gain",
  "bpm_1_x_scale",
  "bpm_1_y_scale",
  "bpm_1_i_scale",
  "bpm_2_x",
  "bpm_2_y",
  "bpm_2_i",
  "bpm_2_i_gain",
  "bpm_2_x_gain",
  "bpm_2_y_gain",
  "bpm_2_x_scale",
  "bpm_2_y_scale",
  "bpm_2_i_scale",
  "bpm_3_x",
  "bpm_3_y",
  "bpm_3_i", 
  "bpm_3_x_gain",
  "bpm_3_y_gain",
  "bpm_3_i_gain",
  "bpm_3_x_scale",
  "bpm_3_y_scale",
  "bpm_3_i_scale",
  "Moller Quad1 current",
  "Moller Quad2 current",
  "Helmholtz Coils current",
  "Moller target position",
  "Raster set energy",
  "Raster set pattern X",
  "Raster set pattern Y",
  "Raster X offset",
  "Raster Y offset",   
  "cryo target pressure",
  "cryo target temperature",
  "cryo target status",
  "torus he buf p (atm)",
  "torus he tank p (atm)",
  "torus cold he t (kelvin)",
  "torus ln2 tank pres (atm)",
  "torus ln2 tank level (%)",
  "torus he tank level (%)",
  "torus svc module vac (-log torr)",
  "cryo target heat exch pressure",
  "cryo target cryostat pressure",
  "cryo target He3 tank pressure",
  "cryo target target pressure",
  "cryo target beam screen temperature",
  "cryo target 20k heater temperature",
  "cryo target 300k heater temperature",
  "cryo target D2 tank pressure",
  "cryo target H2 tank pressure",
  "cryo target He cryostat level",
  "cryo target primary target vac",
  "cryo target primary chamber vac",
  "cryo target secondary chamber vac",
  "cryo target joule-thompson exch",
  "cryo target temperature",
  "cryo target heat exch temperature",
  "cryo target heat exch exhaust temperature",
  "cryo target level low",
  "cryo target level high",
  "cryo target level low display",
  "cryo target level high display",
  "cryo target level high by PT_T",
  "cryo target level low by PT_T",
E 67
E 48
E 46
E 43
};
E 42

I 67
static char *epics_chan[] = {
  "MBSY1C_energy",
  "MBSY2C_energy",
  "MBSY3C_energy",
  "IBC1H03AAVG",
  "IBC2C24AVG",
  "IBC3H00AVG",
  "IGL1I00HALLADF",
  "IGL1I00HALLBDF",
  "IGL1I00HALLCDF",
  //  "PLC_HLA",
  //  "PLC_HLB",
  //  "PLC_HLC",
  "SMRPOSA",
  "SMRPOSB",
  "SMRPOSC",
  "IGL1I00DAC0",
  "IGL1I00DAC2",
  "IGL1I00DAC4",
  "e2_target_a_status",
  "e2_target_b_status",
  "e2_target_c_status",
  "IGT0I00BIASET", 
  "IGL1I00OD16_16.RVAL",
  "torus_current",
  "MTSETI",
  "MTIRBCK",
  "MTVRBCK",
  "TMSETI",
  "TMIRBCK",
  "TMVRBCK",
  "hallb:helicity",
  "harp.DRBV",
  "scalerS1o", 
  "scaler_calc1",
  "scalerS2o",
  "scalerS3o",
  "scalerS4o",
  "scalerS5o",
  "scalerS6o",
  "scalerS7o",
  "scalerS8o",
  "scalerS9o",
  "cc_o2_ref",
  "cc_o2_sig",
  "VMP2C24SPD",
  "VCG2C21",
  "VCG2C24",
  "VCG2H01",
  "VIP2H01DV",
  "VIP2H01DI",
  "IPM2H01.XPOS",
  "IPM2H01.YPOS",
  "IPM2H01",
  "IPM2H01.XKMF",
  "IPM2H01.YKMF",
  "IPM2H01.IKMF",
  "IPM2H01XSENrbstr.STR1",
  "IPM2H01YSENrbstr.STR1",
  "IBC2H01ISENrbstr.STR1",
  "IPM2C24A.XPOS",
  "IPM2C24A.YPOS",
  "IPM2C24A",
  "IPM2C24A.XKMF",
  "IPM2C24A.YKMF",
  "IPM2C24A.IKMF",
  "IPM2C24AXSENrbstr.STR1",
  "IPM2C24AYSENrbstr.STR1",
  "IBC2C24AISENrbstr.STR1",
  "IPM2C21A.XPOS",
  "IPM2C21A.YPOS",
  "IPM2C21A",
  "IPM2C21A.XKMF",
  "IPM2C21A.YKMF",
  "IPM2C21A.IKMF",
  "IPM2C21AXSENrbstr.STR1",
  "IPM2C21AYSENrbstr.STR1",
  "IBC2C21AISENrbstr.STR1",
  "hallb_sf_xy560_0_14",
  "hallb_sf_xy560_0_18",
  "hallb_sf_xy560_0_19",
  "moeller_target.RBV",
  "RASTSETENERGY",
  "RASTSETPATTERNX",
  "RASTSETPATTERNY",
  "RASTSETXOFFSET",
  "RASTSETYOFFSET", 
  "B_cryotarget_pressure",
  "B_cryotarget_temperature",
  "B_cryotarget_status",
  "hallb_sf_xy560_0_6",
  "hallb_sf_xy560_0_7",
  "hallb_sf_xy560_0_8",
  "hallb_sf_xy560_0_9",
  "hallb_sf_xy560_0_10",
  "hallb_sf_xy560_0_11",
  "hallb_sf_xy560_0_12",
  "B_cryotarget_PT_2KH",
  "B_cryotarget_PT_5KH",
  "B_cryotarget_PT_HES",
  "B_cryotarget_PT_T",
  "B_cryotarget_TT_EBP",
  "B_cryotarget_TT_E1",
  "B_cryotarget_TT_ECR",
  "B_cryotarget_PT_D2S",
  "B_cryotarget_PT_H2S",
  "B_cryotarget_LT_CR",
  "B_cryotarget_PT_VT",
  "B_cryotarget_PT_CVP",
  "B_cryotarget_PT_CVS",
  "B_cryotarget_JT_2K",
  "B_cryotarget_TT_T",
  "B_cryotarget_TT_ET",
  "B_cryotarget_TT_ER1",
  "B_cryotarget_LS_TB",
  "B_cryotarget_LS_TH",
  "B_cryotarget_NIV_C_BAS",
  "B_cryotarget_NIV_C_HAUT",
  "B_cryotarget_NIV_BAS",
  "B_cryotarget_NIV_HAUT",
};

E 67
I 42
static int ncallback = 0;
D 67
static int nepics    = sizeof(epics)/sizeof(epics_struct);
static float epics_val[sizeof(epics)/sizeof(epics_struct)];
cdevRequestObject *obj[sizeof(epics)/sizeof(epics_struct)];
cdevCallback       *cb[sizeof(epics)/sizeof(epics_struct)];
E 67
I 67
static float      epics_val[sizeof(epics_chan)/sizeof(char *)];
static int nepics  = sizeof(epics_chan)/sizeof(char *);
E 67


E 42
I 22
// constants for head bank
static int nvers  = 0;
static int type   = 100;
static int rocst  = 0;
static int evcls  = 0;
static int presc  = 0;


E 22
I 11
D 20
// misc
D 17
static char buffer[120];
E 17
I 17
static int run;
static int descriptor;
static char buffer[200];
E 17
static char filename[200];


E 20
E 11
E 6
D 5

E 5
// prototypes
void decode_command_line(int argc, char **argv);
I 20
D 22

E 22
void add_tped_event();
void add_cped_event();
E 20
D 5
void add_ts_event(int run);
I 3
void add_l1_event(int run);
E 5
I 5
D 17
void add_sparse_event(int run);
I 6
void add_hv_event(int run);
I 7
D 9
void add_l1thresh_event(int run);
E 9
I 9
D 11
void add_thresh_event(int run);
E 11
I 11
void add_pretrig_event(int run);
void add_discr_event(int run);
E 11
E 9
E 7
E 6
E 5
E 3
D 8
int get_run_number(void);
E 8
I 8
void add_ts_event(int run);
I 10
void add_l1prog_event(int run);
E 10
E 8
void insert_dd_events(void);
I 5
int create_sparse_bank(char *bankname, int num, char *filename, int *p, int nused, int &banksize);
I 12
int create_pretrig_bank(char *bankname, int num, ifstream &file, char *tag, 
			int *p, int nused, int &banksize);
E 12
I 6
int create_hv_bank(char *bankname, int num, char *filename, int *p, int nused, int &banksize);
E 17
I 17
void add_spar_event();
D 20
void add_hv_event();
E 20
I 20
D 30
void add_lecroy_hv_event();
void add_caen_hv_event();
E 30
E 20
void add_pretrig_event();
void add_discr_event();
void add_ts_event();
I 65
void add_trig_event();
E 65
void add_l1prog_event();
I 37
void add_brep_event();
I 46
void add_mlu_event();
E 46
E 37
I 20
void add_ttbl_event();
D 30
void add_hardware_status_event();
void add_photon_event();
E 30
E 20
D 22

E 22
D 20
void create_spar_bank(int banknum);
E 20
I 20
D 56
void create_tped1_bank(char *fname, char *bankname);
void create_tped2_bank(char *fname, char *bankname);
I 21
void create_tped6_bank(char *fname, char *bankname);
void create_tped7_bank(char *fname, char *bankname);
E 21
void create_cped_bank(char *fname, char *bankname, int banknum);
void create_spar_bank(char *fname, char *bankname, int banknum);
D 30
void create_lecroy_hv_bank(char *bankname, int banknum, char *filename);
E 30
E 20
D 33
void create_pretrig_bank(char *bankname, int banknum, ifstream &file, char *tag); 
E 33
I 33
void create_pretrig_bank(int ncol, char *bankname, int banknum, ifstream &file, char *tag); 
E 56
I 56
void create_tped1_bank(const char *fname, const char *bankname);
void create_tped2_bank(const char *fname, const char *bankname);
void create_tped6_bank(const char *fname, const char *bankname);
void create_tped7_bank(const char *fname, const char *bankname);
void create_cped_bank(const char *fname, const char *bankname, int banknum);
void create_spar_bank(const char *fname, const char *bankname, int banknum);
void create_pretrig_bank(int ncol, const char *bankname, int banknum, ifstream &file, const char *tag); 
E 56
E 33
D 20
void create_hv_bank(char *bankname, int banknum, char *filename);

E 20
E 17
D 67
void epics_callback_func(int status, void *userarg, cdevRequestObject &epics_req_obj,
			    cdevData& result);
E 67
E 6
E 5
D 17

E 17
I 9
D 11
void find_tag_line(ifstream &file, char *tag, char buffer[], int buflen);
void get_next_line(ifstream &file, char buffer[], int buflen);
E 11
I 11
D 52
D 55
int find_tag_line(ifstream &file, char *tag, char buffer[], int buflen);
E 55
I 55
int find_tag_line(ifstream &file, const char *tag, char buffer[], int buflen);
E 55
E 52
I 52
int find_tag_line(ifstream &file, const char *tag, char buffer[], int buflen);
E 52
int get_next_line(ifstream &file, char buffer[], int buflen);
E 11
D 17

E 17
I 17
D 18
int add_bank(char *bankname, int banknum, char *format, int ncol, int nrow, int nword, int data[]);
int va_add_bank(char *bankname, int banknum, char *format, int ncol, int nrow, int nword, ...);
E 18
I 18
D 56
void add_bank(char *bankname, int banknum, char *format, int ncol, int nrow, int nword, int data[]);
void va_add_bank(char *bankname, int banknum, char *format, int ncol, int nrow, int nword, ...);
E 56
I 56
void add_bank(const char *bankname, int banknum, const char *format, int ncol, int nrow, int nword, int data[]);
void va_add_bank(const char *bankname, int banknum, const char *format, int ncol, int nrow, int nword, ...);
I 63
int str2int(const char *s);
E 63
E 56
E 18
E 17
E 9
extern "C" {
I 8
D 56
int get_run_number(char *msql_database, char *session);
E 56
I 56
int get_run_number(const char *msql_database, const char *session);
E 56
D 11
int fork_and_wait(char *command);
E 11
I 11
D 13
int fork_and_wait(char *command, int timeout=0);
E 13
I 13
D 17
int fork_and_wait(char *command, int timeout, ...);
E 13
E 11
E 8
int create_header(int *p, int fevlen, int &banksize,
D 15
		  int nrun, int nevnt, int nphys, int trig);
E 15
I 15
		  int name1, int name2, int nrun, int nevnt, int nphys, int trig);
E 15
int add_bank(int *p2fev, int fevlen, 
      char *name, int num, char *format, int ncol, int nrow, int ndata, int &banksize, int *data);
int va_add_bank(int *p2fev, int fevlen, 
      char *name, int num, char *format, int ncol, int nrow, int ndata, int &banksize, ...);
E 17
I 9
D 13
int insert_msg(char *name, char *facility, char *process, char *msgclass, 
	       int severity, char *status, int code, char *text);
E 13
E 9
}


// program start time
static time_t start=time(NULL);


I 6
D 67
// ref to cdev system object
cdevSystem &cdevsys = cdevSystem::defaultSystem ();


E 67
E 6
//--------------------------------------------------------------------------

D 66

D 38
main(int argc,char **argv){
E 38
I 38
main(int argc,char **argv) {
E 38

E 66
I 66
int
main(int argc,char **argv)
{
E 66
I 9
D 13
  ostrstream temp;
E 13
  int status;
I 24
  BOSIOptr ptr;
E 24
E 9

I 9

I 20
  // synch with c i/o
  ios::sync_with_stdio();


E 20
E 9
  // decode command line
  decode_command_line(argc,argv);

I 9

E 9
  // set session name if not specified via env variable or on command line
D 52
D 55
  if(session==NULL)session="clasprod";
E 55
I 55
  if(session==NULL)session=(char*)"clasprod";
E 55
E 52
I 52
  if(session==NULL)session=(char*)"clasprod";
E 52

I 9

E 9
I 6
D 67
  // only print cdev error messages
  cdevsys.setThreshold(CDEV_SEVERITY_ERROR);

I 9

E 67
D 13
  // post startup message
  temp << "Process startup:    begin_run_event" << ends;
D 10
  status=insert_msg("begin_run_event","online","begin_run_event","status",0,"START",0,temp.str());
E 10
I 10
  // status=insert_msg("begin_run_event","online","begin_run_event","status",0,"START",0,temp.str());
E 10


E 13
E 9
E 6
D 11
  // insert data into DD system as special begin run event
E 11
I 11
D 17
  // insert special events into dd system
E 11
  insert_dd_events();

I 9

E 9
D 13
  // done
I 9
D 11
  //   temp.freeze();    ???
E 11
  temp.seekp(0,ios::beg);
  temp << "Process shutdown:  begin_run_event" << ends;
D 10
  status=insert_msg("begin_run_event","online","begin_run_event","status",0,"STOP",0,temp.str());
E 10
I 10
  // status=insert_msg("begin_run_event","online","begin_run_event","status",0,"STOP",0,temp.str());
E 13
E 10
E 9
  exit(EXIT_SUCCESS);

}
       

//----------------------------------------------------------------


void insert_dd_events(){
  
  int status,run;
  struct fifo_mode fmode;
  int ctl[4] = {-1,-1,-1,-1};


  // connect to DD system INPUT fifo
D 10
  fmode.mode     = FMODE_ALL;
  fmode.wait     = FWAIT_SLEEP;
  fmode.suser    = FMODE_MULTI_USER;
  fmode.prescale = 1;
  fmode.p2ctl    = ctl;
  status=ddu_init("INPUT",fmode);
  if(status!=0){
    cerr << "?unable to attach to DD system INPUT fifo, status is: " << status << endl;
    return;
E 10
I 10
D 13
  if(debug==0){
E 13
I 13
  if(no_dd==0){
E 13
    fmode.mode     = FMODE_ALL;
    fmode.wait     = FWAIT_SLEEP;
    fmode.suser    = FMODE_MULTI_USER;
    fmode.prescale = 1;
    fmode.p2ctl    = ctl;
    status=ddu_init("INPUT",fmode);
    if(status!=0){
      cerr << "?unable to attach to DD system INPUT fifo, status is: " << status << endl;
      return;
    }
E 10
  }


E 17
  // get run number
D 8
  run=get_run_number();
E 8
I 8
  run=get_run_number(msql_database,session);
I 22
  
E 22
E 8

D 22

E 22
I 18
  // initialize bos
  status=bosInit(bcs_.iw,NBCS);


E 18
I 17
D 22
  // open file
D 20
  sprintf(filename,"/raid/stage_in/parms_%06d.dat",run);
D 18
  //  status=bosopen(filename,descriptor);
E 18
I 18
  status=bosOpen(filename,"r",&descriptor);
E 20
I 20
  sprintf(filename,"%s/parm_%s_%06d.dat",file_loc,session,run);
E 22
I 22
  // open parms file
  sprintf(filename,"%s/parms_%s_%06d.dat",file_loc,session,run);
E 22
D 24
  status=bosOpen(filename,"w",&descriptor);
E 24
I 24
D 44
  ptr=fillDEFBOSIO(getDEFBOSIO());
  ptr->recl=64000;
  status=bosCOpen(filename,"w",&descriptor,ptr);
  //status=bosOpen(filename,"w",&descriptor);
E 44
I 44
D 56
  status=bosOpen(filename,"w",&descriptor);
E 56
I 56
  status=bosOpen(filename,(char*)"w",&descriptor);
E 56
  int recl=64000;
D 52
D 55
  bosIoctl(descriptor,"recl",(void *)&recl);
E 55
I 55
  bosIoctl(descriptor,(char*)"recl",(void *)&recl);
E 55
E 52
I 52
  bosIoctl(descriptor,(char*)"recl",(void *)&recl);
E 52
E 44
E 24
E 20
E 18
  if(status!=0) {
    cerr << "?unable to open output file!" << endl << endl;
    exit(EXIT_FAILURE);
  }

I 19

E 19
E 17
I 8
D 10

E 10
E 8
D 5
  // add trigger supervisor event
  add_ts_event(run);
E 5
I 5
D 20
  // create sparsification threshold event
E 20
I 20
  // add events to bos file
  add_tped_event();
  add_cped_event();
E 20
D 9
  add_sparse_event(run);
E 9
I 9
D 10
  //add_sparse_event(run);
E 10
I 10
D 11
  // add_sparse_event(run);
E 11
I 11
D 17
  add_sparse_event(run);
E 17
I 17
  add_spar_event();
I 20
D 30
//   add_pretrig_event();
//   add_discr_event();
//   add_ts_event();
//   add_l1prog_event();
//   add_lecroy_hv_event();
//   add_caen_hv_event();
E 30
I 30
  add_pretrig_event();
  add_discr_event();
I 65
  add_trig_event();
E 65
  add_l1prog_event();
  add_ts_event();
I 37
  add_brep_event();
I 46
  add_mlu_event();
E 46
E 37
E 30
D 36
//   add_ttbl_event();
E 36
I 36
  //   add_ttbl_event();
E 36
D 30
//   add_hardware_status_event();
//   if(???)add_photon_event();
E 30
E 20
E 17
E 11
E 10
E 9
E 5


I 6
D 11
  // create HV event
D 9
  add_hv_event(run);
E 9
I 9
D 10
  //add_hv_event(run);
E 10
I 10
  // add_hv_event(run);
E 11
I 11
D 17
  // create pretrig threshold event
  add_pretrig_event(run);
E 17
I 17
D 20
  // create pretrig event
  add_pretrig_event();
E 20
I 20
  // flush and close file
D 52
D 55
  bosWrite(descriptor,bcs_.iw,"0");
E 55
I 55
  bosWrite(descriptor,bcs_.iw,(char*)"0");
E 55
E 52
I 52
  bosWrite(descriptor,bcs_.iw,(char*)"0");
E 52
  bosClose(descriptor);
E 20
E 17
E 11
E 10
E 9


I 7
D 9
  // create l1 threshold event
  add_l1thresh_event(run);
E 9
I 9
D 11
  // create threshold event
D 10
  add_thresh_event(run);
E 10
I 10
  // add_thresh_event(run);
E 11
I 11
D 20
  // create channel discriminator event
D 17
  add_discr_event(run);
E 17
I 17
  add_discr_event();
E 20
I 20
  // done
  exit(EXIT_SUCCESS);
}
E 20
E 17
E 11
E 10
E 9

I 20
  
//----------------------------------------------------------------
E 20

I 8
D 17
  // read out ts program and create ts program event
D 10
  status=fork_and_wait("/usr/local/clas/bin/get_ts_program");
  add_ts_event(run);
E 10
I 10
D 11
  // status=fork_and_wait("/usr/local/clas/bin/get_ts_program");
  // add_ts_event(run);
E 11
I 11
D 13
  status=fork_and_wait("/usr/local/clas/bin/get_ts_program",10);
  add_ts_event(run);
E 13
I 13
  status=fork_and_wait("/usr/local/clas/bin/get_ts_program",10,NULL);
  if(status==0)add_ts_event(run);
E 17
I 17
D 20
  // create ts program event
  add_ts_event();
E 20
E 17
E 13
E 11
E 10

I 20
D 66
void add_tped_event() {
E 20

E 66
I 66
void
add_tped_event()
{
E 66
I 25
D 28
  int ecpe,ccpe,stpe,dpsp,scpe,ecp1,dpcp,dtcp,flen;
  char *p;
E 28
I 28
  int ecpe=0,ccpe=0,stpe=0,dpsp=0,scpe=0,ecp1=0,dpcp=0,dtcp=0;
E 28
E 25
I 10
D 17
  // store l1 program in ascii
  add_l1prog_event(run);
E 17
I 17
D 20
  // create l1 program event
  add_l1prog_event();
E 20
E 17

I 25

E 25
I 20
  // head bank
D 22
  va_add_bank("HEAD",0,"I",8,1,8,run);
E 22
I 22
D 38
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,1,start,type,rocst,evcls,presc);
E 38
I 38
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,0,start,type,rocst,evcls,presc);
E 38
E 22
  
E 20

I 11
D 20
  // create HV event
D 17
  add_hv_event(run);
E 17
I 17
  add_hv_event();
E 20
I 20
D 21
  // ped2 banks (2I,F,I,F)
  sprintf(temp,"%s/pedman/Tfiles/sc.tped",clon_parms);
  create_tped2_bank(temp,"SCPE");
E 20
E 17

I 20
  sprintf(temp,"%s/pedman/Tfiles/lac.tped",clon_parms);
  create_tped2_bank(temp,"ECP1");
E 20

E 11
E 10
E 8
E 7
E 6
I 3
D 5
  // add l1 event
  add_l1_event(run);


E 5
E 3
D 17
  // disconnect from DD system
D 10
  ddu_close();
E 10
I 10
D 13
  if(debug==0)ddu_close();
E 13
I 13
  if(no_dd==0)ddu_close();
E 17
I 17
D 18
  // close file
  // status=bosclose(descriptor);
E 18
I 18
D 20
  // write and close file
  bosWrite(descriptor,bcs_.iw,"0");
  bosClose(descriptor);
E 20
E 18
E 17
E 13
E 10

I 20
  // ped1 banks (2I,F)
E 21
I 21
D 22
  // (2I,F)
E 22
I 22
  // (I,I,F)
E 22
E 21
  sprintf(temp,"%s/pedman/Tfiles/ec.tped",clon_parms);
I 25
D 28
  readlink(temp,temp2,sizeof(temp2));
  ecpe=atoi(strstr(temp2,".trans_")+7);
E 25
  create_tped1_bank(temp,"ECPE");
E 28
I 28
  if(readlink(temp,temp2,sizeof(temp2))>0) {
D 40
    ecpe=atoi(strstr(temp2,".trans_")+7);
E 40
I 40
    ecpe=atoi(strrchr(temp2,'_')+1);
E 40
    create_tped1_bank(temp,"ECPE");
  } else {
    cerr << "Unable to translate link: " << temp << endl;
  }
E 28
E 20

D 17
  return;
E 17
I 17
D 20
  exit(EXIT_SUCCESS);
E 20
I 20
  sprintf(temp,"%s/pedman/Tfiles/cc.tped",clon_parms);
I 25
D 28
  readlink(temp,temp2,sizeof(temp2));
  ccpe=atoi(strstr(temp2,".trans_")+7);
E 25
  create_tped1_bank(temp,"CCPE");
E 28
I 28
  if(readlink(temp,temp2,sizeof(temp2))>0) {
D 40
    ccpe=atoi(strstr(temp2,".trans_")+7);
E 40
I 40
    ccpe=atoi(strrchr(temp2,'_')+1);
E 40
    create_tped1_bank(temp,"CCPE");
  } else {
    cerr << "Unable to translate link: " << temp << endl;
  }
E 28

I 28

E 28
I 21
D 23
  sprintf(temp,"%s/pedman/Tfiles/tac.tped",clon_parms);
  create_tped1_bank(temp,"DTCP");
E 23
I 23
  sprintf(temp,"%s/pedman/Tfiles/st.tped",clon_parms);
I 25
D 28
  readlink(temp,temp2,sizeof(temp2));
  stpe=atoi(strstr(temp2,".trans_")+7);
E 25
  create_tped1_bank(temp,"STPE");
E 28
I 28
  if(readlink(temp,temp2,sizeof(temp2))>0) {
D 40
    stpe=atoi(strstr(temp2,".trans_")+7);
E 40
I 40
    stpe=atoi(strrchr(temp2,'_')+1);
E 40
    create_tped1_bank(temp,"STPE");
  } else {
    cerr << "Unable to translate link: " << temp << endl;
  }
E 28
E 23

I 28

E 28
E 21
  sprintf(temp,"%s/pedman/Tfiles/ps.tped",clon_parms);
I 25
D 28
  readlink(temp,temp2,sizeof(temp2));
  dpsp=atoi(strstr(temp2,".trans_")+7);
E 25
  create_tped1_bank(temp,"DPSP");
E 28
I 28
  if(readlink(temp,temp2,sizeof(temp2))>0) {
D 40
    dpsp=atoi(strstr(temp2,".trans_")+7);
E 40
I 40
    dpsp=atoi(strrchr(temp2,'_')+1);
E 40
    create_tped1_bank(temp,"DPSP");
  } else {
    cerr << "Unable to translate link: " << temp << endl;
  }
E 28

I 21

I 28

E 28
D 22
  // (2I,F,I,F)
E 22
I 22
  // (I,2(I,F))
E 22
  sprintf(temp,"%s/pedman/Tfiles/sc.tped",clon_parms);
I 25
D 28
  readlink(temp,temp2,sizeof(temp2));
  scpe=atoi(strstr(temp2,".trans_")+7);
E 25
  create_tped2_bank(temp,"SCPE");
E 28
I 28
  if(readlink(temp,temp2,sizeof(temp2))>0) {
D 40
    scpe=atoi(strstr(temp2,".trans_")+7);
E 40
I 40
    scpe=atoi(strrchr(temp2,'_')+1);
E 40
    create_tped2_bank(temp,"SCPE");
  } else {
    cerr << "Unable to translate link: " << temp << endl;
  }
E 28

I 28

E 28
  sprintf(temp,"%s/pedman/Tfiles/lac.tped",clon_parms);
I 25
D 28
  readlink(temp,temp2,sizeof(temp2));
  ecp1=atoi(strstr(temp2,".trans_")+7);
E 25
  create_tped2_bank(temp,"ECP1");
E 28
I 28
  if(readlink(temp,temp2,sizeof(temp2))>0) {
D 40
    ecp1=atoi(strstr(temp2,".trans_")+7);
E 40
I 40
    ecp1=atoi(strrchr(temp2,'_')+1);
E 40
    create_tped2_bank(temp,"ECP1");
  } else {
    cerr << "Unable to translate link: " << temp << endl;
  }
E 28


  // (I,6(I,F))
E 21
  sprintf(temp,"%s/pedman/Tfiles/pc.tped",clon_parms);
I 25
D 28
  readlink(temp,temp2,sizeof(temp2));
  dpcp=atoi(strstr(temp2,".trans_")+7);
E 25
D 21
  create_tped1_bank(temp,"DPCP");
E 21
I 21
  create_tped6_bank(temp,"DPCP");
E 28
I 28
  if(readlink(temp,temp2,sizeof(temp2))>0) {
D 40
    dpcp=atoi(strstr(temp2,".trans_")+7);
E 40
I 40
    dpcp=atoi(strrchr(temp2,'_')+1);
E 40
    create_tped6_bank(temp,"DPCP");
  } else {
    cerr << "Unable to translate link: " << temp << endl;
  }
E 28
E 21

D 21
  sprintf(temp,"%s/pedman/Tfiles/tac.tped",clon_parms);
  create_tped1_bank(temp,"DTCP");
E 21

I 21
  // (I,7(I,F))
E 21
D 23
  sprintf(temp,"%s/pedman/Tfiles/st.tped",clon_parms);
D 21
  create_tped1_bank(temp,"STPE");
E 21
I 21
  create_tped7_bank(temp,"STPE");
E 23
I 23
  sprintf(temp,"%s/pedman/Tfiles/tac.tped",clon_parms);
I 25
D 28
  readlink(temp,temp2,sizeof(temp2));
  dtcp=atoi(strstr(temp2,".trans_")+7);
E 25
  create_tped7_bank(temp,"DTCP");
E 28
I 28
  if(readlink(temp,temp2,sizeof(temp2))>0) {
D 40
    dtcp=atoi(strstr(temp2,".trans_")+7);
E 40
I 40
    dtcp=atoi(strrchr(temp2,'_')+1);
E 40
    create_tped7_bank(temp,"DTCP");
  } else {
    cerr << "Unable to translate link: " << temp << endl;
  }
E 28
E 23
E 21


I 28

E 28
I 25
  // add pedestal run index bank
D 29
  va_add_bank("RNPE",0,"I,A",2,8,16,
E 29
I 29
  va_add_bank("RNPE",0,"(I,A)",2,8,16,
E 29
D 63
	      ecpe,*((unsigned long*)"ECPE"),
	      ccpe,*((unsigned long*)"CCPE"),
	      stpe,*((unsigned long*)"STPE"),
	      dpsp,*((unsigned long*)"DPSP"),
	      scpe,*((unsigned long*)"SCPE"),
	      ecp1,*((unsigned long*)"ECP1"),
	      dpcp,*((unsigned long*)"DPCP"),
	      dtcp,*((unsigned long*)"DTCP"));
E 63
I 63
	      ecpe,str2int("ECPE"),
	      ccpe,str2int("CCPE"),
	      stpe,str2int("STPE"),
	      dpsp,str2int("DPSP"),
	      scpe,str2int("SCPE"),
	      ecp1,str2int("ECP1"),
	      dpcp,str2int("DPCP"),
	      dtcp,str2int("DTCP"));
E 63
  

E 25
  // write and drop banks
D 56
  bosWrite(descriptor,bcs_.iw,"E");
  bosLdrop(bcs_.iw,"E");
E 56
I 56
  bosWrite(descriptor,bcs_.iw,(char*)"E");
  bosLdrop(bcs_.iw,(char*)"E");
E 56
  bosNgarbage(bcs_.iw);

I 24
  if(debug==1)cout << "Created tped event" << endl;
E 24
I 23

E 23
  return;
E 20
E 17
}

I 20

//----------------------------------------------------------------


D 56
void create_tped1_bank(char *fname, char *bankname) {
E 56
I 56
D 66
void create_tped1_bank(const char *fname, const char *bankname) {
E 56

E 66
I 66
void
create_tped1_bank(const char *fname, const char *bankname)
{
E 66
D 26
  int nentry;
E 26
I 26
  int nentry,dum;
E 26
  int tpeds[500][3];
  char sectors[120];
  int sec;
  char csec[16];


  // create translated ped banks from data in file
  ifstream file(fname);
D 57
  if(file.bad()) {
E 57
I 57
  if(!file.is_open()) {
E 57
    cerr << "?unable to open " << fname << endl;
    return;
  }
    

  // get list of sectors
  if((find_tag_line(file,"*SECTORS*",sectors,sizeof(sectors))!=0) ||
     (get_next_line(file,sectors,sizeof(sectors))!=0)) {
I 24
    cerr << "No sector tag for file,bank " << fname << ", " << bankname << endl;
E 24
    file.close();
    return;
  }
E 20
  
I 20

  // loop over each sector
  char *ptr=strtok(sectors," ");  // point to 1st token
  while (ptr!=NULL) {

    sec=atoi(ptr);

    // loop over data
    nentry=0;
    sprintf(csec,"*SECTOR%d*",sec);
D 24
    if(find_tag_line(file,csec,buffer,sizeof(buffer))!=0)continue;
E 24
I 24
    if(find_tag_line(file,csec,buffer,sizeof(buffer))!=0) {
D 35
      cerr << "No " << csec << " tag for file,bank " << fname << ", " << bankname;
      continue;
    }
E 24
    while (get_next_line(file,buffer,sizeof(buffer))==0) {
      nentry++;
      if(nentry>500) {
	nentry--;
	cerr << "?too many tpeds in " << fname << endl;
	break;
E 35
I 35
      cerr << "No " << csec << " tag for file,bank " << fname << ", " << bankname << endl;
    } else {
      while (get_next_line(file,buffer,sizeof(buffer))==0) {
	nentry++;
	if(nentry>500) {
	  nentry--;
	  cerr << "?too many tpeds in " << fname << endl;
	  break;
	}
	sscanf(buffer,"%d %d %d %f",
	       &tpeds[nentry-1][0], &dum, &tpeds[nentry-1][1], &tpeds[nentry-1][2]);
E 35
      }
D 26
      sscanf(buffer,"%d %d %f",
	     &tpeds[nentry-1][0], &tpeds[nentry-1][1], &tpeds[nentry-1][2]);
E 26
I 26
D 35
      sscanf(buffer,"%d %d %d %f",
	     &tpeds[nentry-1][0], &dum, &tpeds[nentry-1][1], &tpeds[nentry-1][2]);
E 35
I 35
      
      // create bos bank
      add_bank(bankname,sec,"(I,I,F)",3,nentry,nentry*3,(int*)tpeds);
      
      if(debug!=0) {
	cout << bankname << " bank number " << sec << ", format I,I,F"
	     << ", ncol 3" << ", nrow " << nentry 
	     << ", buflen " << nentry*3 << endl;
      }      
E 35
E 26
    }
D 35

    // create bos bank
D 22
    add_bank(bankname,sec,"2I,F",3,nentry,nentry*3,(int*)tpeds);
E 22
I 22
D 29
    add_bank(bankname,sec,"I,I,F",3,nentry,nentry*3,(int*)tpeds);
E 29
I 29
    add_bank(bankname,sec,"(I,I,F)",3,nentry,nentry*3,(int*)tpeds);
E 29
E 22

    if(debug!=0) {
D 22
      cout << bankname << " bank number " << sec << ", format 2I,F"
E 22
I 22
      cout << bankname << " bank number " << sec << ", format I,I,F"
E 22
	   << ", ncol 3" << ", nrow " << nentry 
	   << ", buflen " << nentry*3 << endl;
    }      

E 35
I 35
      
E 35
    // update ptr to point to next token
    ptr=strtok(NULL," ");
  }


  // close file
  file.close();


  // done
  return;
}


E 20
//----------------------------------------------------------------


D 5
void add_ts_event(int run){
E 5
I 5
D 17
void add_sparse_event(int run){
E 17
I 17
D 20
void add_spar_event(){
E 20
I 20
D 56
void create_tped2_bank(char *fname, char *bankname) {
E 56
I 56
D 66
void create_tped2_bank(const char *fname, const char *bankname) {
E 56
E 20
E 17
E 5

E 66
I 66
void
create_tped2_bank(const char *fname, const char *bankname)
{
E 66
I 20
D 26
  int nentry;
E 26
I 26
  int nentry,dum;
E 26
  int tpeds[500][5];
  char sectors[120];
  int sec;
  char csec[16];


  // create translated ped banks from data in file
  ifstream file(fname);
D 57
  if(file.bad()) {
E 57
I 57
  if(!file.is_open()) {
E 57
    cerr << "?unable to open " << fname << endl;
    return;
  }
    

  // get list of sectors
  if((find_tag_line(file,"*SECTORS*",sectors,sizeof(sectors))!=0) ||
     (get_next_line(file,sectors,sizeof(sectors))!=0)) {
I 24
    cerr << "No sector tag for file,bank " << fname << ", " << bankname << endl;
E 24
    file.close();
    return;
  }
  

  // loop over each sector
  char *ptr=strtok(sectors," ");  // point to 1st token
  while (ptr!=NULL) {

    sec=atoi(ptr);

    // loop over data
    nentry=0;
    sprintf(csec,"*SECTOR%d*",sec);
D 24
    if(find_tag_line(file,csec,buffer,sizeof(buffer))!=0)continue;
E 24
I 24
    if(find_tag_line(file,csec,buffer,sizeof(buffer))!=0) {
      cerr << "No " << csec << " tag for file,bank " << fname << ", " << bankname;
D 35
      continue;
    }
E 24
    while (get_next_line(file,buffer,sizeof(buffer))==0) {
      nentry++;
      if(nentry>500) {
	nentry--;
	cerr << "?too many tpeds in " << fname << endl;
	break;
E 35
I 35
    } else {
      while (get_next_line(file,buffer,sizeof(buffer))==0) {
	nentry++;
	if(nentry>500) {
	  nentry--;
	  cerr << "?too many tpeds in " << fname << endl;
	  break;
	}
	sscanf(buffer,"%d %d %d %f %d %f",
	       &tpeds[nentry-1][0], &dum, &tpeds[nentry-1][1], &tpeds[nentry-1][2],
	       &tpeds[nentry-1][3], &tpeds[nentry-1][4]);
E 35
      }
D 26
      sscanf(buffer,"%d %d %f %d %f",
	     &tpeds[nentry-1][0], &tpeds[nentry-1][1], &tpeds[nentry-1][2],
E 26
I 26
D 35
      sscanf(buffer,"%d %d %d %f %d %f",
	     &tpeds[nentry-1][0], &dum, &tpeds[nentry-1][1], &tpeds[nentry-1][2],
E 26
	     &tpeds[nentry-1][3], &tpeds[nentry-1][4]);
E 35
I 35
      
      // create bos bank
      add_bank(bankname,sec,"(I,2(I,F))",5,nentry,nentry*5,(int*)tpeds);
      
      if(debug!=0) {
	cout << bankname << " bank number " << sec << ", format I,2(I,F)"
	     << ", ncol 5" << ", nrow " << nentry 
	     << ", buflen " << nentry*5 << endl;
      }      
E 35
    }
D 35

    // create bos bank
D 22
    add_bank(bankname,sec,"2I,F,I,F",5,nentry,nentry*5,(int*)tpeds);
E 22
I 22
D 29
    add_bank(bankname,sec,"I,2(I,F)",5,nentry,nentry*5,(int*)tpeds);
E 29
I 29
    add_bank(bankname,sec,"(I,2(I,F))",5,nentry,nentry*5,(int*)tpeds);
E 29
E 22

    if(debug!=0) {
D 22
      cout << bankname << " bank number " << sec << ", format 2I,F,I,F"
E 22
I 22
      cout << bankname << " bank number " << sec << ", format I,2(I,F)"
E 22
	   << ", ncol 5" << ", nrow " << nentry 
	   << ", buflen " << nentry*5 << endl;
    }      

E 35
I 35
      
E 35
I 21
    // update ptr to point to next token
    ptr=strtok(NULL," ");
  }


  // close file
  file.close();


  // done
  return;
}


//----------------------------------------------------------------


D 56
void create_tped6_bank(char *fname, char *bankname) {
E 56
I 56
D 66
void create_tped6_bank(const char *fname, const char *bankname) {
E 56

E 66
I 66
void
create_tped6_bank(const char *fname, const char *bankname)
{
E 66
  int count;
  int tpeds[13];
  char sectors[120];
  int sec;
  char csec[16];
  int id,dum,ped;
  float sigma;


  // create translated ped banks from data in file
  ifstream file(fname);
D 57
  if(file.bad()) {
E 57
I 57
  if(!file.is_open()) {
E 57
    cerr << "?unable to open " << fname << endl;
    return;
  }
    

  // get list of sectors
  if((find_tag_line(file,"*SECTORS*",sectors,sizeof(sectors))!=0) ||
     (get_next_line(file,sectors,sizeof(sectors))!=0)) {
I 24
    cerr << "No sector tag for file,bank " << fname << ", " << bankname << endl;
E 24
    file.close();
    return;
  }
  

  // loop over each sector
  char *ptr=strtok(sectors," ");  // point to 1st token
  while (ptr!=NULL) {

    sec=atoi(ptr);

    // loop over data
    sprintf(csec,"*SECTOR%d*",sec);
D 24
    if(find_tag_line(file,csec,buffer,sizeof(buffer))!=0)continue;
E 24
I 24
    if(find_tag_line(file,csec,buffer,sizeof(buffer))!=0) {
      cerr << "No " << csec << " tag for file,bank " << fname << ", " << bankname;
D 35
      continue;
    }
E 24
    for(count=0; count<6; count++) {
      if(get_next_line(file,buffer,sizeof(buffer))!=0) {
	cerr << "Not enough data in " << fname << endl;
	file.close();
	return;
E 35
I 35
    } else {
      for(count=0; count<6; count++) {
	if(get_next_line(file,buffer,sizeof(buffer))!=0) {
	  cerr << "Not enough data in " << fname << endl;
	  file.close();
	  return;
	}
	sscanf(buffer,"%d %d %d %f",&id,&dum,&ped,&sigma);
	tpeds[0]=id;
	tpeds[2*count+1]=ped;
	tpeds[2*count+2]=*(int*)&sigma;
E 35
      }
D 26
      sscanf(buffer,"%d %d %f %d",&id,&dum,&ped,&sigma);
E 26
I 26
D 35
      sscanf(buffer,"%d %d %d %f",&id,&dum,&ped,&sigma);
E 26
      tpeds[0]=id;
      tpeds[2*count+1]=ped;
      tpeds[2*count+2]=*(int*)&sigma;
E 35
I 35
      
      
      // create bos bank
      add_bank(bankname,sec,"(I,6(I,F))",13,1,13,(int*)tpeds);
      
      if(debug!=0) {
	cout << bankname << " bank number " << sec << ", format I,6(I,F)"
	     << ", ncol 13" << ", nrow 1" << ", buflen 13" << endl;
      }      
E 35
    }

D 35

    // create bos bank
D 29
    add_bank(bankname,sec,"I,6(I,F)",13,1,13,(int*)tpeds);
E 29
I 29
    add_bank(bankname,sec,"(I,6(I,F))",13,1,13,(int*)tpeds);
E 29

    if(debug!=0) {
      cout << bankname << " bank number " << sec << ", format I,6(I,F)"
	   << ", ncol 13" << ", nrow 1" << ", buflen 13" << endl;
    }      

E 35
    // update ptr to point to next token
    ptr=strtok(NULL," ");
  }


  // close file
  file.close();


  // done
  return;
}


//----------------------------------------------------------------


D 56
void create_tped7_bank(char *fname, char *bankname) {
E 56
I 56
D 66
void create_tped7_bank(const char *fname, const char *bankname) {
E 56

E 66
I 66
void
create_tped7_bank(const char *fname, const char *bankname)
{
E 66
  int count;
  int tpeds[15];
  char sectors[120];
  int sec;
  char csec[16];
  int id,dum,ped;
  float sigma;


  // create translated ped banks from data in file
  ifstream file(fname);
D 57
  if(file.bad()) {
E 57
I 57
  if(!file.is_open()) {
E 57
    cerr << "?unable to open " << fname << endl;
    return;
  }
    

  // get list of sectors
  if((find_tag_line(file,"*SECTORS*",sectors,sizeof(sectors))!=0) ||
     (get_next_line(file,sectors,sizeof(sectors))!=0)) {
I 24
    cerr << "No sector tag for file,bank " << fname << ", " << bankname << endl;
E 24
    file.close();
    return;
  }
  

  // loop over each sector
  char *ptr=strtok(sectors," ");  // point to 1st token
  while (ptr!=NULL) {

    sec=atoi(ptr);

    // loop over data
    sprintf(csec,"*SECTOR%d*",sec);
D 24
    if(find_tag_line(file,csec,buffer,sizeof(buffer))!=0)continue;
E 24
I 24
    if(find_tag_line(file,csec,buffer,sizeof(buffer))!=0) {
      cerr << "No " << csec << " tag for file,bank " << fname << ", " << bankname;
D 35
      continue;
    }
E 24
    for(count=0; count<7; count++) {
      if(get_next_line(file,buffer,sizeof(buffer))!=0) {
	cerr << "Not enough data in " << fname << endl;
	file.close();
	return;
E 35
I 35
    } else {
      for(count=0; count<7; count++) {
	if(get_next_line(file,buffer,sizeof(buffer))!=0) {
	  cerr << "Not enough data in " << fname << endl;
	  file.close();
	  return;
	}
	sscanf(buffer,"%d %d %d %f",&id,&dum,&ped,&sigma);
	tpeds[0]=id;
	tpeds[2*count+1]=ped;
	tpeds[2*count+2]=*(int*)&sigma;
E 35
      }
D 26
      sscanf(buffer,"%d %d %f %d",&id,&dum,&ped,&sigma);
E 26
I 26
D 35
      sscanf(buffer,"%d %d %d %f",&id,&dum,&ped,&sigma);
E 26
      tpeds[0]=id;
      tpeds[2*count+1]=ped;
      tpeds[2*count+2]=*(int*)&sigma;
    }


    // create bos bank
D 29
    add_bank(bankname,sec,"I,7(I,F)",15,1,15,(int*)tpeds);
E 29
I 29
    add_bank(bankname,sec,"(I,7(I,F))",15,1,15,(int*)tpeds);
E 29

    if(debug!=0) {
      cout << bankname << " bank number " << sec << ", format I,7(I,F)"
	   << ", ncol 15" << ", nrow 1" << ", buflen 15" << endl;
E 35
I 35
      
      
      // create bos bank
      add_bank(bankname,sec,"(I,7(I,F))",15,1,15,(int*)tpeds);
      
      if(debug!=0) {
	cout << bankname << " bank number " << sec << ", format I,7(I,F)"
	     << ", ncol 15" << ", nrow 1" << ", buflen 15" << endl;
      }      
E 35
    }      

E 21
    // update ptr to point to next token
    ptr=strtok(NULL," ");
  }


  // close file
  file.close();


  // done
  return;
}


//----------------------------------------------------------------


D 66
void add_cped_event() {

E 66
I 66
void
add_cped_event()
{
E 66
I 27
D 28
  int cc,sc,ec1,ec2,lac;
E 28
I 28
  int cc=0,sc=0,ec1=0,ec2=0,lac=0;
E 28
E 27

I 27

E 27
E 20
D 17
  int status;
D 10
  int *p,i,nused,banksize,nhead,buflen;
E 10
I 10
  int *p = 0;
  int i,nused,banksize,nhead,buflen;
E 10
  fifo_entry fev;
E 17
I 17
  // head bank
D 22
  va_add_bank("HEAD",0,"I",8,1,8,run);
E 22
I 22
D 38
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,1,start,type,rocst,evcls,presc);
E 38
I 38
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,0,start,type,rocst,evcls,presc);
E 38
E 22
  
I 28

E 28
D 20
  create_spar_bank(1);  // sc  ???
  create_spar_bank(2);  // cc
  create_spar_bank(3);  // ec1
  create_spar_bank(4);  // ec2
  create_spar_bank(5);  // lac
E 20
I 20
D 31
  sprintf(temp,"%s/pedman/archive/cc.ped",clon_parms);
E 31
I 31
D 33
  sprintf(temp,"%s/pedman/archive/cc_load.ped",clon_parms);
E 33
I 33
D 62
  sprintf(temp,"%s/pedman/archive/cc.ped",clon_parms);
E 62
I 62
  sprintf(temp,"%s/pedman/archive/cc1.ped",clon_parms);
E 62
E 33
E 31
I 27
D 28
  readlink(temp,temp2,sizeof(temp2));
  cc=atoi(strstr(temp2,"cc_")+3);
E 27
  create_cped_bank(temp,"CPED",12);
E 28
I 28
  if(readlink(temp,temp2,sizeof(temp2))>0) {
D 40
    cc=atoi(strstr(temp2,"cc_")+3);
E 40
I 40
    cc=atoi(strrchr(temp2,'_')+1);
E 40
    create_cped_bank(temp,"CPED",12);
  } else {
    cerr << "Unable to translate link: " << temp << endl;
  }

E 28
 
D 31
  sprintf(temp,"%s/pedman/archive/sc.ped",clon_parms);
E 31
I 31
D 33
  sprintf(temp,"%s/pedman/archive/sc_load.ped",clon_parms);
E 33
I 33
D 62
  sprintf(temp,"%s/pedman/archive/sc.ped",clon_parms);
E 62
I 62
  sprintf(temp,"%s/pedman/archive/sc1.ped",clon_parms);
E 62
E 33
E 31
I 27
D 28
  readlink(temp,temp2,sizeof(temp2));
  sc=atoi(strstr(temp2,"sc_")+3);
E 27
  create_cped_bank(temp,"CPED",13);
E 28
I 28
  if(readlink(temp,temp2,sizeof(temp2))>0) {
D 40
    sc=atoi(strstr(temp2,"sc_")+3);
E 40
I 40
    sc=atoi(strrchr(temp2,'_')+1);
E 40
    create_cped_bank(temp,"CPED",13);
  } else {
    cerr << "Unable to translate link: " << temp << endl;
  }

E 28
 
D 31
  sprintf(temp,"%s/pedman/archive/ec1.ped",clon_parms);
E 31
I 31
D 33
  sprintf(temp,"%s/pedman/archive/ec1_load.ped",clon_parms);
E 33
I 33
  sprintf(temp,"%s/pedman/archive/ec1.ped",clon_parms);
E 33
E 31
I 27
D 28
  readlink(temp,temp2,sizeof(temp2));
  ec1=atoi(strstr(temp2,"ec1_")+4);
E 27
  create_cped_bank(temp,"CPED",14);
E 28
I 28
  if(readlink(temp,temp2,sizeof(temp2))>0) {
D 40
    ec1=atoi(strstr(temp2,"ec1_")+4);
E 40
I 40
    ec1=atoi(strrchr(temp2,'_')+1);
E 40
    create_cped_bank(temp,"CPED",14);
  } else {
    cerr << "Unable to translate link: " << temp << endl;
  }

E 28
 
D 31
  sprintf(temp,"%s/pedman/archive/ec2.ped",clon_parms);
E 31
I 31
D 33
  sprintf(temp,"%s/pedman/archive/ec2_load.ped",clon_parms);
E 33
I 33
  sprintf(temp,"%s/pedman/archive/ec2.ped",clon_parms);
E 33
E 31
I 27
D 28
  readlink(temp,temp2,sizeof(temp2));
  ec2=atoi(strstr(temp2,"ec2_")+4);
E 27
  create_cped_bank(temp,"CPED",15);
E 28
I 28
  if(readlink(temp,temp2,sizeof(temp2))>0) {
D 40
    ec2=atoi(strstr(temp2,"ec2_")+4);
E 40
I 40
    ec2=atoi(strrchr(temp2,'_')+1);
E 40
    create_cped_bank(temp,"CPED",15);
  } else {
    cerr << "Unable to translate link: " << temp << endl;
  }

E 28
 
D 31
  sprintf(temp,"%s/pedman/archive/lac.ped",clon_parms);
E 31
I 31
D 33
  sprintf(temp,"%s/pedman/archive/lac_load.ped",clon_parms);
E 33
I 33
D 62
  sprintf(temp,"%s/pedman/archive/lac.ped",clon_parms);
E 62
I 62
  sprintf(temp,"%s/pedman/archive/lac1.ped",clon_parms);
E 62
E 33
E 31
I 27
D 28
  readlink(temp,temp2,sizeof(temp2));
  lac=atoi(strstr(temp2,"lac_")+4);
E 27
  create_cped_bank(temp,"CPED",16);
 
E 28
I 28
  if(readlink(temp,temp2,sizeof(temp2))>0) {
D 40
    lac=atoi(strstr(temp2,"lac_")+4);
E 40
I 40
    lac=atoi(strrchr(temp2,'_')+1);
E 40
    create_cped_bank(temp,"CPED",16);
  } else {
    cerr << "Unable to translate link: " << temp << endl;
  }
E 28
E 20
E 17

I 28

E 28
I 27
  // add pedestal run index bank
D 29
  va_add_bank("RNPE",0,"I,A",2,5,10,
E 29
I 29
  va_add_bank("RNPE",0,"(I,A)",2,5,10,
E 29
D 63
	       cc,*((unsigned long*)"CC  "),
	       sc,*((unsigned long*)"SC  "),
	      ec1,*((unsigned long*)"EC1 "),
	      ec2,*((unsigned long*)"EC2 "),
	      lac,*((unsigned long*)"LAC "));
E 63
I 63
	       cc,str2int("CC  "),
	       sc,str2int("SC  "),
	      ec1,str2int("EC1 "),
	      ec2,str2int("EC2 "),
	      lac,str2int("LAC "));
E 63
  

E 27
I 20
  // write and drop banks
E 20
I 18
D 56
  bosWrite(descriptor,bcs_.iw,"E");
  bosLdrop(bcs_.iw,"E");
E 56
I 56
  bosWrite(descriptor,bcs_.iw,(char*)"E");
  bosLdrop(bcs_.iw,(char*)"E");
E 56
  bosNgarbage(bcs_.iw);
I 20

I 24
  if(debug==1)cout << "Created cped event" << endl;

E 24
  return;
E 20
E 18
D 17

  // get free fifo event
D 6
  status=ddu_req_fev(DDBUFFERSIZE,&fev);
E 6
I 6
D 10
  status=ddu_req_fev(SPBUFFERSIZE,&fev);
E 6
  if(status!=0){
D 7
    cerr << "?unable to get fev, status is: " << status << endl;
E 7
I 7
    cerr << "?unable to get sparse fev, status is: " << status << endl;
E 7
    return;
  }
E 10
I 10
D 13
  if(debug==0){
E 13
I 13
  if(no_dd==0) {
E 13
    status=ddu_req_fev(SPBUFFERSIZE,&fev);
    if(status!=0){
      cerr << "?unable to get sparse fev, status is: " << status << endl;
      return;
    }
E 10


D 10
  // set pointer, reset counts, fill ctl words, etc.
  p=fev.p2da;
  nused=0;
  nhead=0;
  fev.ctlw1=ddctl[0];
  fev.ctlb1=ddctl[1];
  fev.ctlw2=ddctl[2];
  fev.ctlb2=ddctl[3];
E 10
I 10
    // set pointer, reset counts, fill ctl words, etc.
    p=fev.p2da;
    nused=0;
    nhead=0;
    fev.ctlw1=ddctl[0];
    fev.ctlb1=ddctl[1];
    fev.ctlw2=ddctl[2];
    fev.ctlb2=ddctl[3];
E 10


D 10
  // create segment header, then update pointer and counters
D 6
  status=create_header(p,DDBUFFERSIZE-nused,nhead,run,nevnt,nphys,trig);
E 6
I 6
  status=create_header(p,SPBUFFERSIZE-nused,nhead,run,nevnt,nphys,trig);
E 6
  if(status==0){
    p+=nhead;
    nused+=nhead;
  }  
E 10
I 10
    // create segment header, then update pointer and counters
D 15
    status=create_header(p,SPBUFFERSIZE-nused,nhead,run,nevnt,nphys,trig);
E 15
I 15
    status=create_header(p,SPBUFFERSIZE-nused,nhead,'RUNP','ARMS',run,nevnt,nphys,trig);
E 15
    if(status==0){
      p+=nhead;
      nused+=nhead;
    }  
    
    
    // head bank
    status=va_add_bank(p,SPBUFFERSIZE-nused,"HEAD",0,"I",8,1,8,banksize,
		       nvers,run,nevnt,start,type,rocst,evcls,presc);
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
E 10

D 10

  // head bank
D 6
  status=va_add_bank(p,DDBUFFERSIZE-nused,"HEAD",0,"I",8,1,8,banksize,
E 6
I 6
  status=va_add_bank(p,SPBUFFERSIZE-nused,"HEAD",0,"I",8,1,8,banksize,
E 6
	      nvers,run,nevnt,start,type,rocst,evcls,presc);
  if(status==0){
    p+=banksize;
    nused+=banksize;
E 10
  }


D 5
  // add trigger supervisor program bank
D 3
  buflen=1;
  status=add_bank(p,DDBUFFERSIZE-nused,"TS  ",1,"I",1,1,buflen,banksize,(int *)1);
E 3
I 3
  buflen=4;
D 4
  status=add_bank(p,DDBUFFERSIZE-nused,"TS  ",1,"I",1,1,buflen,banksize,ddctl);
E 4
I 4
  status=add_bank(p,DDBUFFERSIZE-nused,"TS  ",1,"I",1,4,buflen,banksize,ddctl);
E 5
I 5
  // croc06 
D 9
  status=create_sparse_bank("THRS",6,"/usr/local/clas/parms/initfiles/croc06.spar",p,nused,banksize);
E 9
I 9
  status=create_sparse_bank("SPAR",6,"/usr/local/clas/parms/initfiles/croc06.spar",p,nused,banksize);
E 9
E 5
E 4
E 3
  if(status==0){
    p+=banksize;
I 3
    nused+=banksize;
  }

I 5
  // croc07
D 9
  status=create_sparse_bank("THRS",7,"/usr/local/clas/parms/initfiles/croc07.spar",p,nused,banksize);
E 9
I 9
  status=create_sparse_bank("SPAR",7,"/usr/local/clas/parms/initfiles/croc07.spar",p,nused,banksize);
E 9
  if(status==0){
    p+=banksize;
    nused+=banksize;
  }
E 5

D 5
  // all banks added...set fev and fpack overall word counts
E 5
I 5
  // croc08 
D 9
  status=create_sparse_bank("THRS",8,"/usr/local/clas/parms/initfiles/croc08.spar",p,nused,banksize);
E 9
I 9
  status=create_sparse_bank("SPAR",8,"/usr/local/clas/parms/initfiles/croc08.spar",p,nused,banksize);
E 9
  if(status==0){
    p+=banksize;
    nused+=banksize;
  }

  // croc11 
D 9
  status=create_sparse_bank("THRS",11,"/usr/local/clas/parms/initfiles/croc11.spar",p,nused,banksize);
E 9
I 9
  status=create_sparse_bank("SPAR",11,"/usr/local/clas/parms/initfiles/croc11.spar",p,nused,banksize);
E 9
  if(status==0){
    p+=banksize;
    nused+=banksize;
  }


  // croc19
D 9
  status=create_sparse_bank("THRS",19,"/usr/local/clas/parms/initfiles/croc19.spar",p,nused,banksize);
E 9
I 9
  status=create_sparse_bank("SPAR",19,"/usr/local/clas/parms/initfiles/croc19.spar",p,nused,banksize);
E 9
  if(status==0){
    p+=banksize;
    nused+=banksize;
  }

 
 // all banks added...set fev and fpack overall word counts
E 5
D 10
  fev.len=nused;
  *(fev.p2da+10)=nused-nhead;


  // insert event into DD system
  status=ddu_put_fev(fev);
  if(status!=0){
    cerr << "?unable to put fev, status is: " << status << endl;
    return;
E 10
I 10
D 13
  if(debug==0){
E 13
I 13
  if(no_dd==0) {
E 13
    fev.len=nused;
    *(fev.p2da+10)=nused-nhead;
    
    
    // insert event into DD system
    status=ddu_put_fev(fev);
    if(status!=0){
      cerr << "?unable to put fev, status is: " << status << endl;
      return;
    }
E 10
  }

E 17
D 10

E 10
}


//----------------------------------------------------------------


D 5
void add_l1_event(int run){
E 5
I 5
D 17
int create_sparse_bank(char *bankname, int num, char *filename, int *p, int nused, int &banksize){
E 17
I 17
D 20
void create_spar_bank(int banknum) {
E 20
I 20
D 56
void create_cped_bank(char *fname, char *bankname, int banknum) {
E 56
I 56
D 66
void create_cped_bank(const char *fname, const char *bankname, int banknum) {
E 56
E 20
E 17
E 5

E 66
I 66
void
create_cped_bank(const char *fname, const char *bankname, int banknum)
{
E 66
D 5
  int status;
  int *p,i,nused,banksize,nhead,buflen;
  fifo_entry fev;
E 5
I 5
D 17
  int status=-1;
E 17
  int nentry=0;
D 17
  int buflen;
E 17
D 13
  short threshold[1000][3];
E 13
I 13
D 20
  int threshold[1000][3];
E 20
I 20
  int cped[1000][5];
E 20
E 13
D 11
  char buffer[120];
E 11
E 5


I 17
D 20
  sprintf(filename,"junk.dat");   // ???
E 20
I 20
  // fill local array with cped data
  ifstream file(fname);
D 38
  while (file.eof()==0){
E 38
I 38
D 59
  while (file.eof()==0) {
E 59
I 59
  while(file.is_open()&&file.good()&&!file.eof()&&!file.fail()&&!file.bad()) {
E 59
E 38
    file.getline(buffer,sizeof(buffer));
D 38
    if(file.eof()==0){
E 38
I 38
    if(file.eof()==0) {
E 38
      nentry++;
      if(nentry>1000) {
	nentry--;
	cerr << "?too many cpeds in " << fname << endl;
	break;
      }
      sscanf(buffer,"%d %d %d %f %d",
	     &cped[nentry-1][0], &cped[nentry-1][1], &cped[nentry-1][2],
	     &cped[nentry-1][3], &cped[nentry-1][4]);
    }
  }
  file.close();
E 20

I 20

  // create bos bank
D 24
  add_bank(bankname,banknum,"3I,F,I",5,nentry,nentry*5,(int*)cped);


  if(debug!=0) {
    cout << bankname << " bank number " << banknum << ", format 3I,F,I"
	 << ", ncol 5" << ", nrow " << nentry 
	 << ", buflen " << nentry*5 << endl;
E 24
I 24
  if(nentry>0) {
D 29
    add_bank(bankname,banknum,"3I,F,I",5,nentry,nentry*5,(int*)cped);
E 29
I 29
    add_bank(bankname,banknum,"(3I,F,I)",5,nentry,nentry*5,(int*)cped);
E 29
    if(debug!=0) {
      cout << bankname << " bank number " << banknum << ", format 3I,F,I"
	   << ", ncol 5" << ", nrow " << nentry 
	   << ", buflen " << nentry*5 << endl;
    }
  } else {
    cerr << "No cped data for fname,bank,num: " << fname << ", " << bankname << ", " << banknum << endl;
E 24
  }


  // done
  return;
}


//----------------------------------------------------------------


D 66
void add_spar_event() {


E 66
I 66
void
add_spar_event()
{
E 66
  // head bank
D 22
  va_add_bank("HEAD",0,"I",8,1,8,run);
E 22
I 22
D 38
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,1,start,type,rocst,evcls,presc);
E 38
I 38
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,0,start,type,rocst,evcls,presc);
E 38

E 22
  
D 31
  sprintf(temp,"%s/pedman/spar_archive/cc_hard.spar",clon_parms);
E 31
I 31
D 32
  sprintf(temp,"%s/pedman/spar_archive/cc_%s_%06d.spar",clon_parms,session,run);
E 32
I 32
D 62
  sprintf(temp,"%s/pedman/spar_archive/cc_%s_%06d_hard.spar",clon_parms,session,run);
E 62
I 62
  sprintf(temp,"%s/pedman/spar_archive/cc1_%s_%06d_hard.spar",clon_parms,session,run);
E 62
E 32
E 31
  create_spar_bank(temp,"SPAR",12); 
 				    
D 31
  sprintf(temp,"%s/pedman/spar_archive/sc_hard.spar",clon_parms);
E 31
I 31
D 32
  sprintf(temp,"%s/pedman/spar_archive/sc_%s_%06d.spar",clon_parms,session,run);
E 32
I 32
D 62
  sprintf(temp,"%s/pedman/spar_archive/sc_%s_%06d_hard.spar",clon_parms,session,run);
E 62
I 62
  sprintf(temp,"%s/pedman/spar_archive/sc1_%s_%06d_hard.spar",clon_parms,session,run);
E 62
E 32
E 31
  create_spar_bank(temp,"SPAR",13); 
 				    
D 31
  sprintf(temp,"%s/pedman/spar_archive/ec1_hard.spar",clon_parms);
E 31
I 31
D 32
  sprintf(temp,"%s/pedman/spar_archive/ec1_%s_%06d.spar",clon_parms,session,run);
E 32
I 32
  sprintf(temp,"%s/pedman/spar_archive/ec1_%s_%06d_hard.spar",clon_parms,session,run);
E 32
E 31
  create_spar_bank(temp,"SPAR",14); 
 				    
D 31
  sprintf(temp,"%s/pedman/spar_archive/ec2_hard.spar",clon_parms);
E 31
I 31
D 32
  sprintf(temp,"%s/pedman/spar_archive/ec2_%s_%06d.spar",clon_parms,session,run);
E 32
I 32
  sprintf(temp,"%s/pedman/spar_archive/ec2_%s_%06d_hard.spar",clon_parms,session,run);
E 32
E 31
  create_spar_bank(temp,"SPAR",15); 
 				    
D 31
  sprintf(temp,"%s/pedman/spar_archive/lac_hard.spar",clon_parms);
E 31
I 31
D 32
  sprintf(temp,"%s/pedman/spar_archive/lac_%s_%06d.spar",clon_parms,session,run);
E 32
I 32
D 62
  sprintf(temp,"%s/pedman/spar_archive/lac_%s_%06d_hard.spar",clon_parms,session,run);
E 62
I 62
  sprintf(temp,"%s/pedman/spar_archive/lac1_%s_%06d_hard.spar",clon_parms,session,run);
E 62
E 32
E 31
  create_spar_bank(temp,"SPAR",16);
 

  // write and drop banks
D 56
  bosWrite(descriptor,bcs_.iw,"E");
  bosLdrop(bcs_.iw,"E");
E 56
I 56
  bosWrite(descriptor,bcs_.iw,(char*)"E");
  bosLdrop(bcs_.iw,(char*)"E");
E 56
  bosNgarbage(bcs_.iw);

I 24
  if(debug==1)cout << "Created spar event" << endl;

E 24
  return;
}


//----------------------------------------------------------------


D 56
void create_spar_bank(char *fname, char *bankname, int banknum) {
E 56
I 56
D 66
void create_spar_bank(const char *fname, const char *bankname, int banknum) {
E 56

E 66
I 66
void
create_spar_bank(const char *fname, const char *bankname, int banknum)
{
E 66
  int nentry=0;
  int spar[1000][4];


E 20
E 17
D 5
  // get free fifo event
  status=ddu_req_fev(DDBUFFERSIZE,&fev);
  if(status!=0){
    cerr << "?unable to get fev, status is: " << status << endl;
    return;
E 5
I 5
  // fill local array with sparsification data
D 20
  ifstream file(filename);
E 20
I 20
  ifstream file(fname);
I 31
D 57
  if(file.bad()) {
E 57
I 57
  if(!file.is_open()) {
E 57
    cerr << "Unable to read spar file " << fname << endl;
    return;
  }
E 31
E 20
D 23
  while (file.eof()==0){
    file.getline(buffer,sizeof(buffer));
    if(file.eof()==0){
      nentry++;
I 20
      if(nentry>1000) {
	nentry--;
	cerr << "?too many spars in " << fname << endl;
	break;
      }
E 20
D 13
      sscanf(buffer,"%hd %hd %hd",
E 13
I 13
      sscanf(buffer,"%d %d %d",
E 13
D 20
	     &threshold[nentry-1][0], &threshold[nentry-1][1], &threshold[nentry-1][2]);
E 20
I 20
	     &spar[nentry-1][0], &spar[nentry-1][1], &spar[nentry-1][2], &spar[nentry-1][3]);
E 23
I 23
  while (get_next_line(file,buffer,sizeof(buffer))==0) {
    nentry++;
    if(nentry>1000) {
      nentry--;
      cerr << "?too many spars in " << fname << endl;
      break;
E 23
E 20
    }
I 23
    sscanf(buffer,"%d %d %d %d",
	   &spar[nentry-1][0], &spar[nentry-1][1], &spar[nentry-1][2], &spar[nentry-1][3]);
E 23
E 5
  }
I 17
  file.close();
E 17


D 5
  // set pointer, reset counts, fill ctl words, etc.
  p=fev.p2da;
  nused=0;
  nhead=0;
  fev.ctlw1=ddctl[0];
  fev.ctlb1=ddctl[1];
  fev.ctlw2=ddctl[2];
  fev.ctlb2=ddctl[3];


  // create segment header, then update pointer and counters
  status=create_header(p,DDBUFFERSIZE-nused,nhead,run,nevnt,nphys,trig);
  if(status==0){
    p+=nhead;
    nused+=nhead;
  }  


  // head bank
  status=va_add_bank(p,DDBUFFERSIZE-nused,"HEAD",0,"I",8,1,8,banksize,
	      nvers,run,nevnt,start,type,rocst,evcls,presc);
  if(status==0){
    p+=banksize;
    nused+=banksize;
E 5
I 5
  // create bos bank
D 10
  if(nentry>0){
    buflen=(nentry*3+1)/2;
D 6
    status=add_bank(p,DDBUFFERSIZE-nused,"THRS",num,"B16",3,nentry,buflen,banksize,(int *)threshold);
E 6
I 6
    status=add_bank(p,SPBUFFERSIZE-nused,bankname,num,"B16",3,nentry,buflen,banksize,(int *)threshold);
E 10
I 10
D 13
  if(debug==0){
E 13
I 13
D 17
  buflen=nentry*3;
  if(no_dd==0) {
E 13
    if(nentry>0){
D 13
      buflen=(nentry*3+1)/2;
      status=add_bank(p,SPBUFFERSIZE-nused,bankname,num,"B16",3,nentry,buflen,banksize,(int*)threshold);
E 13
I 13
      status=add_bank(p,SPBUFFERSIZE-nused,bankname,num,"3I",3,nentry,buflen,banksize,(int*)threshold);
E 13
    }
E 10
E 6
E 5
  }
E 17
I 17
D 20
  add_bank("SPAR",banknum,"3I",3,nentry,nentry*3,(int*)threshold);
E 20
I 20
D 24
  add_bank(bankname,banknum,"4I",4,nentry,nentry*4,(int*)spar);
E 20

I 20

E 20
E 17
I 13
  if(debug!=0) {
D 17
    cout << "Sparse bank " << bankname << ", number " << num << ", format 3I"
E 17
I 17
D 20
    cout << "SPAR bank number " << banknum << ", format 3I"
E 17
	 << ", ncol 3" << ", nrow " << nentry 
D 17
	 << ", buflen " << buflen << endl;
E 17
I 17
	 << ", buflen " << nentry*3 << endl;
E 20
I 20
    cout << bankname << " bank number " << banknum << ", format 4I"
	 << ", ncol 4" << ", nrow " << nentry 
	 << ", buflen " << nentry*4 << endl;
E 24
I 24
  if(nentry>0) {
    add_bank(bankname,banknum,"4I",4,nentry,nentry*4,(int*)spar);
    if(debug!=0) {
      cout << bankname << " bank number " << banknum << ", format 4I"
	   << ", ncol 4" << ", nrow " << nentry 
	   << ", buflen " << nentry*4 << endl;
    }
  } else {
    cerr << "No spar data for fname,bank,num: " << fname << ", " << bankname << ", " << banknum << endl;
E 24
E 20
E 17
  }
E 13

I 13

E 13
D 10

E 10
D 5
  // add trigger supervisor program bank
  buflen=4;
D 4
  status=add_bank(p,DDBUFFERSIZE-nused,"L1  ",1,"I",1,1,buflen,banksize,ddctl);
E 4
I 4
  status=add_bank(p,DDBUFFERSIZE-nused,"L1  ",1,"I",1,4,buflen,banksize,ddctl);
E 4
  if(status==0){
    p+=banksize;
E 3
    nused+=banksize;
  }
E 5
I 5
  // done
D 17
  file.close();
  return(status);
E 17
I 17
  return;
E 17
E 5
D 20

E 20
D 5

  // all banks added...set fev and fpack overall word counts
  fev.len=nused;
  *(fev.p2da+10)=nused-nhead;


  // insert event into DD system
  status=ddu_put_fev(fev);
  if(status!=0){
    cerr << "?unable to put fev, status is: " << status << endl;
    return;
  }


E 5
}


//----------------------------------------------------------------


I 6
D 17
void add_hv_event(int run){
E 17
I 17
D 20
void add_hv_event() {
E 20
I 20
D 30
void add_lecroy_hv_event() {
E 30
I 30
D 66
void add_ttbl_event() {
E 30
E 20
E 17

E 66
I 66
void
add_ttbl_event()
{
E 66
D 17
  int status;
D 10
  int *p,i,nused,banksize,nhead,buflen;
E 10
I 10
  int *p = 0;
  int i,nused,banksize,nhead,buflen;
E 10
  fifo_entry fev;
E 17
I 17
  int i;
E 17


D 17
  // get free fifo event
D 10
  status=ddu_req_fev(HVBUFFERSIZE,&fev);
  if(status!=0){
D 7
    cerr << "?unable to get fev, status is: " << status << endl;
E 7
I 7
    cerr << "?unable to get hv fev, status is: " << status << endl;
E 7
    return;
  }
E 10
I 10
D 13
  if(debug==0){
E 13
I 13
  if(no_dd==0) {
E 13
    status=ddu_req_fev(HVBUFFERSIZE,&fev);
    if(status!=0){
      cerr << "?unable to get hv fev, status is: " << status << endl;
      return;
    }
E 17
I 17
  // head bank
D 22
  va_add_bank("HEAD",0,"I",8,1,8,run);
E 22
I 22
D 38
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,1,start,type,rocst,evcls,presc);
E 38
I 38
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,0,start,type,rocst,evcls,presc);
E 38
E 22
E 17
E 10

I 22

E 22
I 17
D 30
  // bmta hv bank
D 20
  create_hv_bank("HV  ",1,"$CLON_PARMS/hv/bmta.txt");
E 20
I 20
  create_lecroy_hv_bank("HV  ",1,"$CLON_PARMS/hv/bmta.txt");
E 20
E 17

D 10
  // set pointer, reset counts, fill ctl words, etc.
  p=fev.p2da;
  nused=0;
  nhead=0;
  fev.ctlw1=ddctl[0];
  fev.ctlb1=ddctl[1];
  fev.ctlw2=ddctl[2];
  fev.ctlb2=ddctl[3];
E 10
I 10
D 17
    // set pointer, reset counts, fill ctl words, etc.
    p=fev.p2da;
    nused=0;
    nhead=0;
    fev.ctlw1=ddctl[0];
    fev.ctlb1=ddctl[1];
    fev.ctlw2=ddctl[2];
    fev.ctlb2=ddctl[3];
    
    
    // create segment header, then update pointer and counters
D 15
    status=create_header(p,HVBUFFERSIZE-nused,nhead,run,nevnt,nphys,trig);
E 15
I 15
    status=create_header(p,HVBUFFERSIZE-nused,nhead,'RUNP','ARMS',run,nevnt,nphys,trig);
E 15
    if(status==0){
      p+=nhead;
      nused+=nhead;
    }  
    
    
    // head bank
    status=va_add_bank(p,HVBUFFERSIZE-nused,"HEAD",0,"I",8,1,8,banksize,
		       nvers,run,nevnt,start,type,rocst,evcls,presc);
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
E 17
I 17
  // ccecsc hv bank
D 20
  create_hv_bank("HV  ",2,"$CLON_PARMS/hv/ccecsc.txt");
E 20
I 20
  create_lecroy_hv_bank("HV  ",2,"$CLON_PARMS/hv/ccecsc.txt");
E 20
E 17
E 10

D 10

  // create segment header, then update pointer and counters
  status=create_header(p,HVBUFFERSIZE-nused,nhead,run,nevnt,nphys,trig);
  if(status==0){
    p+=nhead;
    nused+=nhead;
  }  


  // head bank
  status=va_add_bank(p,HVBUFFERSIZE-nused,"HEAD",0,"I",8,1,8,banksize,
	      nvers,run,nevnt,start,type,rocst,evcls,presc);
  if(status==0){
    p+=banksize;
    nused+=banksize;
E 10
D 17
  }


  // get bmta hv bank
D 7
  status=create_hv_bank("HVBM",0,"/usr/local/clas/parms/run_log/bmta.txt",p,nused,banksize);
E 7
I 7
D 9
  status=create_hv_bank("HVBM",0,"/usr/local/clas/parms/hv/bmta.txt",p,nused,banksize);
E 9
I 9
D 11
  status=create_hv_bank("HV  ",0,"/usr/local/clas/parms/hv/bmta.txt",p,nused,banksize);
E 11
I 11
D 13
  status=create_hv_bank("HVBM",0,"/usr/local/clas/parms/hv/bmta.txt",p,nused,banksize);
E 13
I 13
  status=create_hv_bank("HV  ",1,"/usr/local/clas/parms/hv/bmta.txt",p,nused,banksize);
E 13
E 11
E 9
E 7
  if(status==0){
    p+=banksize;
    nused+=banksize;
  }


D 9
//   // get ccecsc hv bank
D 7
//   status=create_hv_bank("HVPM",0,"/usr/local/clas/parms/run_log/ccecsc.txt",p,nused,banksize);
E 7
I 7
//   status=create_hv_bank("HVPM",0,"/usr/local/clas/parms/hv/ccecsc.txt",p,nused,banksize);
E 7
//   if(status==0){
//     p+=banksize;
//     nused+=banksize;
//   }
E 9
I 9
  // get ccecsc hv bank
D 10
  status=create_hv_bank("HV  ",1,"/usr/local/clas/parms/hv/ccecsc.txt",p,nused,banksize);
  if(status==0){
    p+=banksize;
    nused+=banksize;
  }
E 10
I 10
D 11
//   status=create_hv_bank("HV  ",1,"/usr/local/clas/parms/hv/ccecsc.txt",p,nused,banksize);
//   if(status==0){
//     p+=banksize;
//     nused+=banksize;
//   }
E 11
I 11
D 13
  status=create_hv_bank("HVPM",0,"/usr/local/clas/parms/hv/ccecsc.txt",p,nused,banksize);
E 13
I 13
  status=create_hv_bank("HV  ",2,"/usr/local/clas/parms/hv/ccecsc.txt",p,nused,banksize);
E 13
  if(status==0){
    p+=banksize;
    nused+=banksize;
  }
E 11
E 10
E 9


E 17
D 7
//   // get dc hv bank
//   status=create_hv_bank("HVDC",0,"/usr/local/clas/parms/run_log/dchv.txt",p,nused,banksize);
//   if(status==0){
//     p+=banksize;
//     nused+=banksize;
//   }
E 7
I 7
  // CAEN EC1 and DC voltages not available in epics yet...
E 7


E 30
I 18
D 56
  bosWrite(descriptor,bcs_.iw,"E");
  bosLdrop(bcs_.iw,"E");
E 56
I 56
  bosWrite(descriptor,bcs_.iw,(char*)"E");
  bosLdrop(bcs_.iw,(char*)"E");
E 56
  bosNgarbage(bcs_.iw);
I 23

E 23
E 18
I 7
D 17

E 7
  // all banks added...set fev and fpack overall word counts
D 10
  fev.len=nused;
  *(fev.p2da+10)=nused-nhead;


  // insert event into DD system
  status=ddu_put_fev(fev);
  if(status!=0){
    cerr << "?unable to put fev, status is: " << status << endl;
    return;
E 10
I 10
D 13
  if(debug==0){
E 13
I 13
  if(no_dd==0){
E 13
    fev.len=nused;
    *(fev.p2da+10)=nused-nhead;
    
    
    // insert event into DD system
    status=ddu_put_fev(fev);
    if(status!=0){
      cerr << "?unable to put fev, status is: " << status << endl;
      return;
    }
E 10
  }

E 17
I 17
  return;
E 17
D 10

E 10
}


//----------------------------------------------------------------


D 17
int create_hv_bank(char *bankname, int num, char *filename, int *p, int nused, int &banksize){
E 17
I 17
D 20
void create_hv_bank(char *bankname, int num, char *filename) {
E 20
I 20
D 30
void create_lecroy_hv_bank(char *bankname, int num, char *filename) {
E 20
E 17

D 17
  int status=-1;
E 17
  int nentry=0;

  int buflen;
D 11
  char buffer[120];
E 11
  cdevGroup group;
D 17
  cdevRequestObject *obj[MAX_HV];
E 17
I 17
  cdevRequestObject *obj[MAXHV];
E 17
D 20
  char temp[64];
E 20
D 17
  int bosarray[MAX_HV][9];   // I,32A
E 17
I 17
  int bosarray[MAXHV][9];   // I,32A
E 17


  // read hv channel names from file and create request objects
  ifstream file(filename);
  while (file.eof()==0) {
D 10
    file.getline(buffer,sizeof(buffer));
E 10
I 10
    get_next_line(file,buffer,sizeof(buffer));
E 10
    if(file.eof()==0){
I 13
D 17
      if(nentry>=MAX_HV){
	cerr << "?too many hv channels, max is " << MAX_HV << endl;
E 17
I 17
      if(nentry>=MAXHV){
	cerr << "?too many hv channels, max is " << MAXHV << endl;
E 17
	break;
      }
E 13
      nentry++;
      sscanf(buffer,"%[^.].%s",channel[nentry-1],channel_get[nentry-1]);
      channel_val[nentry-1]=-1;
      sprintf(temp,"get %s",channel_get[nentry-1]);
      obj[nentry-1] = cdevRequestObject::attachPtr(channel[nentry-1],temp);
    }
  }
I 17
  file.close();
E 17
  

  // start group for all callbacks
  group.start();


  // create callbacks
  for(int i=0; i<nentry; i++){
    cdevCallback cb(epics_callback_func,(void*)(i));
    obj[i]->sendCallback(NULL,cb);
  }
  
  
  // process the group
  group.pend((double)cdev_pend_time);
  
  
  // check if all callbacks received
  if(ncallback<nentry){
    cerr << "?only received " << ncallback << " callbacks" << " out of " 
	 << nentry << " expected" << endl;
  }    
  
  // pack data into bosarray
  for(i=0; i<nentry; i++){
    bosarray[i][0] = channel_val[i];
    strcpy(temp,channel[i]);
    strcat(temp,".");
    strcat(temp,channel_get[i]);
    strncpy((char *)(&bosarray[i][1]),temp,min(strlen(temp),32));
  }


  // create bos bank
D 10
  if(nentry>0){
    buflen=nentry*9;
D 7
    status=add_bank(p,HVBUFFERSIZE-nused,bankname,num,"I,32A",2,nentry,buflen,banksize,
E 7
I 7
    status=add_bank(p,HVBUFFERSIZE-nused,bankname,num,"I,8A",2,nentry,buflen,banksize,
E 7
		    (int *)bosarray);
E 10
I 10
D 13
  if(debug==0){
E 13
I 13
  buflen=nentry*9;
D 17
  if(no_dd==0) {
E 13
    if(nentry>0){
D 13
      buflen=nentry*9;
E 13
      status=add_bank(p,HVBUFFERSIZE-nused,bankname,num,"I,8A",2,nentry,buflen,banksize,
		      (int *)bosarray);
    }
E 10
  }
E 17
I 17
D 29
  if(nentry>0)add_bank(bankname,num,"I,8A",2,nentry,buflen,(int *)bosarray);
E 29
I 29
  if(nentry>0)add_bank(bankname,num,"(I,8A)",2,nentry,buflen,(int *)bosarray);
E 29
E 17
I 13
  if(debug!=0) {
    cout << "HV bank " << bankname << ", number " << num << ", format I,8A"
	 << ", ncol 2" << ", nrow " << nentry 
	 << ", buflen " << buflen << endl;
  }
E 13

I 13

E 13
D 10

E 10
  // done
D 17
  file.close();
  return(status);
E 17
I 17
  return;
E 17

}
I 7


//----------------------------------------------------------------


E 30
D 9
void add_l1thresh_event(int run){
E 9
I 9
D 11
void add_thresh_event(int run){
E 11
I 11
D 17
void add_pretrig_event(int run){
E 17
I 17
D 66
void add_pretrig_event() {
E 17
E 11
E 9

E 66
I 66
void
add_pretrig_event()
{
E 66
D 17
  int status;
D 10
  int *p,i,j,nused,banksize,nhead,buflen;
E 10
I 10
  int *p = 0;
  int i,j,nused,banksize,nhead,buflen;
E 10
  fifo_entry fev;
E 17
I 17
D 65
  int i,j,buflen;
E 65
I 65
  int i,buflen;
E 65
E 17
D 9
  int l1thresh[12][7];
E 9
I 9
D 11
  int fcthresh[16][6];
  int ccthresh[2];
  char buffer[120];
E 11
I 11
D 12
  int pretrig[16][6];
  int ccpretrig[2];
E 11
  istrstream buf(buffer,sizeof(buffer));
E 12
  int time;
I 12
  istrstream buf(buffer,sizeof(buffer));
E 12
E 9

D 9

E 9
D 10
  // get free fifo event
D 9
  status=ddu_req_fev(L1THRESHBUFFERSIZE,&fev);
E 9
I 9
  status=ddu_req_fev(THRESHBUFFERSIZE,&fev);
E 9
  if(status!=0){
D 9
    cerr << "?unable to get l1thresh fev, status is: " << status << endl;
E 9
I 9
    cerr << "?unable to get thresh fev, status is: " << status << endl;
E 9
    return;
  }
E 10

I 11
D 17
  // get pretrig file name
  ifstream namefile("/usr/local/clas/parms/pretrigger/current_pretrig.txt");
  if(namefile.bad())return;
  namefile.getline(filename,sizeof(filename));
  namefile.close();		
E 11

I 11

E 17
  // open pretrig file
I 17
D 30
  sprintf(filename,"%s/pretrig/archive/pretrig_%06d.txt",getenv("CLON_PARMS"),run);
E 30
I 30
D 65
  sprintf(filename,"%s/pretrigger/archive/pretrig_%s_%06d.txt",getenv("CLON_PARMS"),session,run);
E 65
I 65
  sprintf(filename,"%s/pretrigger/archive/pretrig_%s_%06d.txt",clon_parms,session,run);
E 65
E 30
E 17
  ifstream file(filename);
D 30
  if(file.bad())return;
E 30
I 30
D 57
  if(file.bad()) {
E 57
I 57
  if(!file.is_open()) {
E 57
    cerr << "Unable to open pretrig file " << filename << endl;
    return;
  }
E 30
  file.setf(ios::skipws);


E 11
D 10
  // set pointer, reset counts, fill ctl words, etc.
  p=fev.p2da;
  nused=0;
  nhead=0;
  fev.ctlw1=ddctl[0];
  fev.ctlb1=ddctl[1];
  fev.ctlw2=ddctl[2];
  fev.ctlb2=ddctl[3];
E 10
I 10
D 17
  // get free fifo event
D 13
  if(debug==0){
E 13
I 13
  if(no_dd==0){
E 13
D 11
    status=ddu_req_fev(THRESHBUFFERSIZE,&fev);
E 11
I 11
    status=ddu_req_fev(PRETRIGBUFFERSIZE,&fev);
E 11
    if(status!=0){
D 11
      cerr << "?unable to get thresh fev, status is: " << status << endl;
E 11
I 11
      cerr << "?unable to get pretrig fev, status is: " << status << endl;
E 11
      return;
    }
E 17
I 17
  // head bank
D 22
  va_add_bank("HEAD",0,"I",8,1,8,run);
E 22
I 22
D 38
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,1,start,type,rocst,evcls,presc);
E 38
I 38
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,0,start,type,rocst,evcls,presc);
E 38
E 22
E 17
E 10
D 11


E 11
I 11
    
D 17
    
E 11
D 10
  // create segment header, then update pointer and counters
D 9
  status=create_header(p,L1THRESHBUFFERSIZE-nused,nhead,run,nevnt,nphys,trig);
E 9
I 9
  status=create_header(p,THRESHBUFFERSIZE-nused,nhead,run,nevnt,nphys,trig);
E 9
  if(status==0){
    p+=nhead;
    nused+=nhead;
  }  
E 10
I 10
    // set pointer, reset counts, fill ctl words, etc.
    p=fev.p2da;
    nused=0;
    nhead=0;
    fev.ctlw1=ddctl[0];
    fev.ctlb1=ddctl[1];
    fev.ctlw2=ddctl[2];
    fev.ctlb2=ddctl[3];
    
E 10
D 11

E 11
I 11
    
E 11
I 10
    // create segment header, then update pointer and counters
D 11
    status=create_header(p,THRESHBUFFERSIZE-nused,nhead,run,nevnt,nphys,trig);
E 11
I 11
D 15
    status=create_header(p,PRETRIGBUFFERSIZE-nused,nhead,run,nevnt,nphys,trig);
E 15
I 15
    status=create_header(p,PRETRIGBUFFERSIZE-nused,nhead,'RUNP','ARMS',run,nevnt,nphys,trig);
E 15
E 11
    if(status==0){
      p+=nhead;
      nused+=nhead;
    }  
    
    
    // head bank
D 11
    status=va_add_bank(p,THRESHBUFFERSIZE-nused,"HEAD",0,"I",8,1,8,banksize,
E 11
I 11
    status=va_add_bank(p,PRETRIGBUFFERSIZE-nused,"HEAD",0,"I",8,1,8,banksize,
E 11
		       nvers,run,nevnt,start,type,rocst,evcls,presc);
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
E 17
E 10

D 10
  // head bank
D 9
  status=va_add_bank(p,L1THRESHBUFFERSIZE-nused,"HEAD",0,"I",8,1,8,banksize,
E 9
I 9
  status=va_add_bank(p,THRESHBUFFERSIZE-nused,"HEAD",0,"I",8,1,8,banksize,
E 9
	      nvers,run,nevnt,start,type,rocst,evcls,presc);
  if(status==0){
    p+=banksize;
    nused+=banksize;
E 10
D 17
  }
I 10
    
E 10

E 17
D 10

E 10
D 9
  // read l1 thresholds
  ifstream file("/usr/local/clas/parms/l1thresh/l1thresh.txt");
  for (i=0; i<12; i++){
    for (j=0; j<7; j++){
      file >> l1thresh[i][j];
    }
E 9
I 9
D 11
  // open threshold file
  ifstream file("/usr/local/clas/parms/pretrigger/threshold.txt");
  file.setf(ios::skipws);

  // get time
E 11
I 11
  // get time and fill bank
E 11
  find_tag_line(file,"*TIME*",buffer,sizeof(buffer));
  get_next_line(file,buffer,sizeof(buffer));
  buf >> time;
I 11
D 13
  if(debug==0){
E 13
I 13
D 17
  if(no_dd==0) {
E 13
    status=add_bank(p,PRETRIGBUFFERSIZE-nused,"PRTM",0,"I",1,1,1,banksize,(int *)&time);
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
  }
E 17
I 17
  add_bank("PRTM",0,"I",1,1,1,(int *)&time);
E 17
I 13
  if(debug!=0) {
    cout << "Pretrig bank PRTM, number 0, format I"
	 << ", ncol 3" << ", nrow 1, buflen 1" << endl;
  }
E 13
  
E 11

D 11
  // get fc thresholds
  find_tag_line(file,"*FC*",buffer,sizeof(buffer));
  for (i=0; i<sizeof(fcthresh)/sizeof(*fcthresh); i++) {
E 11
I 11
D 17

E 17
  // get ec thresholds and fill bank
D 12
  find_tag_line(file,"*EC_L1_T*",buffer,sizeof(buffer));
  for (i=0; i<16; i++) {
E 11
    get_next_line(file,buffer,sizeof(buffer));
    buf.seekg(0);
D 11
    for (j=0; j<sizeof(*fcthresh)/sizeof(int); j++){  buf >> fcthresh[i][j]; }
E 11
I 11
    for (j=0; j<6; j++){  buf >> pretrig[i][j]; }
E 11
E 9
  }
I 11
  if(debug==0){
    status=add_bank(p,PRETRIGBUFFERSIZE-nused,"ECPT",0,"6I",6,16,96,banksize,(int *)&pretrig[0][0]);
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
E 12
I 12
D 17
  status=create_pretrig_bank("ECPT",0,file,"*EC_L1_T*",p,nused,banksize);
  if(status==0){
    p+=banksize;
    nused+=banksize;
E 12
  }    
E 17
I 17
D 33
  create_pretrig_bank("ECPT",0,file,"*EC_L1_T*");
E 33
I 33
  create_pretrig_bank(6,"ECPT",0,file,"*EC_L1_T*");
E 33
E 17
D 12
  
E 12
E 11
I 9

D 11
  // get cc thresholds
  find_tag_line(file,"*CC*",buffer,sizeof(buffer));
E 11
I 11

  // get ec masks and fill bank
D 12
  find_tag_line(file,"*EC_L1_M*",buffer,sizeof(buffer));
  for (i=0; i<2; i++) {
    get_next_line(file,buffer,sizeof(buffer));
    buf.seekg(0);
    for (j=0; j<6; j++){  buf >> pretrig[i][j]; }
  }
  if(debug==0){
    status=add_bank(p,PRETRIGBUFFERSIZE-nused,"ECPM",0,"6I",6,1,6,banksize,(int *)&pretrig[0][0]);
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
E 12
I 12
D 17
  status=create_pretrig_bank("ECPM",0,file,"*EC_L1_M*",p,nused,banksize);
  if(status==0){
    p+=banksize;
    nused+=banksize;
E 12
  }    
E 17
I 17
D 33
  create_pretrig_bank("ECPM",0,file,"*EC_L1_M*");
E 33
I 33
  create_pretrig_bank(6,"ECPM",0,file,"*EC_L1_M*");
E 33
E 17
  

D 33

  // get cc thresholds and fill bank
I 12
  int npretrig=0;
  int ccpretrig[MAXPRETRIG][2];
E 12
  find_tag_line(file,"*CC_L1_T*",buffer,sizeof(buffer));
E 11
D 12
  get_next_line(file,buffer,sizeof(buffer));
  buf.seekg(0);
D 11
  for (j=0; j<sizeof(ccthresh)/sizeof(int); j++){  buf >> ccthresh[j]; }
E 11
I 11
  for (j=0; j<2; j++){  buf >> ccpretrig[j]; }
E 12
I 12
  while((npretrig<MAXPRETRIG)&&get_next_line(file,buffer,sizeof(buffer))==0) {
    npretrig++;
    buf.seekg(0);
    for (j=0; j<2; j++){  buf >> ccpretrig[npretrig-1][j]; }
  }
E 12
D 13
  if(debug==0){
E 13
I 13
D 17
  if(no_dd==0){
E 13
D 12
    status=add_bank(p,PRETRIGBUFFERSIZE-nused,"CCPT",0,"2I",2,1,2,banksize,(int *)&ccpretrig[0]);
E 12
I 12
    status=add_bank(p,PRETRIGBUFFERSIZE-nused,"CCPT",0,"2I",2,npretrig,2*npretrig,
		    banksize,(int *)&ccpretrig[0][0]);
E 12
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
D 13
  }    
E 13
I 13
  }
E 17
I 17
  add_bank("CCPT",0,"2I",2,npretrig,2*npretrig,(int *)&ccpretrig[0][0]);
E 17
  if(debug!=0) {
D 30
    cout << " Pretrig bank CCPT, number 2, format 2I"
E 30
I 30
    cout << "Pretrig bank CCPT, number 2, format 2I"
E 30
	 << ", ncol 2" << ", nrow " << npretrig
	 << ", buflen " << 2*npretrig << endl;
  }
E 33
I 33
  // get ec mean thresholds
  create_pretrig_bank(6,"ECMT",0,file,"*EC_Mean*");
E 33
E 13
E 11
  
D 11
  // close file
E 9
  file.close();
E 11

I 11
D 33
  // get sc thresholds and fill bank
D 12
  find_tag_line(file,"*SC_L1_T*",buffer,sizeof(buffer));
  for (i=0; i<3; i++) {
    get_next_line(file,buffer,sizeof(buffer));
    buf.seekg(0);
    for (j=0; j<6; j++){  buf >> pretrig[i][j]; }
E 12
I 12
D 17
  status=create_pretrig_bank("SCPT",0,file,"*SC_L1_T*",p,nused,banksize);
  if(status==0){
    p+=banksize;
    nused+=banksize;
E 12
  }
E 17
I 17
  create_pretrig_bank("SCPT",0,file,"*SC_L1_T*");
E 33
I 33
  // get cc thresholds
  create_pretrig_bank(4,"CCPT",0,file,"*CC_L1_T*");


  // get cc means
  create_pretrig_bank(2,"CCMT",0,file,"*CC_Mean*");

E 33
					       
I 33
  // get sc widths,thresholds,masks and fill bank
  create_pretrig_bank(3,"SCPT",0,file,"*SC_L1_T*");
E 33
					       
D 33
  // get sc widths and fill bank	       
  create_pretrig_bank("SCPW",0,file,"*SC_L1_W*");
E 33
					       
I 33
  // get sc mean threshold
  create_pretrig_bank(1,"SCMT",0,file,"*SC_MeanThr*");
E 33
					       
D 33
  // get sc masks and fill bank		       
  create_pretrig_bank("SCPM",0,file,"*SC_L1_M*");
E 33
E 17
D 12
  if(debug==0){
    status=add_bank(p,PRETRIGBUFFERSIZE-nused,"SCPT",0,"6I",6,3,18,banksize,(int *)&pretrig[0][0]);
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
  }    
E 12
E 11

I 11
D 33

E 33
I 33
  // get sc mean width
  create_pretrig_bank(1,"SCMW",0,file,"*SC_MeanWid*");
					       
					       
E 33
D 12

E 12
D 17
  // get sc widths and fill bank
D 12
  find_tag_line(file,"*SC_L1_W*",buffer,sizeof(buffer));
  for (i=0; i<3; i++) {
    get_next_line(file,buffer,sizeof(buffer));
    buf.seekg(0);
    for (j=0; j<6; j++){  buf >> pretrig[i][j]; }
  }
E 11
D 9
  // add bank
  status=add_bank(p,L1THRESHBUFFERSIZE-nused,"L1TH",0,"7I",7,12,84,banksize,(int *)&l1thresh[0][0]);
E 9
I 9
D 10
  // add threshold time bank
  status=add_bank(p,THRESHBUFFERSIZE-nused,"THTM",0,"I",1,1,1,banksize,(int *)&time);
E 9
  if(status==0){
    p+=banksize;
I 9
    nused+=banksize;
  }
E 10
I 10
  if(debug==0){
I 11
    status=add_bank(p,PRETRIGBUFFERSIZE-nused,"SCPW",0,"6I",6,3,18,banksize,(int *)&pretrig[0][0]);
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
E 12
I 12
  status=create_pretrig_bank("SCPW",0,file,"*SC_L1_W*",p,nused,banksize);
  if(status==0){
    p+=banksize;
    nused+=banksize;
E 12
  }    
E 11
E 10

I 10
D 11
    // add threshold time bank
    status=add_bank(p,THRESHBUFFERSIZE-nused,"THTM",0,"I",1,1,1,banksize,(int *)&time);
E 11
I 11

D 12

E 12
  // get sc masks and fill bank
D 12
  find_tag_line(file,"*SC_L1_M*",buffer,sizeof(buffer));
  for (i=0; i<3; i++) {
    get_next_line(file,buffer,sizeof(buffer));
    buf.seekg(0);
    for (j=0; j<6; j++){  buf >> pretrig[i][j]; }
E 12
I 12
  status=create_pretrig_bank("SCPM",0,file,"*SC_L1_M*",p,nused,banksize);
  if(status==0){
    p+=banksize;
    nused+=banksize;
E 12
  }
D 12
  if(debug==0){
    status=add_bank(p,PRETRIGBUFFERSIZE-nused,"SCPM",0,"6I",6,3,18,banksize,(int *)&pretrig[0][0]);
E 11
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
I 11
  }    
E 12


E 17
D 12

E 12
  // close file
  file.close();
D 17

E 17
E 11
    
I 18
D 56
  bosWrite(descriptor,bcs_.iw,"E");
  bosLdrop(bcs_.iw,"E");
E 56
I 56
  bosWrite(descriptor,bcs_.iw,(char*)"E");
  bosLdrop(bcs_.iw,(char*)"E");
E 56
  bosNgarbage(bcs_.iw);
I 23

E 23
E 18
I 11
D 17
  // all banks added...set fev and fpack overall word counts
D 13
  if(debug==0){
E 13
I 13
  if(no_dd==0){
E 13
    fev.len=nused;
    *(fev.p2da+10)=nused-nhead;
E 11
    
D 11
    // add fc threshold bank
    status=add_bank(p,THRESHBUFFERSIZE-nused,"THFC",0,"6I",6,16,96,banksize,(int *)&fcthresh[0][0]);
E 11
I 11
    // insert event into DD system
    status=ddu_put_fev(fev);
    if(status!=0){
      cerr << "?unable to put fev, status is: " << status << endl;
      return;
    }
  }
D 12
  
E 12
I 12

E 17
I 17
  return;
E 17
E 12
}


//----------------------------------------------------------------


I 12
D 17
int create_pretrig_bank(char *bankname, int num, ifstream &file, char *tag, 
			int *p, int nused, int &banksize) {
E 17
I 17
D 33
void create_pretrig_bank(char *bankname, int num, ifstream &file, char *tag) {
E 33
I 33
D 56
void create_pretrig_bank(int ncol, char *bankname, int num, ifstream &file, char *tag) {
E 56
I 56
D 66
void create_pretrig_bank(int ncol, const char *bankname, int num, ifstream &file, const char *tag) {
E 56
E 33
E 17

E 66
I 66
void
create_pretrig_bank(int ncol, const char *bankname, int num, ifstream &file, const char *tag)
{
E 66
  istrstream buf(buffer,sizeof(buffer));
  int npretrig=0;
D 17
  banksize=0;
E 17
D 33
  int pretrig[MAXPRETRIG][6];
E 33
I 33
  int *pretrig  = new int[MAXPRETRIG*ncol];
E 33
D 17
  int j,status;
E 17
I 17
  int j;
I 33
  char fmt[10];
E 33
E 17

  find_tag_line(file,tag,buffer,sizeof(buffer));
  while((npretrig<MAXPRETRIG)&&get_next_line(file,buffer,sizeof(buffer))==0) {
    npretrig++;
    buf.seekg(0);
D 33
    for (j=0; j<6; j++){  buf >> pretrig[npretrig-1][j]; }
E 33
I 33
D 38
    for (j=0; j<ncol; j++){  buf >> pretrig[(npretrig-1)*ncol+j]; }
E 38
I 38
    for (j=0; j<ncol; j++) {  buf >> pretrig[(npretrig-1)*ncol+j]; }
E 38
E 33
  }
D 13
  if(debug==0){
E 13
I 13


D 17
  if(no_dd==0){
E 13
    status=add_bank(p,PRETRIGBUFFERSIZE-nused,bankname,num,"6I",6,npretrig,6*npretrig,
		    banksize,(int *)&pretrig[0][0]);
  }
E 17
I 17
D 33
  add_bank(bankname,num,"6I",6,npretrig,6*npretrig,(int *)&pretrig[0][0]);
E 33
I 33
  sprintf(fmt,"%dI",ncol);
  add_bank(bankname,num,fmt,ncol,npretrig,ncol*npretrig,pretrig);
E 33
E 17
I 13
  if(debug!=0) {
D 33
    cout << "Pretrig bank " << bankname << ", number " << num << ", format 6I"
	 << ", ncol 6" << ", nrow " << npretrig
	 << ", buflen " << 6*npretrig<< endl;
E 33
I 33
    cout << "Pretrig bank " << bankname << ", number " << num << ", format " << fmt 
	 << ", ncol " << ncol << ", nrow " << npretrig
	 << ", buflen " << ncol*npretrig << endl;
E 33
  }
E 13

I 13
D 33

E 33
I 33
  delete []pretrig;
E 33
E 13
D 17
  return(status);
E 17
I 17
  return;
E 17
}


//----------------------------------------------------------------


E 12
D 17
void add_discr_event(int run){
E 17
I 17
D 66
void add_discr_event() {
E 17

E 66
I 66
void
add_discr_event()
{
E 66
D 17
  int status;
E 17
D 65
  int *p = 0;
E 65
D 17
  int i,j,nused,banksize,nhead,buflen;
  fifo_entry fev;
E 17
I 17
  int i,j,buflen;
E 17
D 12
  int discr[100][6];
  istrstream buf(buffer,sizeof(buffer));
E 12
  int time,ndisc;
I 12
  istrstream buf(buffer,sizeof(buffer));
E 12

I 12
D 17
#define MAXDISCR 100
E 17
D 34
  int discr[MAXDISCR][6];
E 34
I 34
  int discr[MAXDISCR][5];
I 35
  int lacdiscr[MAXDISCR][4];
E 35
E 34
E 12

I 12

E 12
D 17
  // get discr file name
  ifstream namefile("/usr/local/clas/parms/discr/current_discr.txt");
  if(namefile.bad())return;
  namefile.getline(filename,sizeof(filename));
  namefile.close();		


E 17
  // open discr file
I 30
D 65
  sprintf(filename,"%s/discr/archive/discr_%s_%06d.txt",getenv("CLON_PARMS"),session,run);
E 65
I 65
  sprintf(filename,"%s/discr/archive/discr_%s_%06d.txt",clon_parms,session,run);
E 65
E 30
  ifstream file(filename);
D 30
  if(file.bad())return;
E 30
I 30
D 57
  if(file.bad()) {
E 57
I 57
  if(!file.is_open()) {
E 57
    cerr << "Unable to open discr file " << filename << endl;
    return;
  }
E 30
  file.setf(ios::skipws);


D 17
  // get free fifo event
D 13
  if(debug==0){
E 13
I 13
  if(no_dd==0) {
E 13
    status=ddu_req_fev(DISCRBUFFERSIZE,&fev);
    if(status!=0){
      cerr << "?unable to get discr fev, status is: " << status << endl;
      return;
    }
E 17
I 17
  // head bank
D 22
  va_add_bank("HEAD",0,"I",8,1,8,run);
E 17
    
E 22
I 22
D 38
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,1,start,type,rocst,evcls,presc);
E 38
I 38
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,0,start,type,rocst,evcls,presc);
E 38
E 22
D 17
    
    // set pointer, reset counts, fill ctl words, etc.
    p=fev.p2da;
    nused=0;
    nhead=0;
    fev.ctlw1=ddctl[0];
    fev.ctlb1=ddctl[1];
    fev.ctlw2=ddctl[2];
    fev.ctlb2=ddctl[3];
    
    
    // create segment header, then update pointer and counters
D 15
    status=create_header(p,DISCRBUFFERSIZE-nused,nhead,run,nevnt,nphys,trig);
E 15
I 15
    status=create_header(p,DISCRBUFFERSIZE-nused,nhead,'RUNP','ARMS',run,nevnt,nphys,trig);
E 15
E 11
    if(status==0){
I 11
      p+=nhead;
      nused+=nhead;
    }  
    
    
    // head bank
    status=va_add_bank(p,DISCRBUFFERSIZE-nused,"HEAD",0,"I",8,1,8,banksize,
		       nvers,run,nevnt,start,type,rocst,evcls,presc);
    if(status==0){
E 11
      p+=banksize;
      nused+=banksize;
    }
E 17
I 11

I 22

E 22
D 17
  }
E 11
    
D 11
    
    // add cc threshold bank
    status=add_bank(p,THRESHBUFFERSIZE-nused,"THCC",0,"2I",2,1,2,banksize,(int *)&ccthresh[0]);
E 11
I 11

E 17
  // get time and fill bank
D 34
  find_tag_line(file,"*TIME*",buffer,sizeof(buffer));
  get_next_line(file,buffer,sizeof(buffer));
  buf >> time;
D 13
  if(debug==0){
E 13
I 13
D 17
  if(no_dd==0){
E 13
    status=add_bank(p,DISCRBUFFERSIZE-nused,"DITM",0,"I",1,1,1,banksize,(int *)&time);
E 11
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
I 11
  }
E 17
I 17
  add_bank("DITM",0,"I",1,1,1,(int *)&time);
E 17
I 13
  if(debug!=0) {
    cout << "Discr bank DITM, number 1, format I"
	 << ", ncol 1, nrow 1, buflen 1" << endl;
E 34
I 34
  if(find_tag_line(file,"*TIME*",buffer,sizeof(buffer))==0) {
    get_next_line(file,buffer,sizeof(buffer));
    buf >> time;
    add_bank("DITM",0,"I",1,1,1,(int *)&time);
    if(debug!=0) {
      cout << "Discr bank DITM, number 1, format I"
	   << ", ncol 1, nrow 1, buflen 1" << endl;
    }
  } else {
    cout << "Unable to find *TIME* in " << filename << endl;
E 34
  }
E 13
  


  // get ec channel discriminators and fill bank
  ndisc=0;
D 34
  find_tag_line(file,"*EC*",buffer,sizeof(buffer));
D 12
  while(get_next_line(file,buffer,sizeof(buffer))==0) {
E 12
I 12
  while((ndisc<MAXDISCR)&&(get_next_line(file,buffer,sizeof(buffer))==0)) {
E 12
    ndisc++;
    buf.seekg(0);
    for (j=0; j<6; j++){  buf >> discr[ndisc-1][j]; }
E 34
I 34
  if(find_tag_line(file,"*EC*",buffer,sizeof(buffer))==0) {
    while((ndisc<MAXDISCR)&&(get_next_line(file,buffer,sizeof(buffer))==0)) {
      ndisc++;
      buf.seekg(0);
D 38
      for (j=0; j<5; j++){  buf >> discr[ndisc-1][j]; }
E 38
I 38
      for (j=0; j<5; j++) {  buf >> discr[ndisc-1][j]; }
E 38
    }
    if(ndisc>0)add_bank("ECDI",0,"5I",5,ndisc,5*ndisc,(int *)&discr[0][0]);
    if(debug!=0) {
D 40
      cout << "Pretrig bank ECDI, number 0, format 5I"
E 40
I 40
      cout << "Discr bank ECDI, number 0, format 5I"
E 40
	   << ", ncol 5" << ", nrow " << ndisc
	   << ", buflen " << 5*ndisc << endl;
    }
  } else {
    cout << "Unable to find *EC* in " << filename << endl;
E 34
  }
D 13
  if((debug==0)&&(ndisc>0)){
E 13
I 13
D 17
  if((no_dd==0)&&(ndisc>0)) {
E 13
    status=add_bank(p,DISCRBUFFERSIZE-nused,"ECDI",0,"6I",6,ndisc,6*ndisc,banksize,(int *)&discr[0][0]);
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
  }    
E 17
I 17
D 34
  if(ndisc>0)add_bank("ECDI",0,"6I",6,ndisc,6*ndisc,(int *)&discr[0][0]);
E 17
I 13
  if(debug!=0) {
    cout << "Pretrig bank ECDI, number 0, format 6I"
	 << ", ncol 6" << ", nrow " << ndisc
	 << ", buflen " << 6*ndisc << endl;
  }
E 13
  
E 34


I 34

E 34
  // get cc channel discriminators and fill bank
  ndisc=0;
D 34
  find_tag_line(file,"*CC*",buffer,sizeof(buffer));
D 12
  while(get_next_line(file,buffer,sizeof(buffer))==0) {
E 12
I 12
  while((ndisc<MAXDISCR)&&get_next_line(file,buffer,sizeof(buffer))==0) {
E 12
    ndisc++;
    get_next_line(file,buffer,sizeof(buffer));
    buf.seekg(0);
    for (j=0; j<6; j++){  buf >> discr[ndisc-1][j]; }
E 34
I 34
  if(find_tag_line(file,"*CC*",buffer,sizeof(buffer))==0) {
    while((ndisc<MAXDISCR)&&get_next_line(file,buffer,sizeof(buffer))==0) {
      ndisc++;
D 35
      get_next_line(file,buffer,sizeof(buffer));
E 35
      buf.seekg(0);
D 38
      for (j=0; j<5; j++){  buf >> discr[ndisc-1][j]; }
E 38
I 38
      for (j=0; j<5; j++) {  buf >> discr[ndisc-1][j]; }
E 38
    }
    if(ndisc>0)add_bank("CCDI",0,"5I",5,ndisc,5*ndisc,(int *)&discr[0][0]);
    if(debug!=0) {
D 40
      cout << "Pretrig bank CCDI, number 0, format 5I"
E 40
I 40
      cout << "Discr bank CCDI, number 0, format 5I"
E 40
	   << ", ncol 5" << ", nrow " << ndisc
	   << ", buflen " << 5*ndisc << endl;
    }
  } else {
    cout << "Unable to find *CC* in " << filename << endl;
E 34
  }
D 13
  if((debug==0)&&(ndisc>0)){
E 13
I 13
D 17
  if((no_dd==0)&&(ndisc>0)){
E 13
    status=add_bank(p,DISCRBUFFERSIZE-nused,"CCDI",0,"6I",6,ndisc,6*ndisc,banksize,(int *)&discr[0][0]);
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
  }    
E 17
I 17
D 34
  if(ndisc>0)add_bank("CCDI",0,"6I",6,ndisc,6*ndisc,(int *)&discr[0][0]);
E 17
I 13
  if(debug!=0) {
    cout << "Pretrig bank CCDI, number 0, format 6I"
	 << ", ncol 6" << ", nrow " << ndisc
	 << ", buflen " << 6*ndisc << endl;
  }
E 13
  
E 34

I 34


E 34
  // get sc channel discriminators and fill bank
  ndisc=0;
D 34
  find_tag_line(file,"*SC*",buffer,sizeof(buffer));
D 12
  while(get_next_line(file,buffer,sizeof(buffer))==0) {
E 12
I 12
  while((ndisc<MAXDISCR)&&get_next_line(file,buffer,sizeof(buffer))==0) {
E 12
    ndisc++;
    get_next_line(file,buffer,sizeof(buffer));
    buf.seekg(0);
    for (j=0; j<6; j++){  buf >> discr[ndisc-1][j]; }
E 34
I 34
  if(find_tag_line(file,"*SC*",buffer,sizeof(buffer))==0) {
    while((ndisc<MAXDISCR)&&get_next_line(file,buffer,sizeof(buffer))==0) {
      ndisc++;
D 35
      get_next_line(file,buffer,sizeof(buffer));
E 35
      buf.seekg(0);
D 38
      for (j=0; j<5; j++){  buf >> discr[ndisc-1][j]; }
E 38
I 38
      for (j=0; j<5; j++) {  buf >> discr[ndisc-1][j]; }
E 38
    }
    if(ndisc>0)add_bank("SCDI",0,"5I",5,ndisc,5*ndisc,(int *)&discr[0][0]);
    if(debug!=0) {
D 40
      cout << "Pretrig bank SCDI, number 0, format 5I"
E 40
I 40
      cout << "Discr bank SCDI, number 0, format 5I"
E 40
	   << ", ncol 5" << ", nrow " << ndisc
	   << ", buflen " << 5*ndisc << endl;
    }
  } else {
    cout << "Unable to find *SC* in " << filename << endl;
E 34
  }
D 13
  if((debug==0)&&(ndisc>0)){
E 13
I 13
D 17
  if((no_dd==0)&&(ndisc>0)){
E 13
    status=add_bank(p,DISCRBUFFERSIZE-nused,"SCDI",0,"6I",6,ndisc,6*ndisc,banksize,(int *)&discr[0][0]);
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
  }    
E 17
I 17
D 34
  if(ndisc>0)add_bank("SCDI",0,"6I",6,ndisc,6*ndisc,(int *)&discr[0][0]);
E 17
I 13
  if(debug!=0) {
    cout << "Pretrig bank SCDI, number 0, format 6I"
	 << ", ncol 6" << ", nrow " << ndisc
	 << ", buflen " << 6*ndisc << endl;
  }
E 34
E 13


I 34

I 35
  // get lac channel discriminators and fill bank
  ndisc=0;
  if(find_tag_line(file,"*LAC_T*",buffer,sizeof(buffer))==0) {
    while((ndisc<MAXDISCR)&&get_next_line(file,buffer,sizeof(buffer))==0) {
      ndisc++;
      buf.seekg(0);
D 38
      for (j=0; j<4; j++){  buf >> lacdiscr[ndisc-1][j]; }
E 38
I 38
      for (j=0; j<4; j++) {  buf >> lacdiscr[ndisc-1][j]; }
E 38
    }
    if(ndisc>0)add_bank("LCDI",0,"4I",4,ndisc,4*ndisc,(int *)&lacdiscr[0][0]);
    if(debug!=0) {
D 40
      cout << "Pretrig bank LCDI, number 0, format 4I"
E 40
I 40
      cout << "Discr bank LCDI, number 0, format 4I"
E 40
	   << ", ncol 4" << ", nrow " << ndisc
	   << ", buflen " << 4*ndisc << endl;
    }
  } else {
    cout << "Unable to find *LAC_T* in " << filename << endl;
  }


E 35
E 34
D 17
  // close file
E 17
I 17
  // done
E 17
  file.close();
I 18
D 56
  bosWrite(descriptor,bcs_.iw,"E");
  bosLdrop(bcs_.iw,"E");
E 56
I 56
  bosWrite(descriptor,bcs_.iw,(char*)"E");
  bosLdrop(bcs_.iw,(char*)"E");
E 56
  bosNgarbage(bcs_.iw);
I 23

E 23
E 18
D 17

E 11
    
D 11
    
    // all banks added...set fev and fpack overall word counts
E 11
I 11
  // all banks added...set fev and fpack overall word counts
D 13
  if(debug==0){
E 13
I 13
  if(no_dd==0){
E 13
E 11
    fev.len=nused;
    *(fev.p2da+10)=nused-nhead;
    
D 11
    
E 11
    // insert event into DD system
    status=ddu_put_fev(fev);
    if(status!=0){
      cerr << "?unable to put fev, status is: " << status << endl;
      return;
    }
E 10
D 11

E 11
D 10
  // add fc threshold bank
  status=add_bank(p,THRESHBUFFERSIZE-nused,"THFC",0,"6I",6,16,96,banksize,(int *)&fcthresh[0][0]);
  if(status==0){
    p+=banksize;
    nused+=banksize;
E 10
  }
D 11

E 11
I 11
  
E 17
I 17
  return;
E 17
E 11
D 10

  // add cc threshold bank
  status=add_bank(p,THRESHBUFFERSIZE-nused,"THCC",0,"2I",2,1,2,banksize,(int *)&ccthresh[0]);
  if(status==0){
    p+=banksize;
E 9
    nused+=banksize;
  }


  // all banks added...set fev and fpack overall word counts
  fev.len=nused;
  *(fev.p2da+10)=nused-nhead;


  // insert event into DD system
  status=ddu_put_fev(fev);
  if(status!=0){
    cerr << "?unable to put fev, status is: " << status << endl;
    return;
  }


E 10
}
E 7


//----------------------------------------------------------------


D 8
void epics_callback_func(int status, void *userarg, cdevRequestObject &epics_req_obj,
			    cdevData& result){
E 8
I 8
D 17
void add_ts_event(int run){
E 17
I 17
D 66
void add_ts_event() {
E 17
E 8

E 66
I 66
void
add_ts_event()
{
E 66
D 8
  ncallback++;
  channel_val[(int)userarg] = (int) result;
E 8
I 8
D 11
  int status;
E 11
I 11
D 17
  int status,stat1,stat2;
E 11
D 10
  int *p,i,j,nused,banksize,nhead,buflen;
E 10
I 10
  int *p=0;
  int i,j,nused,banksize,nhead,buflen;
E 10
  fifo_entry fev;
E 17
I 17
  int stat1,stat2;
  int i,j,buflen;
E 17
D 36
  int tsreg[32],tsprog[4096];
E 36
I 36
  int tsreg[128],tsprog[4096];
  istrstream buf(buffer,sizeof(buffer));
E 36
E 8

D 8
  return;
}
E 8

I 11
  // open ts file
D 17
  ifstream file("/usr/local/clas/parms/ts/current_ts_program.txt");
E 17
I 17
D 65
  sprintf(filename,"%s/ts/current_ts_program.txt",getenv("CLON_PARMS"));
E 65
I 65
  sprintf(filename,"%s/ts/current_ts_program.txt",clon_parms);
E 65
  ifstream file(filename);
E 17
D 38
  if(file.bad()){
E 38
I 38
D 57
  if(file.bad()) {
E 57
I 57
  if(!file.is_open()) {
E 57
E 38
    cerr << "?unable to open ts program file" << endl;
    return;
  }
    
I 13

E 13
  // check if program read properly
  stat1=find_tag_line(file,"*TSREG*",buffer,sizeof(buffer));
  stat2=find_tag_line(file,"*TSPROG*",buffer,sizeof(buffer));
D 38
  if((stat1!=0)||(stat2!=0)){
E 38
I 38
  if((stat1!=0)||(stat2!=0)) {
E 38
    cerr << "?unable to read ts" << endl;
    file.close();
    return;
  }


E 11
I 8
D 17
  // get free fifo event
D 10
  status=ddu_req_fev(TSBUFFERSIZE,&fev);
  if(status!=0){
    cerr << "?unable to get ts fev, status is: " << status << endl;
    return;
E 10
I 10
D 13
  if(debug==0){
E 13
I 13
  if(no_dd==0) {
E 13
    status=ddu_req_fev(TSBUFFERSIZE,&fev);
    if(status!=0){
      cerr << "?unable to get ts fev, status is: " << status << endl;
      return;
    }
    
    
    // set pointer, reset counts, fill ctl words, etc.
    p=fev.p2da;
    nused=0;
    nhead=0;
    fev.ctlw1=ddctl[0];
    fev.ctlb1=ddctl[1];
    fev.ctlw2=ddctl[2];
    fev.ctlb2=ddctl[3];
    
    
    // create segment header, then update pointer and counters
D 15
    status=create_header(p,TSBUFFERSIZE-nused,nhead,run,nevnt,nphys,trig);
E 15
I 15
    status=create_header(p,TSBUFFERSIZE-nused,nhead,'RUNP','ARMS',run,nevnt,nphys,trig);
E 15
    if(status==0){
      p+=nhead;
      nused+=nhead;
    }  
    
    
    // head bank
    status=va_add_bank(p,TSBUFFERSIZE-nused,"HEAD",0,"I",8,1,8,banksize,
		       nvers,run,nevnt,start,type,rocst,evcls,presc);
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
    
E 10
  }
E 17
I 17
  // head bank
D 22
  va_add_bank("HEAD",0,"I",8,1,8,run);
E 22
I 22
D 38
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,1,start,type,rocst,evcls,presc);
E 38
I 38
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,0,start,type,rocst,evcls,presc);
E 38
E 22
E 17
E 8

D 8
//---------------------------------------------------------------------------
E 8

I 8
D 10
  // set pointer, reset counts, fill ctl words, etc.
  p=fev.p2da;
  nused=0;
  nhead=0;
  fev.ctlw1=ddctl[0];
  fev.ctlb1=ddctl[1];
  fev.ctlw2=ddctl[2];
  fev.ctlb2=ddctl[3];
E 8

E 6
D 8
int get_run_number(){
E 8

I 8
  // create segment header, then update pointer and counters
  status=create_header(p,TSBUFFERSIZE-nused,nhead,run,nevnt,nphys,trig);
  if(status==0){
    p+=nhead;
    nused+=nhead;
  }  
E 8

D 8
  m_result *result;
  m_row row_out;
  ostrstream query;
  
E 8

D 8
  // connect to msql database
  int connNum = msqlConnect(getenv("MSQL_TCP_HOST"));
  msqlSelectDB(connNum,msql_database);
  
E 8
I 8
  // head bank
  status=va_add_bank(p,TSBUFFERSIZE-nused,"HEAD",0,"I",8,1,8,banksize,
	      nvers,run,nevnt,start,type,rocst,evcls,presc);
  if(status==0){
    p+=banksize;
    nused+=banksize;
  }
E 8

D 8
  // form msql query, execute, then close msql connection
  query << "select runNumber from sessions where name='"
	<< session << "'" << ends;
  msqlQuery(connNum,query.str());
  result = msqlStoreResult();
  row_out = msqlFetchRow(result);
  msqlClose(connNum);
  
E 8

E 10
D 8
  // get run number 
  return(atoi(row_out[0]));
E 8
I 8
D 11
  // read ts program in 2 pieces
  ifstream file("/usr/local/clas/parms/ts/ts_program.txt");
E 11
I 11
  // read ts registers
  find_tag_line(file,"*TSREG*",buffer,sizeof(buffer));
E 11
D 36
  for (i=0; i<32; i++) {
    file >> hex >> tsreg[i];
E 36
I 36
  for(i=0; i<16; i++) {
    get_next_line(file,buffer,sizeof(buffer));
    buf.seekg(0);
    for (j=0; j<8; j++) buf >> hex >> tsreg[8*i+j];
E 36
  }
I 11

  // read ts program
  find_tag_line(file,"*TSPROG*",buffer,sizeof(buffer));
E 11
D 36
  for (i=0; i<4096; i++) {
    file >> hex >> tsprog[i];
E 36
I 36
  for(i=0; i<512; i++) {
    get_next_line(file,buffer,sizeof(buffer));
    buf.seekg(0);
    for (j=0; j<8; j++) buf >> hex >> tsprog[8*i+j];
E 36
  }
  file.close();


D 10
  // add ts register bank
  status=add_bank(p,TSBUFFERSIZE-nused,"TSRG",0,"B32",32,1,32,banksize,(int *)&tsreg[0]);
  if(status==0){
    p+=banksize;
    nused+=banksize;
E 10
I 10
D 13
  if(debug==0){

    // add ts register bank
E 13
I 13
  // add ts register bank
D 17
  if(no_dd==0){
E 13
    status=add_bank(p,TSBUFFERSIZE-nused,"TSRG",0,"B32",32,1,32,banksize,(int *)&tsreg[0]);
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
D 13
    
    
    // add ts program bank
E 13
I 13
  }    
E 17
I 17
D 36
  add_bank("TSRG",0,"B32",32,1,32,(int *)&tsreg[0]);
E 36
I 36
  add_bank("TSRG",0,"B32",128,1,128,(int *)&tsreg[0]);
E 36
E 17
  if(debug!=0) {
    cout << "TS bank TSRG, number 0, format B32"
D 36
	 << ", ncol 32, nrow 1, buflen 32" << endl;
E 36
I 36
	 << ", ncol 128, nrow 1, buflen 128" << endl;
E 36
  }


  // add ts program bank
D 17
  if(no_dd==0) {
E 13
    status=add_bank(p,TSBUFFERSIZE-nused,"TSPR",0,"B32",4096,1,4096,banksize,(int *)&tsprog[0]);
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
I 13
  }    
E 17
I 17
  add_bank("TSPR",0,"B32",4096,1,4096,(int *)&tsprog[0]);
E 17
  if(debug!=0) {
    cout << "TS bank TSPR, number 0, format B32"
	 << ", ncol 4096, nrow 1, buflen 4096" << endl;
  }
E 13
    
I 18
D 56
  bosWrite(descriptor,bcs_.iw,"E");
  bosLdrop(bcs_.iw,"E");
E 56
I 56
  bosWrite(descriptor,bcs_.iw,(char*)"E");
  bosLdrop(bcs_.iw,(char*)"E");
E 56
  bosNgarbage(bcs_.iw);
I 23

E 23
E 18
D 13
    
    // all banks added...set fev and fpack overall word counts
E 13
I 13
D 17

  // all banks added...set fev and fpack overall word counts
  if(no_dd==0) {
E 13
    fev.len=nused;
    *(fev.p2da+10)=nused-nhead;
    
    
    // insert event into DD system
    status=ddu_put_fev(fev);
    if(status!=0){
      cerr << "?unable to put fev, status is: " << status << endl;
      return;
    }

E 10
  }

E 17
I 17
  return;
E 17
I 10
}
E 10

D 10
  // add ts program bank
  status=add_bank(p,TSBUFFERSIZE-nused,"TSPR",0,"B32",4096,1,4096,banksize,(int *)&tsprog[0]);
  if(status==0){
    p+=banksize;
    nused+=banksize;
E 10
I 10

//----------------------------------------------------------------


I 65
D 66
void add_trig_event() {

E 66
I 66
void
add_trig_event()
{
E 66
  int i,buflen;
  char trig_buf[256];
  char trig_prog[MAXTRIG];


  // read trig program into local array
  sprintf(temp,"%s/%s",clon_parms,trig_name);
D 67
  trig_prog[0]=NULL;
E 67
I 67
  trig_prog[0] = (char)NULL;
E 67
  ifstream trigprog(temp);
  if(!trigprog.is_open()) {
    cerr << "Unable to read trig program file " << trig_name << endl;
    return;
  }

  while(trigprog.is_open()&&trigprog.good()&&!trigprog.eof()&&!trigprog.fail()&&!trigprog.bad()) {
    trigprog.getline(trig_buf,sizeof(trig_buf));
    strcat(trig_prog,trig_buf);
    strcat(trig_prog,"\n");
  }
  trigprog.close();


  // head bank
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,0,start,type,rocst,evcls,presc);


  // add trig program bank
  buflen=(strlen(trig_prog)+1)/4;
  add_bank("TRCF",0,"A",buflen,1,buflen,(int *)&trig_prog[0]);
  if(debug!=0) {
    cout << "TRIG bank TRCF number 0, format A, ncol " << buflen << ", nrow 1"
	 << ", buflen " << buflen << endl;
  }


  bosWrite(descriptor,bcs_.iw,(char*)"E");
  bosLdrop(bcs_.iw,(char*)"E");
  bosNgarbage(bcs_.iw);

  return;
}


//----------------------------------------------------------------


E 65
D 17
void add_l1prog_event(int run){
E 17
I 17
D 66
void add_l1prog_event() {
E 17

E 66
I 66
void
add_l1prog_event()
{
E 66
D 17
  int status;
E 17
D 65
  int *p=0;
D 17
  int i,j,nused,banksize,nhead,buflen;
  fifo_entry fev;
E 17
I 17
  int i,j,buflen;
E 65
I 65
  int i,buflen;
E 65
E 17
D 60
  char l1_name[120];
E 60
I 60
D 64
  char l1_name[256];
E 64
I 64
  char l1_name[512];
E 64
E 60
D 13
  char l1_buf[120];
E 13
I 13
D 65
  char l1_buf[200];
E 65
I 65
  char l1_buf[256];
E 65
I 64
  char l1_prog[MAXL1];
E 64
E 13
D 11
  char *l1_prog=new char[L1BUFFERSIZE*4];
E 11


D 17
  // get free fifo event
D 13
  if(debug==0){
E 13
I 13
  if(no_dd==0){
E 13
    status=ddu_req_fev(L1BUFFERSIZE,&fev);
    if(status!=0){
      cerr << "?unable to get l1 program fev, status is: " << status << endl;
      return;
    }
    
    
    // set pointer, reset counts, fill ctl words, etc.
    p=fev.p2da;
    nused=0;
    nhead=0;
    fev.ctlw1=ddctl[0];
    fev.ctlb1=ddctl[1];
    fev.ctlw2=ddctl[2];
    fev.ctlb2=ddctl[3];
    
    
    // create segment header, then update pointer and counters
D 15
    status=create_header(p,L1BUFFERSIZE-nused,nhead,run,nevnt,nphys,trig);
E 15
I 15
    status=create_header(p,L1BUFFERSIZE-nused,nhead,'RUNP','ARMS',run,nevnt,nphys,trig);
E 15
    if(status==0){
      p+=nhead;
      nused+=nhead;
    }  
    
    
    // head bank
    status=va_add_bank(p,L1BUFFERSIZE-nused,"HEAD",0,"I",8,1,8,banksize,
		       nvers,run,nevnt,start,type,rocst,evcls,presc);
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
    
E 10
  }
E 17
I 17
D 60
  // head bank
D 22
  va_add_bank("HEAD",0,"I",8,1,8,run);
E 22
I 22
D 38
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,1,start,type,rocst,evcls,presc);
E 38
I 38
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,0,start,type,rocst,evcls,presc);
E 38
E 22
E 17


D 10
  // all banks added...set fev and fpack overall word counts
  fev.len=nused;
  *(fev.p2da+10)=nused-nhead;
E 10
I 10
  // get l1 program  file name
E 60
I 60
  // get l1 program file name
E 60
D 22
  ifstream l1name("/home/clasrun/Current.Config");
E 22
I 22
D 65
  sprintf(temp,"%s/ts/Current.Config",getenv("CLON_PARMS"));
E 65
I 65
  sprintf(temp,"%s/ts/Current.Config",clon_parms);
E 65
  ifstream l1name(temp);
I 30
D 57
  if(l1name.bad()) {
E 57
I 57
  if(!l1name.is_open()) {
E 57
    cerr << "Unable to read l1 name file " << temp << endl;
    return;
  }
E 30
E 22
  l1name.getline(l1_name,sizeof(l1_name));
  l1name.close();
E 10


D 10
  // insert event into DD system
  status=ddu_put_fev(fev);
  if(status!=0){
    cerr << "?unable to put fev, status is: " << status << endl;
    return;
E 10
I 10
D 11
  // read l1 program
E 11
I 11
  // read l1 program into local array
D 17
  char *l1_prog=new char[L1BUFFERSIZE*4];
E 17
I 17
D 20
  char *l1_prog=new char[L1SIZE];
E 20
I 20
D 64
  char *l1_prog=new char[MAXL1];
E 64
E 20
E 17
E 11
D 67
  l1_prog[0]=NULL;
E 67
I 67
  l1_prog[0] = (char)NULL;
E 67
D 60
  ifstream l1prog(l1_name);
E 60
I 60
D 64
  strcpy(temp,"/home/trigger/");
  strcat(temp,l1_name);
  ifstream l1prog(temp);
E 64
I 64
  ifstream l1prog(l1_name);
E 64
E 60
I 30
D 57
  if(l1prog.bad()) {
E 57
I 57
  if(!l1prog.is_open()) {
E 57
    cerr << "Unable to read l1 program file " << l1_name << endl;
    return;
  }
E 30
D 38
  while (l1prog.eof()==0){
E 38
I 38
D 59
  while (l1prog.eof()==0) {
E 59
I 59
  while(l1prog.is_open()&&l1prog.good()&&!l1prog.eof()&&!l1prog.fail()&&!l1prog.bad()) {
E 59
E 38
    l1prog.getline(l1_buf,sizeof(l1_buf));
    strcat(l1_prog,l1_buf);
    strcat(l1_prog,"\n");
E 10
  }
I 10
  l1prog.close();
E 10

I 60


  // head bank
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,0,start,type,rocst,evcls,presc);
E 60

I 10

D 13
  if(debug==0){

    // add l1 program bank
    buflen=(strlen(l1_prog)+1)/4;
    status=add_bank(p,L1BUFFERSIZE-nused,"L1PG",0,"A",1,buflen,buflen,banksize,(int *)&l1_prog[0]);
E 13
I 13
  // add l1 program bank
  buflen=(strlen(l1_prog)+1)/4;
D 17
  if(no_dd==0) {
    status=add_bank(p,L1BUFFERSIZE-nused,"L1PG",0,"A",buflen,1,buflen,banksize,(int *)&l1_prog[0]);
E 13
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
I 11
D 13
    delete l1_prog;
E 13
I 13
  }
E 17
I 17
  add_bank("L1PG",0,"A",buflen,1,buflen,(int *)&l1_prog[0]);
E 17
  if(debug!=0) {
    cout << "L1 bank L1PG number 0, format A, ncol " << buflen << ", nrow 1"
	 << ", buflen " << buflen << endl;
  }


I 30
D 56
  bosWrite(descriptor,bcs_.iw,"E");
  bosLdrop(bcs_.iw,"E");
E 56
I 56
  bosWrite(descriptor,bcs_.iw,(char*)"E");
  bosLdrop(bcs_.iw,(char*)"E");
E 56
  bosNgarbage(bcs_.iw);

E 30
E 13
E 11
D 17
    
D 13
    
    // all banks added...set fev and fpack overall word counts
E 13
I 13
  // all banks added...set fev and fpack overall word counts
  if(no_dd==0){
E 13
    fev.len=nused;
    *(fev.p2da+10)=nused-nhead;
    
    
    // insert event into DD system
    status=ddu_put_fev(fev);
    if(status!=0){
      cerr << "?unable to put fev, status is: " << status << endl;
I 13
      delete l1_prog;
E 13
      return;
    }
D 13

I 11
  } else {
    delete l1_prog;
E 13
E 11
  }

E 17
I 13
D 64
  delete l1_prog;
E 64
I 64

E 64
D 17

E 17
I 17
  return;
E 17
E 13
E 10
E 8
}


I 8
//----------------------------------------------------------------
E 8

D 8
//--------------------------------------------------------------------------
E 8

I 8
D 30
void epics_callback_func(int status, void *userarg, cdevRequestObject &epics_req_obj,
D 22
			    cdevData& result){
E 22
I 22
			    cdevData& result) {
E 22
E 8

I 8
  ncallback++;
  channel_val[(int)userarg] = (int) result;

  return;
}


//---------------------------------------------------------------------------


E 30
I 18
D 37
void va_add_bank(char *name, int num, char *format, int ncol, int nrow, int ndata, ...){
E 37
I 37
D 66
void add_brep_event() {
E 37

E 66
I 66
void
add_brep_event()
{
E 66
I 37
D 67
  cdevGroup group;
I 55
  int i;
E 67
I 67
  int i, result;
E 67
E 55
I 52
  int i;
E 52
E 37

D 37
  int i,ind;
  va_list ap;
E 37

D 37
  int namelen=strlen(name);
  int fmtlen=strlen(format);
E 37
I 37
  // head bank
D 38
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,1,start,type,rocst,evcls,presc);
E 38
I 38
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,0,start,type,rocst,evcls,presc);
E 38
E 37

I 23
D 37
  bosLctl(bcs_.iw,"E+",name);
E 23
  bosNformat(bcs_.iw,name,format);
  ind=bosNcreate(bcs_.iw,name,num,ncol,nrow);
E 37

D 37
  va_start(ap,ndata);
D 23
  for(i=1; i<=ndata; i++) bcs_.iw[ind+i]=va_arg(ap,int);
E 23
I 23
  for(i=0; i<ndata; i++) bcs_.iw[ind+i]=va_arg(ap,int);
E 23
  va_end(arg);
E 37
I 37
D 67
  // create request objects and callbacks
D 38
  for(int i=0; i<nepics; i++){
E 38
I 38
D 52
D 55
  for(int i=0; i<nepics; i++) {
E 55
I 55
  for(i=0; i<nepics; i++) {
E 67
I 67
  for(i=0; i<nepics; i++)
  {
E 67
E 55
E 52
I 52
  for(i=0; i<nepics; i++) {
E 52
E 38
    epics_val[i]=-9999.0;
D 42
    obj[i] = cdevRequestObject::attachPtr(epics_chan[i],"get");
E 42
I 42
D 53
D 55
    obj[i] = cdevRequestObject::attachPtr(epics[i].chan,epics[i].get);
E 55
I 55
D 67
    obj[i] = cdevRequestObject::attachPtr((char*)epics[i].chan,(char*)epics[i].get);
E 55
E 53
I 53
    obj[i] = cdevRequestObject::attachPtr((char*)epics[i].chan,(char*)epics[i].get);
E 53
E 42
    cb[i] = new cdevCallback(epics_callback_func,(void*)i);
E 67
  }
E 37
D 67

D 37
  return;
}
E 37

I 37
  // create group
  group.start();
D 38
  for(i=0; i<nepics; i++){
E 38
I 38
D 50
  for(i=0; i<nepics; i++) {
E 50
I 50
  for(int i=0; i<nepics; i++) {
E 50
E 38
    if(obj[i]!=NULL)obj[i]->sendCallback(NULL,*cb[i]);
  }
E 37

E 67
I 67
  result = getepics(nepics, epics_chan, epics_val);
E 67
D 37
//----------------------------------------------------------------
E 37
I 37
  
D 67
  // process group
  group.pend((double)cdev_pend_time);
  
  
E 67
I 67
  /*
E 67
  // check if all callbacks received
D 38
  if(ncallback<nepics){
E 38
I 38
  if(ncallback<nepics) {
E 38
    cerr << "?only received " << ncallback << " callbacks out of " 
	 << nepics << " expected" << endl;
  }    
E 37
D 67

E 67
I 67
  */
E 67
I 37
  
  // create bos bank
D 38
  add_bank("BREP",0,"F",nepics,1,nepics,(int *)&epics_val[0]);
E 38
I 38
  add_bank("BREP",2,"F",nepics,1,nepics,(int *)&epics_val[0]);
E 38
  if(debug!=0) {
    cout << "bank BREP, number 0, format F, ncol " << nepics << ", nrow 1, buflen " << nepics << endl;
  }
E 37

D 37
void add_bank(char *name, int num, char *format, int ncol, int nrow, int ndata, int data[]){
E 37

I 37
  // write bank
D 56
  bosWrite(descriptor,bcs_.iw,"E");
  bosLdrop(bcs_.iw,"E");
E 56
I 56
  bosWrite(descriptor,bcs_.iw,(char*)"E");
  bosLdrop(bcs_.iw,(char*)"E");
E 56
  bosNgarbage(bcs_.iw);
  return;
}
E 37

D 37
  int i,ind;
  int namelen=strlen(name);
  int fmtlen=strlen(format);
E 37

I 23
D 37
  bosLctl(bcs_.iw,"E+",name);
E 23
  bosNformat(bcs_.iw,name,format);
  ind=bosNcreate(bcs_.iw,name,num,ncol,nrow);
E 37
I 37
D 67
//----------------------------------------------------------------
E 37

D 23
  for(i=1; i<=ndata; i++) bcs_.iw[ind+i]=data[i-1];
E 23
I 23
D 37
  for(i=0; i<ndata; i++) bcs_.iw[ind+i]=data[i];
E 37
E 23

I 37
D 66
void epics_callback_func(int status, void *userarg, cdevRequestObject &epics_req_obj,
D 38
			    cdevData& result){
E 38
I 38
			    cdevData& result) {
E 38

E 66
I 66
void
epics_callback_func(int status, void *userarg, cdevRequestObject &epics_req_obj,
			    cdevData& result)
{
E 66
  ncallback++;
  epics_val[(int)userarg] = (float) result;

E 37
  return;
}


E 67
D 37
//----------------------------------------------------------------
E 37
I 37
//---------------------------------------------------------------------------
I 46


D 66
void add_mlu_event() {

E 66
I 66
void
add_mlu_event()
{
E 66
D 47
  int mlu[10];
  
E 47
I 47
  int buflen;
D 63
  char mlu_buf[200];
E 63
E 47

D 47
  // read mlu stuff
E 47

I 47
  // open mlu file
D 49
  sprintf(temp,"%s/euphrates/current_mlu.txt",getenv("CLON_PARMS"));
E 49
I 49
D 65
  sprintf(temp,"%s/euphrates/current.trg",getenv("CLON_PARMS"));
E 65
I 65
  sprintf(temp,"%s/euphrates/current.trg",clon_parms);
E 65
E 49
  ifstream mlu(temp);
D 57
  if(mlu.bad()) {
E 57
I 57
  if(!mlu.is_open()) {
E 57
    cerr << "Unable to read mlu file " << temp << endl;
    return;
  }


  // create and fill text string from file
  char *mlu_prog=new char[MAXMLU];
D 67
  mlu_prog[0]=NULL;
E 67
I 67
  mlu_prog[0] = (char)NULL;
E 67
  while (mlu.eof()==0) {
D 63
    mlu.getline(mlu_buf,sizeof(mlu_buf));
    strcat(mlu_prog,mlu_buf);
E 63
I 63
    mlu.getline(temp,sizeof(temp));
    strcat(mlu_prog,temp);
E 63
    strcat(mlu_prog,"\n");
  }
  mlu.close();
E 47


  // head bank
  va_add_bank("HEAD",0,"I",8,1,8,nvers,run,0,start,type,rocst,evcls,presc);


D 47
  // create bos bank
  add_bank("MLU ",0,"I",1,1,1,mlu);
E 47
I 47
  buflen=(strlen(mlu_prog)+1)/4;
  add_bank("MLU ",0,"A",buflen,1,buflen,(int *)&mlu_prog[0]);
  if(debug!=0) {
    cout << "MLU bank MLU  number 0, format A, ncol " << buflen << ", nrow 1"
	 << ", buflen " << buflen << endl;
  }
E 47

D 63

E 63
  // write bank
D 56
  bosWrite(descriptor,bcs_.iw,"E");
  bosLdrop(bcs_.iw,"E");
E 56
I 56
  bosWrite(descriptor,bcs_.iw,(char*)"E");
  bosLdrop(bcs_.iw,(char*)"E");
E 56
  bosNgarbage(bcs_.iw);
D 47
  return;
E 47

I 47
  delete mlu_prog;

  return;
E 47
}


//----------------------------------------------------------------
E 46
E 37


E 18
E 8
D 37
void decode_command_line(int argc, char **argv)
{
E 37
I 37
D 66
void decode_command_line(int argc, char **argv) {
E 37

E 66
I 66
void
decode_command_line(int argc, char **argv)
{
E 66
  int i=1;
D 10
  char *help="\nusage:\n\n  begin_run_event [-m msql_database]  [-s session]\n\n\n";
E 10
I 10
D 13
  char *help="\nusage:\n\n  begin_run_event [-m msql_database]  [-s session] [-debug]\n\n\n";
E 13
I 13
D 17
  char *help="\nusage:\n\n  begin_run_event [-m msql_database]  [-s session] [-no_dd] [-debug]\n\n\n";
E 17
I 17
D 20
  char *help="\nusage:\n\n  begin_run_event [-m msql_database]  [-s session] [-debug]\n\n\n";
E 20
I 20
D 45
  char *help="\nusage:\n\n  begin_run_event [-m msql_database] [-s session] [-f file_loc] [-debug]\n\n\n";
E 45
I 45
D 53
D 55
  char *help="\nusage:\n\n  begin_run_event [-m msql_database] [-s session] [-f file_loc] [-p cdev_pend_time] [-debug]\n\n\n";
E 55
I 55
D 67
  const char *help="\nusage:\n\n  begin_run_event [-m msql_database] [-s session] [-f file_loc] [-p cdev_pend_time] [-debug]\n\n\n";
E 67
I 67
  const char *help="\nusage:\n\n  begin_run_event [-m msql_database] [-s session] [-f file_loc] [-debug]\n\n\n";
E 67
E 55
E 53
I 53
  const char *help="\nusage:\n\n  begin_run_event [-m msql_database] [-s session] [-f file_loc] [-p cdev_pend_time] [-debug]\n\n\n";
E 53
E 45
E 20
E 17
E 13
E 10


  while(i<argc) {
    
D 38
    if(strncasecmp(argv[i],"-h",2)==0){
E 38
I 38
    if(strncasecmp(argv[i],"-h",2)==0) {
E 38
      printf(help);
      exit(EXIT_SUCCESS);
    }
I 13
D 17
    else if (strncasecmp(argv[i],"-no_dd",6)==0){
      no_dd=1;
      i=i+1;
    }
E 17
E 13
I 10
D 38
    else if (strncasecmp(argv[i],"-debug",6)==0){
E 38
I 38
    else if (strncasecmp(argv[i],"-debug",6)==0) {
E 38
      debug=1;
      i=i+1;
    }
E 10
D 38
    else if (strncasecmp(argv[i],"-s",2)==0){
E 38
I 38
    else if (strncasecmp(argv[i],"-s",2)==0) {
E 38
      session=strdup(argv[i+1]);
      i=i+2;
    }
D 38
    else if (strncasecmp(argv[i],"-m",2)==0){
E 38
I 38
    else if (strncasecmp(argv[i],"-m",2)==0) {
E 38
      msql_database=strdup(argv[i+1]);
      i=i+2;
    }
I 20
D 38
    else if (strncasecmp(argv[i],"-f",2)==0){
E 38
I 38
    else if (strncasecmp(argv[i],"-f",2)==0) {
E 38
      file_loc=strdup(argv[i+1]);
I 45
      i=i+2;
    }
D 67
    else if (strncasecmp(argv[i],"-p",2)==0) {
      cdev_pend_time=atoi(argv[i+1]);
E 45
      i=i+2;
    }
E 67
E 20
I 10
    else{
      i=i+1;
    }
E 10
  }
}


D 37
/*---------------------------------------------------------------------*/
E 37
I 37
//---------------------------------------------------------------------


D 38
void va_add_bank(char *name, int num, char *format, int ncol, int nrow, int ndata, ...){
E 38
I 38
D 56
void va_add_bank(char *name, int num, char *format, int ncol, int nrow, int ndata, ...) {
E 56
I 56
D 66
void va_add_bank(const char *name, int num, const char *format, int ncol, int nrow, int ndata, ...) {
E 56
E 38


E 66
I 66
void
va_add_bank(const char *name, int num, const char *format, int ncol, int nrow, int ndata, ...)
{
E 66
  int i,ind;
  va_list ap;

D 63
  int namelen=strlen(name);
  int fmtlen=strlen(format);
E 63

D 56
  bosLctl(bcs_.iw,"E+",name);
  bosNformat(bcs_.iw,name,format);
  ind=bosNcreate(bcs_.iw,name,num,ncol,nrow);
E 56
I 56
D 63
  bosLctl(bcs_.iw,(char*)"E+",(char*)name);
  bosNformat(bcs_.iw,(char*)name,(char*)format);
  ind=bosNcreate(bcs_.iw,(char*)name,num,ncol,nrow);
E 63
I 63
  strcpy(temp,"E+");
  strcpy(temp2,name);
  strcpy(temp3,format);
E 63
E 56

I 63
  bosLctl(bcs_.iw,temp,temp2);
  bosNformat(bcs_.iw,temp2,temp3);
  ind=bosNcreate(bcs_.iw,temp2,num,ncol,nrow);

E 63
  va_start(ap,ndata);
  for(i=0; i<ndata; i++) bcs_.iw[ind+i]=va_arg(ap,int);
D 67
  va_end(arg);
E 67

I 67
  /*sergey: do you mean 'ap' ??
  va_end(arg);*/
  va_end(ap);

E 67
  return;
}


//----------------------------------------------------------------


D 38
void add_bank(char *name, int num, char *format, int ncol, int nrow, int ndata, int data[]){
E 38
I 38
D 56
void add_bank(char *name, int num, char *format, int ncol, int nrow, int ndata, int data[]) {
E 56
I 56
D 66
void add_bank(const char *name, int num, const char *format, int ncol, int nrow, int ndata, int data[]) {
E 56
E 38


E 66
I 66
void
add_bank(const char *name, int num, const char *format, int ncol, int nrow, int ndata, int data[])
{
E 66
  int i,ind;
D 63
  int namelen=strlen(name);
  int fmtlen=strlen(format);
E 63

D 56
  bosLctl(bcs_.iw,"E+",name);
  bosNformat(bcs_.iw,name,format);
  ind=bosNcreate(bcs_.iw,name,num,ncol,nrow);
E 56
I 56
D 63
  bosLctl(bcs_.iw,(char*)"E+",(char*)name);
  bosNformat(bcs_.iw,(char*)name,(char*)format);
  ind=bosNcreate(bcs_.iw,(char*)name,num,ncol,nrow);
E 63
I 63
  strcpy(temp,"E+");
  strcpy(temp2,name);
  strcpy(temp3,format);
E 63
E 56

I 63
  bosLctl(bcs_.iw,temp,temp2);
  bosNformat(bcs_.iw,temp2,temp3);
  ind=bosNcreate(bcs_.iw,temp2,num,ncol,nrow);

E 63
  for(i=0; i<ndata; i++) bcs_.iw[ind+i]=data[i];

  return;
}

I 63

//----------------------------------------------------------------


D 66
int str2int(const char *s) {

E 66
I 66
int
str2int(const char *s)
{
E 66
  int i,val=0;

  for(i=0; i<4; i++) {
    val|=s[i]<<((3-i)*8);
  }

  return(val);
}

E 63

//----------------------------------------------------------------

E 37

E 1
