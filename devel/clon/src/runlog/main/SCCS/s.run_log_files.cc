h48351
s 00131/00094/00317
d D 1.37 09/06/08 10:45:29 boiarino 38 37
c *** empty log message ***
e
s 00018/00009/00393
d D 1.36 09/05/29 12:33:33 boiarino 37 36
c *** empty log message ***
e
s 00003/00003/00399
d D 1.35 01/01/03 11:13:39 wolin 36 35
c is_open()
e
s 00021/00021/00381
d D 1.34 00/10/27 09:42:16 wolin 35 34
c const
e
s 00004/00004/00398
d D 1.33 00/09/18 13:18:59 wolin 34 33
c Forgot to annotate run_file if no files
e
s 00013/00004/00389
d D 1.32 00/09/13 14:52:38 wolin 33 32
c Bombproof against bad files
e
s 00001/00001/00392
d D 1.31 00/09/08 13:16:08 wolin 32 31
c Typo
e
s 00007/00007/00386
d D 1.30 00/09/08 13:14:17 wolin 31 30
c New clon_root
e
s 00012/00009/00381
d D 1.29 99/09/23 10:04:17 clasrun 30 29
c Now checks current run in recovery mode
c 
e
s 00002/00004/00388
d D 1.28 99/01/11 15:34:00 wolin 29 28
c Fixed info_server msg
c 
e
s 00004/00004/00388
d D 1.27 98/07/23 12:26:57 wolin 28 27
c Always tag file
c 
e
s 00012/00015/00380
d D 1.26 98/07/23 12:00:27 wolin 27 26
c Using BOR instead of file age
c 
e
s 00030/00003/00365
d D 1.25 98/07/23 11:40:55 wolin 26 25
c Ignores files less than min_file_age hours old
c 
e
s 00008/00003/00360
d D 1.24 98/04/20 17:30:32 wolin 25 24
c Added env RUN_NUMBER
c 
e
s 00004/00004/00359
d D 1.23 98/03/18 15:39:38 wolin 24 23
c nlong in kwords
c 
e
s 00007/00003/00356
d D 1.22 98/03/11 17:14:02 wolin 23 22
c More bombproofing
c 
e
s 00018/00016/00341
d D 1.21 98/03/11 17:10:35 wolin 22 21
c Minor ordering inefficiency in process_message...is it related to bus error?
c 
e
s 00009/00001/00348
d D 1.20 98/03/09 12:29:07 wolin 21 20
c Bombproofed CLON_ROOT
c 
e
s 00002/00002/00347
d D 1.19 98/03/02 14:47:32 wolin 20 19
c Better file doc
c 
e
s 00009/00005/00340
d D 1.18 98/02/19 10:23:12 wolin 19 18
c Minor mods
c 
e
s 00069/00017/00276
d D 1.17 98/01/19 16:22:06 wolin 18 17
c Now using CLON_ROOT
c 
e
s 00000/00016/00293
d D 1.16 97/10/27 17:35:37 wolin 17 16
c Ready for production, I hope...
c 
e
s 00029/00033/00280
d D 1.15 97/09/23 12:22:52 wolin 16 15
c Typo
c 
e
s 00006/00002/00307
d D 1.14 97/09/23 11:50:09 wolin 15 14
c Now can handle both old and new ER file formats
c 
e
s 00017/00010/00292
d D 1.13 97/06/24 09:23:44 wolin 14 13
c Numerous minor improvements
e
s 00012/00008/00290
d D 1.12 97/06/20 15:25:04 wolin 13 12
c More improvements to recovery scheme
e
s 00044/00011/00254
d D 1.11 97/06/20 13:52:03 wolin 12 11
c Improved recovery scheme
e
s 00099/00049/00166
d D 1.10 97/06/19 14:13:20 wolin 11 10
c Added recovery mode
e
s 00055/00058/00160
d D 1.9 97/06/13 12:45:07 wolin 10 9
c Reads ER file, added debug mode
e
s 00001/00001/00217
d D 1.8 97/06/06 17:35:17 wolin 9 8
c Typo
e
s 00021/00019/00197
d D 1.7 97/06/06 17:33:14 wolin 8 7
c Now gets run number from msql
e
s 00101/00069/00115
d D 1.6 97/06/06 16:47:47 wolin 7 6
c Major revision to use new ER run file info scheme
e
s 00003/00003/00181
d D 1.5 97/05/06 11:40:16 wolin 6 5
c Updated documentation
e
s 00010/00003/00174
d D 1.4 97/03/25 12:36:48 wolin 5 4
c Got rid of message type numbers
e
s 00006/00016/00171
d D 1.3 97/03/12 09:19:20 wolin 4 3
c Added nerror
e
s 00006/00003/00181
d D 1.2 97/03/11 17:00:34 wolin 3 1
c Minor improvements
e
s 00000/00000/00000
d R 1.2 97/03/11 16:37:16 Codemgr 2 1
c SunPro Code Manager data about conflicts, renames, etc...
c Name history : 2 1 run_log/s/run_log_files.cc
c Name history : 1 0 s/run_log_files.cc
e
s 00184/00000/00000
d D 1.1 97/03/11 16:37:15 wolin 1 0
c Makes entry in run_log_files database
e
u
U
f e 0
t
T
I 11
//
E 11
I 1
D 7
//
E 7
//  run_log_files
//
D 7
//  Sends run_log_file message to dbrouter using GMD
E 7
I 7
//  Reads run file summary (generated by ER at end transition) and enters 
D 18
//   file info into database
E 18
I 18
//   file info into database 
//  Also generates info_server message
E 18
E 7
//
I 7
D 18
//  Expects file name of the form:  runfile_clasrun_000123.txt
E 18
I 18
//
I 38
// Usage: run_log_files -a clasprod (from rcscript)
//        run_log_files -a clasprod -s clasprod -debug *.txt (if recovering and debugging)
//        cd $CLON_PARMS/run_files; run_log_files -a clasprod -s clasprod -debug runfile_clasprod_060067.txt
//        run_log_files -a clasprod -s clasprod *.txt (if recovering)
//
//
E 38
D 24
 //  Expects file name of the form:  runfile_clasrun_000123.txt
E 24
I 24
//  Expects file name of the form:  runfile_clasrun_000123.txt
E 24
E 18
I 12
//  Tags file when done processing
E 12
E 7
D 4
// still to do:  
//    Add nerror
E 4
//
I 11
//  In recovery mode, enters info from list of file names on command line
I 12
D 26
//  Ignores file if already processed
E 26
I 26
//    Ignores file if already processed
//    Ignores file if less than 5 hours old
I 38
//    NOTE: only 'clasprod' files will be processed, the rest will be ignored
E 38
E 26
E 12
E 11
I 7
//
I 15
D 17
//  still to do:
//     new ER file format
E 17
//
D 17
//
E 17
E 15
E 7
D 8
//  Usage:
//
D 7
//   run_log_files [-a application] [-d destination] [-t timeout] 
//                       run location filename nlong nevent nerror
E 7
I 7
//   run_log_files [-a application] [-d destination] [-t timeout] [-s session] [-dir dir] run_number
E 7
//
I 3
//
E 8
E 3
D 7
//  Note:  required args MUST come after optional args
//         default application     = "clastest"
//         default destination     = "dbrouter"
//
//
D 6
//  To link:
//      rtlink -cxx -g -o run_log_files run_log_files.cc
E 6
I 6
//  Note...currently stores:
//     run, file location, file name, nlong, nevent, nerror
E 6
//
//
D 6
//  ejw, 11-mar-97
E 6
I 6
//  ejw, 6-may-97
E 7
I 7
D 11
//  ejw, 6-jun-97
E 11
I 11
D 18
//  ejw, 19-jun-97
E 18
I 18
//  ejw, 19-jan-98
I 38
//   Sergey Boyarinov: fix problems, works again June 2009
//
E 38
E 18
E 11
E 7
E 6


I 12
// for posix
#define _POSIX_SOURCE_ 1
#define __EXTENSIONS__
E 12

I 12

I 18
// smartsockets
E 18
E 12
#include <rtworks/cxxipc.hxx>

I 18

// system stuff
I 37

using namespace std;
#include <strstream>

E 37
E 18
D 7
#include <iostream.h>
E 7
I 7
#include <fstream.h>
#include <iomanip.h>
E 7
D 37
#include <strstream.h>
E 37
I 12
#include <sys/time.h>
I 26
D 27
#include <sys/types.h>
#include <sys/stat.h>
E 27
E 26
E 12


D 4
// message variables
E 4
I 4
// misc variables
E 4
D 7
char *uniq_dgrp = "run_log_files";
char *app      	= "clastest";
char *dest     	= "dbrouter";
D 4
int run        	= 0;
char *location 	= NULL;
char *filename 	= NULL;
int nlong      	= 0;
int nevt       	= 0;
int nerr       	= 0;


E 4
int timeout    = 5;    // how long to wait for GMD reply
D 4
int argcount   = 5;    // number of args required (run,loc,name,nlong,nevent)

// misc variables
E 4
I 4
int argcount   = 6;    // number of args required (run,loc,name,nlong,nevent,nerror)
E 4
int dataptr    = 0;
E 7
I 7
D 8
char *uniq_dgrp   = "run_log_files";
char *application = "clastest";
char *dest     	  = "dbrouter";
char *session     = "clasrun";
char *dir         = "/usr/local/clas/parms/run_files";
int timeout       = 5;    // how long to wait for GMD reply
E 8
I 8
D 11
char *uniq_dgrp     = "run_log_files";
char *application   = "clastest";
char *dest     	    = "dbrouter";
char *msql_database = "clasrun";
char *session       =  getenv("DD_NAME");
char *dir           = "/usr/local/clas/parms/run_files";
int timeout         = 5;    // how long to wait for GMD reply
E 8
int run;
E 7
I 4
D 10

E 10
I 10
int debug           = 0;
E 10
E 4
char comma     = ',';
char quote     = '\'';
D 4
char *preamble = "insert into ingres.run_log_files (run,location,filename,nlong,nevent) "
E 4
I 4
char *preamble = "insert into ingres.run_log_files (run,location,filename,nlong,nevent,nerror) "
E 4
                 "values (";
E 11
I 11
D 35
static char *uniq_dgrp     = "run_log_files";
static char *application   = "clastest";
static char *dest          = "dbrouter";
static char *msql_database = "clasrun";
E 35
I 35
static char *uniq_dgrp     = (char*)"run_log_files";
static char *application   = (char*)"clastest";
static char *dest          = (char*)"dbrouter";
static char *msql_database = (char*)"clasrun";
E 35
D 38
static char *session       =  getenv("DD_NAME");
I 21
D 31
static char *clon_root     =  getenv("CLON_ROOT");
E 31
I 31
static char *clon_parms    =  getenv("CLON_PARMS");
E 31
I 25
static char *envrun        =  getenv("RUN_NUMBER");
E 38
I 38
static char *session       = "";
static char *clon_parms    = "";
E 38
E 25
E 21
D 18
static char *dir           = "/usr/local/clas/parms/run_files";
E 18
I 18
D 31
static char *dir           = "parms/run_files";
E 31
I 31
D 35
static char *dir           = "run_files";
E 35
I 35
static char *dir           = (char*)"run_files";
E 35
E 31
E 18
static int timeout         = 5;    // how long to wait for GMD reply
static int run;
I 30
static int current_run;
E 30
static int debug           = 0;
I 18
static int no_dbr          = 0;
static int no_info         = 0;
E 18
static int filep           = 0;
I 14
static int force           = 0;
I 26
static int min_file_age    = 5;   // hours
E 26
E 14
static char comma          = ',';
static char quote          = '\'';
D 12
static char *preamble      = "insert into ingres.run_log_files (run,session,location,filename,nlong,"
                             "nevent,nerror) values (";
E 12
I 12
D 35
static char *preamble      = "insert into ingres.run_log_files(run,session_name,location,filename,"
E 35
I 35
D 37
static char *preamble      = (char*)"insert into ingres.run_log_files(run,session_name,location,filename,"
E 37
I 37
static char *preamble      = (char*)"insert into run_log_files(run,session_name,location,filename,"
E 37
E 35
                             "nlong,nevent,nerror) values (";
static time_t now          = time(NULL);
static char line[200];
E 12
E 11
D 7
strstream sqlstring;
E 7


// prototypes
void decode_command_line(int argc, char **argv);
I 11
D 14
void process_file(ifstream &file, int run, char *session);
E 14
I 14
D 35
int process_file(ifstream &file, int run, char *session);
E 35
I 35
int process_file(ifstream &file, int run, const char *session);
E 35
I 18
void insert_into_ipc(void);
E 18
E 14
I 12
D 35
int find_tag_line(ifstream &file, char *tag, char buffer[], int buflen);
E 35
I 35
int find_tag_line(ifstream &file, const char *tag, char buffer[], int buflen);
E 35
E 12
E 11
I 7
int get_next_line(ifstream &file, char buffer[], int buflen);
E 7
I 5
extern "C"{
I 8
D 35
int get_run_number(char *msql_database, char *session);
E 8
D 7
int init_msg_types(void);
E 7
I 7
int dbr_init(char *uniq_dgrp, char *application, char *id_string);
E 35
I 35
int get_run_number(const char *msql_database, const char *session);
int dbr_init(const char *uniq_dgrp, const char *application, const char *id_string);
E 35
int dbr_check(float timeout);
int dbr_close(void);
D 17
int insert_msg(char *name, char *facility, char *process, char *msgclass, 
	       int severity, char *status, int code, char *text);
E 17
E 7
}
E 5

// ref to server (connection created later)
TipcSrv &server=TipcSrv::Instance();


//----------------------------------------------------------------------


D 38
int main(int argc, char **argv)
E 38
I 38
int
main(int argc, char **argv)
E 38
{

  T_OPTION opt;
I 7
D 11
  strstream filename,temp;
  char line[200];
E 11
I 11
D 17
  strstream temp;
E 17
E 11
  int status;
I 12
  char fsession[50];
E 12
D 11
  int nlong, nevent, nerror;
  char loc[80], fname[80];
E 11
E 7


I 19
  // synch with c i/o
  ios::sync_with_stdio();


E 19
  // decode command line (dataptr = pointer to first data field on command line)
  decode_command_line(argc,argv);

D 7
  // read Smartsockets license file
  TutCommandParseStdLicense();
E 7
D 38

E 38
I 18
  // no info_server if in recovery mode
D 38
  if(filep!=0)no_info=1;
E 38
I 38
  if(filep!=0) no_info=1;
E 38

D 38

E 38
E 18
I 8
  // set session name if not specified via env variable or on command line
D 35
  if(session==NULL)session="clasprod";
E 35
I 35
D 38
  if(session==NULL)session=(char*)"clasprod";
E 38
I 38
  if(session==NULL) session=(char*)"clasprod";
E 38
E 35

I 38
  // get clon_parms
  clon_parms = getenv("CLON_PARMS");
E 38

I 21
D 31
  // bombproof clon_root
  if(clon_root==NULL) {
    cerr << "clon_root NOT defined!...using /usr/local/clas" << endl;
    clon_root="/usr/local/clas";
E 31
I 31
D 38
  // bombproof clon_parms
D 32
  if(clon_PARMS==NULL) {
E 32
I 32
  if(clon_parms==NULL) {
E 32
    cerr << "clon_parms NOT defined!...using /usr/local/clas/parms" << endl;
D 35
    clon_parms="/usr/local/clas/parms";
E 35
I 35
    clon_parms=(char*)"/usr/local/clas/parms";
E 35
E 31
  }


E 38
E 21
I 11
D 19
  // get run number
  run=get_run_number(msql_database,session);


E 19
E 11
E 8
D 7
  // set application
  opt=TutOptionLookup("Application");
  if(!TutOptionSetEnum(opt,app)){cerr << "?unable to set application" << endl;}
E 7
I 7
D 17
  // post startup message
  temp << "Process startup:       run_log_files " << ends;
  status=insert_msg("run_log_files","online","run_log_files","status",0,"START",0,temp.str());
E 7

D 7
  // set unique datagroup
  opt=TutOptionLookup("Unique_Datagroup");
  if(!TutOptionSetEnum(opt,uniq_dgrp)){cerr << "?unable to set unique datagroup" << endl;}
E 7

E 17
  // disable GMD timeout
D 35
  opt=TutOptionLookup("Server_Delivery_Timeout");
E 35
I 35
  opt=TutOptionLookup((T_STR)"Server_Delivery_Timeout");
E 35
  if(!TutOptionSetNum(opt,0.0)){cerr << "?unable to set GMD timeout" << endl;}

I 5
D 7
  // create message types
  init_msg_types();
E 7

E 5
D 7
  // connect to server 
  server.Create(T_IPC_SRV_CONN_FULL);
E 7
I 7
  // init ipc
D 10
  dbr_init(uniq_dgrp,application,"run log files");
E 10
I 10
  if(debug==0)dbr_init(uniq_dgrp,application,"run log files");
E 10
E 7

D 5
  // create dbr_request mt and msg objects
  TipcMt mt("dbr_request",2,"verbose");
  TipcMsg message(2,dest,uniq_dgrp);
E 5
I 5
D 7
  // create dbr_request msg object
  TipcMsg message("dbr_request");
  message.Sender(uniq_dgrp);
  message.Dest(dest);
E 7
I 7

I 8
D 11
  // get run number
  run=get_run_number(msql_database,session);
E 11
D 19

E 19
I 11
  // normal mode...process 1 file for the current run
D 38
  if(filep==0){
E 38
I 38
  if(filep==0)
  {
    // get most recent run number from database
    run=get_run_number(msql_database,session);
E 38
E 11

I 25
D 38
    // get run number from env var if it exists, otherwise try msql
    if(envrun!=NULL) {
      run=atoi(envrun);
    } else {
      cerr << "?No RUN_NUMBER env var...using msql" << endl;
      run=get_run_number(msql_database,session);
    }
E 25
I 19

D 25
    // get run number
    run=get_run_number(msql_database,session);
E 25

E 38
D 25

E 25
E 19
E 8
D 11
  // form filename and open file
  filename << dir << "/" << "runfile_" << session << "_" 
       << setw(6) << setfill('0') << run << ".txt" << ends;
  ifstream file(filename.str());
  if(file.bad()){
    cerr << "unable to open file" << endl;
    exit(EXIT_FAILURE);
E 11
I 11
D 12
    // form filename and open file
E 12
I 12
    // form filename and open file for reading
E 12
    strstream filename;
D 18
    filename << dir << "/" << "runfile_" << session << "_" 
E 18
I 18
D 21
    filename << getenv("CLON_ROOT") << "/" << dir << "/" << "runfile_" << session << "_" 
E 21
I 21
D 31
    filename << clon_root << "/" << dir << "/" << "runfile_" << session << "_" 
E 31
I 31
    filename << clon_parms<< "/" << dir << "/" << "runfile_" << session << "_" 
E 31
E 21
E 18
	     << setw(6) << setfill('0') << run << ".txt" << ends;
    ifstream file(filename.str());
D 36
    if(file.bad()){
E 36
I 36
D 38
    if(!file.is_open()){
E 38
I 38
    if(!file.is_open())
    {
E 38
E 36
      cerr << "unable to open run file " << filename.str() << endl;
      exit(EXIT_FAILURE);
    }
D 12
    
    // process and close file
E 12
I 12

    // process file and close
E 12
    process_file(file,run,session);
    file.close();
D 12
    
E 12

I 18
D 38

I 37
	
E 38
E 37
E 18
I 12
D 14
    // tag file 
E 14
I 14
D 28
    // tag file if found any file data
E 28
I 28
    // tag file
E 28
E 14
D 13
    ofstream ofile(filename.str(),ios::app);
    ofile << "\n\n*run_log_files*" << endl;
    ofile << "#  Processed in normal mode on " << ctime(&now) << endl;
    ofile.close();
E 13
I 13
D 37
    if(debug==0){
E 37
I 37
    if(debug==0)
    {
E 37
      ofstream ofile(filename.str(),ios::app);
D 23
      ofile << "\n\n*run_log_files*" << endl;
D 20
      ofile << "#  Processed in normal mode on " << ctime(&now) << endl;
E 20
I 20
      ofile << "#  Processed in run_log_files normal mode on " << ctime(&now) << endl;
E 20
      ofile.close();
E 23
I 23
D 36
      if(ofile.bad()) {
E 36
I 36
D 37
      if(!ofile.is_open()) {
E 36
	cerr << "unable to open run file " << filename.str() << " in append mode" << endl;
      } else {
	ofile << "\n\n*run_log_files*" << endl;
	ofile << "#  Processed in run_log_files normal mode on " << ctime(&now) << endl;
	ofile.close();
E 37
I 37
      if(!ofile.is_open())
      {
	    cerr << "unable to open run file " << filename.str() << " in append mode" << endl;
E 37
      }
I 37
      else
      {
	    ofile << "\n\n*run_log_files*" << endl;
	    ofile << "#  Processed in run_log_files normal mode on " << ctime(&now) << endl;
	    ofile.close();
      }
E 37
E 23
    }
I 37
	
E 37
E 13


E 12
D 26
  //  recovery mode...process all files listed on command line
E 26
I 26
  //  recovery mode...process all files listed on command line older than min_file_age
E 26
D 38
  } else {
D 12
    char fsession[50];
E 12
I 12

E 12
    for(int i=filep; i<argc; i++){

E 38
I 38
  }
  else
  {
    for(int i=filep; i<argc; i++)
    {
E 38
I 12
      char *filename = strdup(argv[i]);

I 26

D 27
      // skip file if not old enough
      struct stat buf;
      if(stat(argv[i],&buf)!=0) {
	cerr << "unable to read file stats for " << argv[i] << endl;
	continue;
      }
      if((now-buf.st_mtim.tv_sec)<min_file_age*3600) {
	cout << "skipping file " << argv[i] << " only " << (now-buf.st_mtim.tv_sec)/3600 
	     << " hours old" << endl;
	continue;
      }


E 27
E 26
E 12
      // open file
D 38
      ifstream file(argv[i]);
D 36
      if(file.bad()){
E 36
I 36
      if(!file.is_open()){
E 36
	cerr << "unable to open recovery file " << argv[i] << endl;
	continue;
E 38
I 38
      ifstream file;
      file.open(argv[i]);
      if(!file.is_open())
      {
	    cerr << "unable to open recovery file " << argv[i] << endl;
	    continue;
E 38
      }
I 38
	  else
	  {
        /*cout << "filename " << filename << endl*/;
	  }
E 38

I 27
D 38

E 38
D 30
      // skip file if not old enough
E 30
I 30
      // extract run and session from filename
      char *p = strchr(strstr(filename,"runfile_"),'_')+1;
      *strchr(p,'_')=' ';
      sscanf(p,"%s %d.txt",fsession,&run);

I 38
      if( strncmp(fsession,"clasprod",8) )
	  {
        /*printf("skip session >%s<\n",fsession);*/
        continue;
	  }
      else
	  {
        /*printf("run %d, session >%s<\n",run,fsession)*/;
	  }
E 38

I 38
      // get current run number; it will effectively check if 'fsession' is in database
      current_run = get_run_number(msql_database,fsession);

E 38
      // skip file if current run for this session unless file is old
D 38
      current_run=get_run_number(msql_database,fsession);
E 30
      if(find_tag_line(file,"*BOR*",line,sizeof(line))==0) {
	get_next_line(file,line,sizeof(line));
	int age = atoi(line);
D 30
	if((now-age)<min_file_age*3600) {
	  cout << "skipping file " << argv[i] << " run only " << (now-age)/3600 
E 30
I 30
	if((run==current_run)&&
	   ((now-age)<min_file_age*3600) ) {
	  cout << "skipping file " << argv[i] << " current run file only " << (now-age)/3600 
E 30
	       << " hours old" << endl;
	  continue;
	}
E 38
I 38
      if(find_tag_line(file,"*BOR*",line,sizeof(line))==0)
      {
	    get_next_line(file,line,sizeof(line));
	    int age = atoi(line);
	    if((run==current_run)&&((now-age)<min_file_age*3600) )
        {
	      cout << "skipping file " << argv[i] << " current run file only " << (now-age)/3600 
	        << " hours old" << endl;
	      continue;
	    }
        else
		{
          /*cout << "proceeding: run=" << run << ", current run=" << current_run <<
            ", age=" << age << ", now=" << now << endl*/;
		}
E 38
      }

E 27
I 26

E 26
I 12
D 14
      // check if processed already
      if(find_tag_line(file,"*run_log_files*",line,sizeof(line))==0){
E 14
I 14
      // don't process if already processed, unless forced
D 38
      if((force==0)&&(find_tag_line(file,"*run_log_files*",line,sizeof(line))==0)){
E 14
	file.close();
	continue;
E 38
I 38
      if((force==0)&&
          (find_tag_line(file,"*run_log_files*",line,sizeof(line))==0))
      {
        cout << "skip: already processed" << endl;
	    file.close();
	    continue;
E 38
      }

I 26

I 38
	  /*Sergey: close and reopen again, seekg in 'process_file' does not work for some reason*/
	  file.close();
      file.open(argv[i]);


E 38
E 26
E 12
D 30
      // extract run and session from filename
D 12
      char *p = strchr(strstr(argv[i],"runfile_"),'_')+1;
E 12
I 12
      char *p = strchr(strstr(filename,"runfile_"),'_')+1;
E 12
      *strchr(p,'_')=' ';
      sscanf(p,"%s %d.txt",fsession,&run);

I 26

E 30
E 26
D 12
      // process and close file
E 12
I 12
      // process file and close
I 38
      cout << "processing file " << argv[i] << ", run number " << run << endl;
E 38
E 12
D 14
      process_file(file,run,fsession);
E 14
I 14
D 28
      status=process_file(file,run,fsession);
E 28
I 28
D 33
      process_file(file,run,fsession);
E 33
I 33
      status=process_file(file,run,fsession);
E 33
E 28
E 14
      file.close();

I 26

E 26
D 12
    }    
E 12
I 12
D 28
      // tag file 
D 13
      ofstream ofile(argv[i],ios::app);
      ofile << "\n\n*run_log_files*" << endl;
      ofile << "#  Processed in recovery mode on " << ctime(&now) << endl;
      ofile.close();
E 13
I 13
D 14
      if(debug==0){
E 14
I 14
      if((status==0)&&(debug==0)){
E 28
I 28
D 38
      // tag file
D 33
      if(debug==0) {
E 33
I 33
      if((debug==0)&&(status==1)) {
E 33
E 28
E 14
	ofstream ofile(argv[i],ios::app);
	ofile << "\n\n*run_log_files*" << endl;
D 20
	ofile << "#  Processed in recovery mode on " << ctime(&now) << endl;
E 20
I 20
	ofile << "#  Processed in run_log_files recovery mode on " << ctime(&now) << endl;
E 20
	ofile.close();
E 38
I 38
      // tag file as processed
      if((debug==0)&&(status==1))
      {
	    ofstream ofile(argv[i],ios::app);
	    ofile << "\n\n*run_log_files*" << endl;
	    ofile << "#  Processed in run_log_files recovery mode on " << ctime(&now) << endl;
	    ofile.close();
E 38
      }
E 13

    }
E 12
E 11
  }
I 11


  // wait for GMD acknowledgements
D 38
  if(debug==0)dbr_check((float)timeout);
E 38
I 38
  if(debug==0) dbr_check((float)timeout);
E 38


  // close connection
  if(debug==0)dbr_close();
E 11
E 7
E 5
  
I 11

D 17
  // post shutdown message
  temp << "Process shutdown:       run_log_files " << ends;
  status=insert_msg("run_log_files","online","run_log_files","status",0,"STOP",0,temp.str());


E 17
  // done
  exit(EXIT_SUCCESS);
}


//----------------------------------------------------------------------


D 14
void process_file(ifstream &file, int run, char *session){
E 14
I 14
D 35
int process_file(ifstream &file, int run, char *session){
E 35
I 35
D 38
int process_file(ifstream &file, int run, const char *session){
E 35
E 14

E 38
I 38
int
process_file(ifstream &file, int run, const char *session)
{
E 38
I 14
D 33
  int status=1;             // no data
E 33
I 33
D 34
  int status=0;
E 34
I 34
  int sendmsg=0;
E 34
E 33
E 14
  int nlong, nevent, nerror;
  char loc[80], fname[80];
D 12
  char line[200];
E 12
E 11
D 3
  // set sender, destination, userprop, delivery mode, etc.
E 3
I 3
D 7
  // set delivery mode, userprop
  message.DeliveryMode(T_IPC_DELIVERY_ALL);     // for GMD
E 3
  message.UserProp(0);
E 7
I 7
D 18
  
E 18
I 18
  TipcMsg *info;
E 18
I 11

I 38
  // search for FILES tag...start at beginning if not there (NOTE: old files don't have the tag)
  if(find_tag_line(file,"*FILES*",line,sizeof(line))!=0)
  {
    file.seekg(0,ios::beg);
    if(find_tag_line(file,"*FILES*",line,sizeof(line))!=0)
	{
      cout << "Cannot find *FILES*, or 'seekg' does not work - return" << endl;
      return(0);
	}
  }
E 38
I 18

E 18
I 12
D 15
  // rewind file
  file.seekg(0,ios::beg);
E 15
I 15
D 38
  // search for FILES tag...start at beginning if not there (n.b. old files don't have the tag)
  if(find_tag_line(file,"*FILES*",line,sizeof(line))!=0)file.seekg(0,ios::beg);
E 15

I 22

E 38
E 22
I 18
  // just send 1 info_server message
D 38
  if((debug==0)&&(no_info==0)) {
E 38
I 38
  if((debug==0)&&(no_info==0))
  {
E 38
D 35
    info = new TipcMsg("info_server");
E 35
I 35
    info = new TipcMsg((T_STR)"info_server");
E 35
    info->Sender(uniq_dgrp);
D 29
    info->Dest("info_server");
    info->DeliveryMode(T_IPC_DELIVERY_BEST_EFFORT);
    info->UserProp(0);
    *info << (T_INT4) run << session;
E 29
I 29
D 35
    info->Dest("info_server/in/run_log_files");
    *info << "run_log_files" << (T_INT4) run << session;
E 35
I 35
    info->Dest((T_STR)"info_server/in/run_log_files");
    *info << (T_STR)"run_log_files" << (T_INT4) run << (T_STR)session;
E 35
E 29
  }

D 38

E 38
E 18
E 12
E 11
D 16
  // loop over all entries in file
  while(!file.eof()){
E 16
I 16
D 22
  // loop over all entries
E 22
I 22
  // loop over all entries, send dbr message for each
E 22
D 38
  while(get_next_line(file,line,sizeof(line))==0) {
D 33
    status=0;
E 33
I 33

E 38
I 38
  while(get_next_line(file,line,sizeof(line))==0)
  {
E 38
    // debug...bomb if bad string
D 38
    if(line[0]!='/') {
E 38
I 38
    if(line[0]!='/')
    {
E 38
      cout << "?illegal line in rlf run " << run << endl;
      if((debug==0)&&(no_info==0)) delete info;
      return(0);
    }

    // ok
D 34
    status=1;
E 34
E 33
    sscanf(line,"%s %s %d %d %d",loc,fname,&nlong,&nevent,&nerror);
E 16
D 38
    
E 38
I 38

E 38
D 14
    // read and decode line
E 14
I 14
D 16
    // found file entry...set status and process
E 14
    if(get_next_line(file,line,sizeof(line))==0){
I 14
      status=0;
E 14
      sscanf(line,"%s %s %d %d %d",loc,fname,&nlong,&nevent,&nerror);
E 16
I 16
D 24
    // form sql string (fields:  run,session,'location','file',nlong,nevent,nerror)
E 24
I 24
    // form sql string
I 34
    sendmsg=1;
E 34
E 24
    strstream sqlstring;
    sqlstring << preamble
	      << run << comma 
	      << quote << session << quote << comma                
	      << quote << loc << quote << comma                
	      << quote << fname << quote << comma
D 24
	      << nlong << comma 
E 24
I 24
	      << nlong/1024 << comma 
E 24
	      << nevent << comma 
D 35
	      << nerror << ")" << ends;
E 35
I 35
	      << nerror << (T_STR)")" << ends;
E 35
I 22
D 38

E 22
E 16
    
D 10
      // create dbr_request msg object
      TipcMsg message("dbr_request");
      message.Sender(uniq_dgrp);
      message.Dest(dest);
      message.DeliveryMode(T_IPC_DELIVERY_ALL);     // for GMD
      message.UserProp(0);
      
E 10
D 11
      // form sql string (fields:  run,'location','file',nlong,nevent,nerror)
E 11
I 11
D 16
      // form sql string (fields:  run,session,'location','file',nlong,nevent,nerror)
E 11
      strstream sqlstring;
      sqlstring << preamble
		<< run << comma 
I 11
		<< quote << session << quote << comma                
E 11
		<< quote << loc << quote << comma                
		<< quote << fname << quote << comma
		<< nlong << comma 
		<< nevent << comma 
		<< nerror << ")" << ends;
      
D 10
      // form dbr_request message
      message << (T_INT4) 1 << sqlstring.str();
      
      // send, flush, and destroy message
      server.Send(message);
      server.Flush();
    
    }
E 10
I 10
      // create, send, and flush dbrouter message if not in debug mode
      if(debug==0){
	TipcMsg message("dbr_request");
	message.Sender(uniq_dgrp);
	message.Dest(dest);
	message.DeliveryMode(T_IPC_DELIVERY_ALL);     // for GMD
	message.UserProp(0);
	message << (T_INT4) 1 << sqlstring.str();
	server.Send(message);
	server.Flush();
      }
E 10
E 7
D 3
  message.DeliveryMode(T_IPC_DELIVERY_ALL);
E 3

D 3
  // create sql string and append message (run,'location','file',nlong,nevent,nerror)
E 3
I 3
D 7
  // form sql string (fields:  run,'location','file',nlong,nevent,nerror)
E 3
  sqlstring << preamble
	    << argv[dataptr]   << comma 
	    << quote << argv[dataptr+1] << quote << comma                
	    << quote << argv[dataptr+2] << quote << comma
	    << argv[dataptr+3] << comma 
D 4
	    << argv[dataptr+4] << ")";
E 4
I 4
	    << argv[dataptr+4] << comma 
	    << argv[dataptr+5] << ")";
E 4
I 3

  // form dbr_request message
E 3
  message << (T_INT4) 1 << sqlstring.str();

  // send, flush, and destroy message
  server.Send(message);
  server.Flush();
  message.Destroy();

E 7
I 7
D 10
  }    
E 10
I 10
      // dump string if in debug mode
      if(debug==1){
	cout << endl << sqlstring.str() << endl << endl;
      }
E 16
I 16
D 18
    // create, send, and flush dbrouter message if not in debug mode
    if(debug==0){
      TipcMsg message("dbr_request");
      message.Sender(uniq_dgrp);
      message.Dest(dest);
      message.DeliveryMode(T_IPC_DELIVERY_ALL);     // for GMD
      message.UserProp(0);
      message << (T_INT4) 1 << sqlstring.str();
      server.Send(message);
E 18
I 18
D 22
    // ipc messages
E 22
I 22
    // dump string if in debug mode
    if(debug==1){
      cout << endl << sqlstring.str() << endl << endl;
    }

E 38
  
    // send ipc messages
E 22
D 38
    // n.b.  send many dbr messages, but only 1 info_server message
    if(debug==0) {

      if(no_dbr==0) {
D 35
	TipcMsg dbr("dbr_request");
E 35
I 35
	TipcMsg dbr((T_STR)"dbr_request");
E 35
	dbr.Sender(uniq_dgrp);
	dbr.Dest(dest);
	dbr.DeliveryMode(T_IPC_DELIVERY_ALL);     // for GMD
	dbr.UserProp(0);
	dbr << (T_INT4) 1 << sqlstring.str();
	server.Send(dbr);
E 38
I 38
    // NOTE: send many dbr messages, but only 1 info_server message
    if(debug==0)
    {
      if(no_dbr==0)
      {
	    TipcMsg dbr((T_STR)"dbr_request");
	    dbr.Sender(uniq_dgrp);
	    dbr.Dest(dest);
	    dbr.DeliveryMode(T_IPC_DELIVERY_ALL);     // for GMD
	    dbr.UserProp(0);
	    dbr << (T_INT4) 1 << sqlstring.str();
	    server.Send(dbr);
E 38
      }
D 22
    
E 22
I 22
      
E 22
D 38
      if(no_info==0) {
D 24
	*info << loc << fname << (T_INT4) nlong << (T_INT4) nevent << (T_INT4) nerror;
E 24
I 24
	*info << loc << fname << (T_INT4) nlong/1024 << (T_INT4) nevent << (T_INT4) nerror;
E 38
I 38
      if(no_info==0)
      {
	    *info << loc << fname << (T_INT4) nlong/1024 << (T_INT4) nevent << (T_INT4) nerror;
E 38
E 24
      }
D 22

E 22
    }
I 38
    else // debug mode - just print
	{
      cout << sqlstring.str() << endl;
	}
E 38

I 22
  }  // loop over each line in file
E 22

D 22
    // done...send and flush messages
    if(debug==0) {
      if(no_info==0) {
	server.Send(*info);
	delete info;
      }
E 18
      server.Flush();
E 16
    }
E 22
I 16
D 18
    
E 18
I 18

D 22

E 18
    // dump string if in debug mode
    if(debug==1){
      cout << endl << sqlstring.str() << endl << endl;
E 22
I 22
  // done...send and flush all messages
D 38
  if(debug==0) {
    if(no_info==0) {
E 38
I 38
  if(debug==0)
  {
    if(no_info==0)
    {
E 38
D 34
      server.Send(*info);
E 34
I 34
      if(sendmsg==1)server.Send(*info);
E 34
      delete info;
E 22
    }
I 22
    server.Flush();
E 22
E 16
  }
E 10
  
I 10
D 11

E 10
  // close file
  file.close();
    
    
E 7
  // wait for GMD acknowledgement
D 7
  server.MainLoop((double)timeout);
E 7
I 7
D 10
  dbr_check((float)timeout);
E 10
I 10
  if(debug==0)dbr_check((float)timeout);
E 10
E 7

I 7

E 7
  // close connection
D 7
  server.Destroy(T_IPC_SRV_CONN_WARM);
E 7
I 7
D 10
  dbr_close();
E 10
I 10
  if(debug==0)dbr_close();
E 10
E 7
  
I 7

  // post shutdown message
  temp << "Process shutdown:       run_log_files " << ends;
  status=insert_msg("run_log_files","online","run_log_files","status",0,"STOP",0,temp.str());


E 7
  // done
  exit(EXIT_SUCCESS);
E 11
I 11
D 14
  return;
E 14
I 14
D 34
  return(status);
E 34
I 34
  return(1);
E 34
E 14
E 11
}


//----------------------------------------------------------------------


D 38
void decode_command_line(int argc, char **argv){

E 38
I 38
void
decode_command_line(int argc, char **argv)
{
E 38
D 35
  char *help = "\nusage:\n\n   run_log_files [-a application] [-d destination] [-t timeout]\n"
E 35
I 35
  const char *help = "\nusage:\n\n   run_log_files [-a application] [-d destination] [-t timeout]\n"
E 35
D 7
    "                 run location filename nlong nevent nerror";
E 7
I 7
D 8
    "          [-s session] [-dir dir] run\n\n";
E 8
I 8
D 9
    "          [-m msql_database] [-s session] [-dir dir] run\n\n";
E 9
I 9
D 10
    "          [-m msql_database] [-s session] [-dir dir]\n\n";
E 10
I 10
D 11
    "          [-m msql_database] [-s session] [-dir dir] [-debug]\n\n";
E 11
I 11
D 14
    "          [-m msql_database] [-s session] [-dir dir] [-debug] [file1 file2 ...]\n\n";
E 14
I 14
D 18
    "          [-m msql_database] [-s session] [-dir dir] [-force] [-debug] [file1 file2 ...]\n\n";
E 18
I 18
D 26
    "          [-m msql_database] [-s session] [-dir dir] [-force] [-no_dbr] [-no_info] [-debug] [file1 file2 ...]\n\n";
E 26
I 26
    "          [-m msql_database] [-s session] [-dir dir] [-force] [-mf min_file_age] \n"
    "          [-no_dbr] [-no_info] [-debug] [file1 file2 ...]\n\n";
E 26
E 18
E 14
E 11
E 10
E 9
E 8
E 7

I 11
D 38

E 38
E 11
  int i=1;
  while(i<argc) {
    if(strncasecmp(argv[i],"-h",2)==0){
      cout << help << endl << endl;
      exit(EXIT_SUCCESS);
D 10

    } else if (strncasecmp(argv[i],"-", 1) != 0){
      break;  // reached msg field

    } else if (argc!=(i+1)) { 
D 7
      if (strncasecmp(argv[i],"-a",2)==0){
	app=strdup(argv[i+1]);
E 7
I 7
      if (strncasecmp(argv[i],"-dir",4)==0){
	dir=strdup(argv[i+1]);
E 7
	i=i+2;
      }
I 7
      else if (strncasecmp(argv[i],"-a",2)==0){
	application=strdup(argv[i+1]);
	i=i+2;
      }
E 7
      else if (strncasecmp(argv[i],"-d",2)==0){
	dest=strdup(argv[i+1]);
	i=i+2;
      }
      else if (strncasecmp(argv[i],"-t",2)==0){
	sscanf(argv[i+1],"%d",&timeout);
	i=i+2;
      }
I 8
      else if (strncasecmp(argv[i],"-m",2)==0){
	msql_database=strdup(argv[i+1]);
	i=i+2;
      }
E 8
I 7
      else if (strncasecmp(argv[i],"-s",2)==0){
	session=strdup(argv[i+1]);
	i=i+2;
      }
E 7
      else if (strncasecmp(argv[i],"-",1)==0) {
	TutWarning("Unknown command line arg: %s\n\n",argv[i]);
	i=i+1;
      }
E 10
    }
I 11
    else if (strncasecmp(argv[i],"-",1)!=0){
      filep=i;
      return;
    }
E 11
D 10
    else {
      cout << help << endl << endl; 
      exit(EXIT_SUCCESS);
    } 
E 10
I 10
    else if (strncasecmp(argv[i],"-dir",4)==0){
      dir=strdup(argv[i+1]);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-debug",6)==0){
      debug=1;
      i=i+1;
    }
I 18
    else if (strncasecmp(argv[i],"-no_dbr",7)==0){
      no_dbr=1;
      i=i+1;
    }
    else if (strncasecmp(argv[i],"-no_info",8)==0){
      no_info=1;
      i=i+1;
    }
E 18
I 14
    else if (strncasecmp(argv[i],"-force",6)==0){
      force=1;
      i=i+1;
    }
I 26
    else if (strncasecmp(argv[i],"-mf",3)==0){
      min_file_age=atoi(argv[i+1]);
      i=i+2;
    }
E 26
E 14
    else if (strncasecmp(argv[i],"-a",2)==0){
      application=strdup(argv[i+1]);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-d",2)==0){
      dest=strdup(argv[i+1]);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-t",2)==0){
      sscanf(argv[i+1],"%d",&timeout);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-m",2)==0){
      msql_database=strdup(argv[i+1]);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-s",2)==0){
      session=strdup(argv[i+1]);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-",1)==0) {
D 35
      TutWarning("Unknown command line arg: %s\n\n",argv[i]);
E 35
I 35
      TutWarning((T_STR)"Unknown command line arg: %s\n\n",argv[i]);
E 35
      i=i+1;
    }
E 10
  }
  
D 8

  // error if no command line args
  if(argc<2){ cout << help << endl << endl; exit(EXIT_SUCCESS);}
  
D 7
  // set pointer to 1st data field on command line
  dataptr=i;
E 7
I 7
  // set run number
  run=atoi(argv[i]);
E 7

E 8
D 7
  // error if not enough data
  if((argc-dataptr)<argcount){ cerr << "\n   ?too few arguments" << endl << endl; exit(EXIT_FAILURE);}

E 7
  return;
}


//----------------------------------------------------------------------


E 1
