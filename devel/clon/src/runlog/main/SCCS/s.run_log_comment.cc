h30453
s 00458/00128/00558
d D 1.43 09/06/03 15:45:23 boiarino 45 44
c *** empty log message ***
e
s 00050/00085/00636
d D 1.42 07/10/29 01:11:51 boiarino 44 43
c migrate from cdev to ca
c 
e
s 00216/00089/00505
d D 1.41 05/12/14 15:52:54 boiarino 43 42
c fix in read_user_data but do not quite understood - see comment
c 
e
s 00100/00100/00494
d D 1.40 00/12/05 17:16:11 wolin 42 41
c New CC
e
s 00000/00000/00594
d D 1.39 00/12/05 16:55:54 wolin 41 40
i 39
c Accepted child's version in workspace "/usr/local/clas/devel/source".
c 
e
s 00002/00002/00592
d D 1.38 00/12/05 15:16:17 wolin 40 38
c torus_current
e
s 00002/00002/00592
d D 1.37.1.1 00/12/05 15:11:33 wolin 39 38
c torus_current
e
s 00004/00003/00590
d D 1.37 99/03/16 15:57:50 wolin 38 37
c Reused dest and it got clobbered!
c 
e
s 00023/00101/00570
d D 1.36 99/03/11 13:19:05 wolin 37 36
c Uses ipcbank2et instead of dd
c 
e
s 00005/00005/00666
d D 1.35 99/01/22 13:31:57 wolin 36 35
c Fixes for info_server
c 
e
s 00041/00026/00630
d D 1.34 99/01/08 13:52:21 wolin 35 34
c More in info_server msg
c 
e
s 00003/00003/00653
d D 1.33 98/04/16 14:46:38 gurjyan 34 33
c corrected the typo, mainly MTIRDBK to MTIRBCK
c and TMIRDBK TMIRBCK
c 
e
s 00002/00002/00654
d D 1.32 98/04/15 14:57:42 wolin 33 32
c Missing comma in run_log_photon
c 
e
s 00004/00001/00652
d D 1.31 98/04/10 22:11:30 gurjyan 32 31
c added new Tcl_SetVar Tag_cur.
c 
e
s 00010/00003/00643
d D 1.30 98/04/10 12:08:04 wolin 31 30
c Added photon stuff
e
s 00001/00001/00645
d D 1.29 98/03/30 17:20:52 wolin 30 29
c Using mini current readback
c 
e
s 00011/00011/00635
d D 1.28 98/03/30 16:32:18 wolin 29 28
c Forgot commas in run_log_photon
c 
e
s 00080/00016/00566
d D 1.27 98/03/30 15:58:03 wolin 28 27
c Added photon stuff...still needs checking...
c 
e
s 00001/00001/00581
d D 1.26 98/03/06 14:14:48 wolin 27 26
c Using 0,0,0,0 for dd ctl words
c 
e
s 00001/00001/00581
d D 1.25 98/02/11 16:44:33 wolin 26 25
c Now doing exit(tk_src_status)
c 
e
s 00002/00001/00580
d D 1.24 98/01/22 09:59:39 wolin 25 24
c Added ignore_run
c 
e
s 00001/00001/00580
d D 1.23 98/01/22 09:52:05 wolin 24 23
c Typo
c 
e
s 00014/00004/00567
d D 1.22 98/01/19 16:33:37 wolin 23 22
c Added mini_raster, CLON_BIN
c 
e
s 00000/00000/00571
d D 1.21 98/01/12 17:46:37 gurjyan 22 21
c *** empty log message ***
e
s 00029/00025/00542
d D 1.20 98/01/12 17:20:03 wolin 21 20
c Minor improvements and cleanup
c 
e
s 00059/00031/00508
d D 1.19 98/01/12 17:08:40 wolin 20 19
c Added info_server message
c 
e
s 00000/00000/00539
d D 1.18 98/01/12 15:17:01 gurjyan 19 18
c by vhg
c 
e
s 00001/00001/00538
d D 1.17 98/01/12 15:15:08 clasrun 18 17
c *** empty log message ***
e
s 00039/00025/00500
d D 1.16 97/12/12 14:54:24 clasrun 17 16
c Vardans new version, many mods
c 
e
s 00002/00002/00523
d D 1.15 97/11/19 09:28:26 wolin 16 15
c New head bank scheme
c 
e
s 00002/00002/00523
d D 1.14 97/11/17 16:12:33 wolin 15 14
c create_header has new args name1,name2
c 
e
s 00105/00001/00420
d D 1.13 97/11/17 15:56:48 wolin 14 13
c Added cdev calls
c 
e
s 00008/00006/00413
d D 1.12 97/10/29 15:18:13 wolin 13 12
c Passing off to Vardan...
c 
e
s 00001/00002/00418
d D 1.11 97/06/18 17:26:56 clasrun 12 11
c Added beamrequest to ingres insert command
e
s 00001/00001/00419
d D 1.10 97/06/13 12:33:03 wolin 11 10
c Typo
e
s 00011/00009/00409
d D 1.9 97/06/03 12:38:06 wolin 10 9
c Updated variable names...still no beamrequest
e
s 00009/00023/00409
d D 1.8 97/05/28 13:41:27 wolin 9 8
c Mostly there, perhaps few remaing fields, no insert_msg
e
s 00006/00001/00426
d D 1.7 97/05/06 11:40:15 wolin 8 7
c Updated documentation
e
s 00045/00088/00382
d D 1.6 97/04/10 17:21:14 wolin 7 6
c Added new database variables, etc.
e
s 00000/00002/00470
d D 1.5 97/04/09 15:51:31 wolin 6 5
c Removed unneeded msql_init(interp)
e
s 00010/00007/00462
d D 1.4 97/03/25 12:48:27 wolin 5 4
c Continued improvements...no more mt numbers, etc
e
s 00015/00017/00454
d D 1.3 97/03/24 12:09:04 wolin 4 3
c Switched to smartsockets c++ api
e
s 00036/00031/00435
d D 1.2 97/03/24 11:10:01 wolin 3 1
c Added DD entry, other minor mods
e
s 00000/00000/00000
d R 1.2 97/03/20 10:43:15 Codemgr 2 1
c SunPro Code Manager data about conflicts, renames, etc...
c Name history : 2 1 run_log/s/run_log_comment.cc
c Name history : 1 0 s/run_log_comment.cc
e
s 00466/00000/00000
d D 1.1 97/03/20 10:43:14 wolin 1 0
c New version also inserts info into DD system
e
u
U
f e 0
t
T
I 1
D 43
//
E 43
//  run_log_comment
//
//  Uses Tk gui to collect run_log_comment info from operator, then
D 35
//    inserts into the database and event stream
//
//
D 20
//  usage:
//     run_log_comment [-a application] [-u uniq_dgrp] [-i id_string] [-debug]
//                     [-d destination] [-t tk_script] [-m msql_database]
//                     [-s session]     [-no_dbr]      [-no_dd]    [-g gmd_time]
//
E 20
//      use -no_dbr to NOT insert data into database
//      use -no_dd  to NOT insert data into DD system
I 20
//      use -no_ipc to NOT send data to info_server
E 20
D 3
//      use -debug to just dump query string to stdout
E 3
I 3
//      use -debug to just dump SQL string to stdout
E 35
I 35
//    inserts into the database, event stream, and info_server
E 35
E 3
//
//
I 45
// Usage: run_log_comment -a clasprod (from rcscript)
//        run_log_comment -a clasprod -s clasprod -debug 59908 (if recovering and debugging)
//        run_log_comment -a clasprod -s clasprod 59908 (if recovering)
//

E 45
D 3
//  ejw, 19-mar-97
E 3
I 3
//   still to do:
I 13
//       new columns
E 13
//       get header ctl words, event class correct
I 5
D 9
//       bombproofing:  no msqld, etc.
E 9
E 5
//
//
D 8
//  ejw, 20-mar-97
E 8
I 8
D 35
//   Note...currently stores:
//      run, time, run type, operators, target, logbook book and page, comment
D 21
//      hv status, beam current request, active sectors
E 21
I 21
//      hv status, beam current request
E 21
//
//
E 35
//  ejw, 6-may-97
I 43
// vardan  Oct. 11 2005 add read file generated rlComment
I 44
// sergey 29-oct-2007 migrate from cdev to ca
E 44
E 43
E 8
E 3


// for posix
#define _POSIX_SOURCE_ 1
#define __EXTENSIONS__


D 3
// db_entry and DD buffer sizes
#define BUFFERSIZE 3000
E 3
I 3
D 37
// sql string and DD buffer sizes
D 7
#define SQLSTRINGSIZE 3000     // characters
#define DDBUFFERSIZE  1000     // longwords
E 7
I 7
#define DDBUFFERSIZE  1200     // longwords
E 7
E 3


E 37
// system stuff
I 44

using namespace std;
#include <strstream>

E 44
#include <iostream.h>
D 7
#include <stdio.h>
#include <sys/types.h>
#include <time.h>
#include <stdarg.h>
#include <strings.h>
#include <stdlib.h>
#include <string.h>
E 7
I 7
D 44
#include <strstream.h>
E 44
E 7
D 4
#include <rtworks/ipc.h>
E 4
I 4
#include <rtworks/cxxipc.hxx>
I 43
#include <fstream.h>
E 43
E 4


// online stuff
extern "C"{
#include <clas_ipc_prototypes.h>
D 37
#include <dd_user.h>
E 37
D 9
#include <msql.h>
E 9
D 45
#include <tcl.h>
#include <tk.h>
E 45
}

D 45

E 45
I 44
#include "epicsutil.h"

E 44
I 17
D 45
// variable for status
D 43
static int tk_src_status;
E 43
I 43
static int tk_src_status = 0;
E 43


I 20
// for tcl
Tcl_Interp *interp;
Tk_Window mainWindow; 


E 45
E 20
E 17
// for record segment header
static int nevnt  = 0;
static int nphys  = 0;
D 13
static int trig   = 0;                // fpack class, 17 for prestart event, 0 for normal event, etc.
E 13
I 13
static int trig   = 0;
E 13


// constants for head bank
static int nvers  = 0;
D 13
static int type   = 1;
E 13
I 13
D 16
static int type   = 0;
E 16
I 16
static int type   = 101;
E 16
E 13
static int rocst  = 0;
D 13
static int evcls  = 0;                // fpack class again?
static int presc  = 1;
E 13
I 13
static int evcls  = 0;
D 16
static int presc  = 100;
E 16
I 16
static int presc  = 0;
E 16
E 13


D 37
// DD event control words
D 27
static int ddctl[4] = {-1,-1,-1,-1};
E 27
I 27
static int ddctl[4] = {0,0,0,0};
E 27


E 37
D 3
// flags to inhibit event recording
static int no_dbr            = 0;
static int no_dd             = 0;
static int debug             = 0;
E 3
I 3
// flags to inhibit event recording, etc.
D 20
static int no_dbr = 0;
static int no_dd  = 0;
static int debug  = 0;
E 20
I 20
static int no_dbr  = 0;
static int no_info = 0;
D 37
static int no_dd   = 0;
E 37
I 37
static int no_data = 0;
E 37
static int debug   = 0;
E 20
E 3


D 38
// parameters resettable on command line
E 38
I 38
// misc vars
E 38
D 42
static char *application    = "clastest";
D 5
static char *uniq_dg        = "run_log_comment";
E 5
I 5
static char *uniq_dgrp      = "run_log_comment";
E 5
static char *id_string      = "run_log_comment";
static char *dest           = "dbrouter";
E 42
I 42
static char *application    = (char*)"clastest";
static char *uniq_dgrp      = (char*)"run_log_comment";
static char *id_string      = (char*)"run_log_comment";
static char *dest           = (char*)"dbrouter";
E 42
D 18
static char *tk_script      = "/usr/local/clas/bin/run_log_comment.tcl";
E 18
I 18
D 23
static char *tk_script      = "/usr/local/clas/work_src/run_log/s/run_log_comment.tcl";
E 23
I 23
D 45
static char *tk_script      = NULL;
D 42
static char *def_tk_script  = "run_log_comment.tcl";
E 23
E 18
static char *msql_database  = "clasrun";
E 42
I 42
static char *def_tk_script  = (char*)"run_log_comment.tcl";
static char *msql_database  = (char*)"clasrun";
E 42
D 37
static char *session        =  getenv("DD_NAME");
E 37
I 37
static char *session        =  NULL;
E 45
I 45
static char *mysql_database  = (char*)"clasrun";
static char session[50]     = "";
E 45
E 37
I 14
D 44
static int cdev_pend_time   =  5;
E 44
E 14
static int gmd_time         =  5;
I 45
static int filep            = 0;
E 45
I 38
static char temp[128];
E 38

I 45
static char *archive_file_name = (char*)"run_log/archive/comment_%s_%06d.txt";
E 45
I 43
char *date = NULL;
char *runtype = NULL;
char *beamcurrent = NULL;
char *raster = NULL;
char *shiftcrue = NULL;
char *comment = NULL;
char *logbook = NULL;
char *page = NULL;
char *target = NULL;
char *tk_b_ener = NULL;
char *tk_t_cur = NULL;
char *tk_mt_cur = NULL;
char *trig_conf = NULL;
char *chan_conf = NULL;
char *l1_mask = NULL;
char *prescale = NULL; 
char *ec_inner_l = NULL; 
char *ec_inner_h = NULL; 
char *ec_outer_l = NULL; 
char *ec_outer_h = NULL; 
char *ec_total_l = NULL; 
char *ec_total_h = NULL; 
char *sc_h = NULL; 
char *cc_h = NULL; 
char *cc_l = NULL; 
char *photon_trig_conf = NULL; 
char *radiator = NULL; 
char *scaler_config1 = NULL; 
char *scaler_config2 = NULL; 
char *scaler_config3 = NULL; 
char *scaler_config4 = NULL;
char *PS_converter = NULL;
char *collimator1 = NULL;   
char *collimator2 = NULL; 
char *PC_converter = NULL;
char *TAC = NULL;
char *RadPhi = NULL;
char *et_coincidence = NULL;
char *tagger_prescaling = NULL;
E 43

I 20
// data variables
I 21
static int run;
E 21
static char *config;
static char entry_date[30]; 



E 20
I 14
D 44
// for cdev
#include <cdev.h>
#include <cdevData.h>
#include <cdevDevice.h>
#include <cdevRequestObject.h>
#include <cdevSystem.h>


// epics channel names, etc.
struct epics_struct {
D 42
  char *name;
  char *chan;
  char *get;
E 42
I 42
  const char *name;
  const char *chan;
  const char *get;
E 44
I 44
static char *epics_name[] = {
  "beam_energy",
  "torus current",
  "mini current",
  "tagger current",
E 44
E 42
};

D 44
static epics_struct epics[] = {
  "beam_energy",          "MBSY2C_energy",             "get",
D 17
  "slit_position",        "SMRPOSB",                   "get",
  "thermionic_gun",       "IGT0I00BIASET",             "get",
  "polarized_gun",        "unknown",                   "get",
  "beam_current",         "IBC2C24AVG",                "get",
E 17
D 39
D 40
  "torus current",	  "hallb_sf_xy560_0_5",        "get",
D 30
  "mini current",	  "MTSETI",                    "get",
E 30
I 30
D 34
  "mini current",	  "MTIRDBK",                    "get",
E 30
I 28
  "tagger current",       "TMIRDBK",                   "get",
E 34
I 34
  "mini current",	  "MTIRBCK",                    "get",
E 39
I 39
  "torus current",	  "torus_current",             "get",
  "mini current",	  "MTIRBCK",                   "get",
E 39
E 40
I 40
  "torus current",	  "torus_current",             "get",
  "mini current",	  "MTIRBCK",                   "get",
E 40
  "tagger current",       "TMIRBCK",                   "get",
E 44
I 44
static char *epics_chan[] = {
  "MBSY2C_energy",
  "torus_current",
  "MTIRBCK",
  "TMIRBCK",
E 44
E 34
E 28
D 17
  "mini voltage",	  "MTVRBCK",                   "get",
  "tagger current",	  "TMSETI",                    "get",
  "tagger voltage",	  "TMVRBCK",                   "get",
  "CC O2 monitor lamp",	  "cc_o2_ref",                 "get",
  "CC O2 monitor gas",	  "cc_o2_sig",                 "get",
  "Upstream beam vacuum", "unknown",                   "get",
  "Target vacuum",	  "unknown",                   "get",
  "cryo pressure",	  "B_cryotarget_pressure",     "get",
  "cryo temperature",	  "B_cryotarget_temperature",  "get",
  "cryo status",	  "B_cryotarget_status",       "get",
E 17
};

D 44
static float      epics_val[sizeof(epics)/sizeof(epics_struct)];
cdevRequestObject      *obj[sizeof(epics)/sizeof(epics_struct)];
cdevCallback            *cb[sizeof(epics)/sizeof(epics_struct)];
static int nepics  = sizeof(epics)/sizeof(epics_struct);
E 44
I 44
static float      epics_val[sizeof(epics_chan)/sizeof(char *)];
static int nepics  = sizeof(epics_chan)/sizeof(char *);
E 44



E 14
// prototypes
void decode_command_line(int argc, char **argv);
D 3
void collect_data(int &run, char *entry);
void insert_into_database(int &run, char *entry);
E 3
I 3
D 7
void collect_data(int &run, char *sql_string);
E 7
I 7
D 21
void collect_data(int &run, strstream &sql_string);
E 21
I 21
D 28
void collect_data(strstream &sql_string);
E 28
I 28
void collect_data(strstream &sql_string, strstream &sql_string2);
I 45
int read_from_file(strstream &sql_string, strstream &sql_string2);
E 45
E 28
E 21
I 14
void get_epics_data(void);
D 44
void epics_callback_func(int status, void *userarg, cdevRequestObject &epics_req_obj,
			    cdevData& result);
E 44
E 14
E 7
D 20
void insert_into_database(char *entry);
E 20
I 20
D 21
void insert_into_ipc(int &run, char *entry);
E 20
E 3
void insert_into_dd(int &run, char *entry);
E 21
I 21
D 28
void insert_into_ipc(char *entry);
void insert_into_dd(char *entry);
E 28
I 28
void insert_into_ipc(char *entry, char *entry2);
D 37
void insert_into_dd(char *entry, char *entry2);
E 37
I 37
void insert_into_data(char *entry, char *entry2);
I 43
int read_user_data(strstream &filename);
I 45
void get_string2(ifstream &file, const char* tag, char *var);
char *env_name(const char *env, const char *name);
E 45
E 43
E 37
E 28
E 21

I 45
void get_string(ifstream &file, const char* tag, char *var);
void get_int(ifstream &file, const char* tag, int array[], int nwd);
void get_long(ifstream &file, const char* tag, unsigned long array[], int nwd);
void get_hex(ifstream &file, const char* tag, unsigned long array[], int nwd);
void get_string3(ifstream &file, const char* tag, char *var);
void get_int2(ifstream &file, const char* tag, int *var);
void get_double2(ifstream &file, const char* tag, double *var);
void convert_date(char *out, char *in);
void double_quotes(char out[], char in[]);
int find_tag_line(ifstream &file, const char* tag, char buffer[], int buflen);
int get_next_line(ifstream &file, char buffer[], int buflen);
char *trim(char *in);


E 45
extern "C" {
D 37
int create_header(int *p, int fevlen, int &banksize,
D 15
		  int nrun, int nevnt, int nphys, int trig);
E 15
I 15
		  int name1, int name2, int nrun, int nevnt, int nphys, int trig);
E 15
int add_bank(int *p2fev, int fevlen, 
      char *name, int num, char *format, int ncol, int nrow, int ndata, int &banksize, int *data);
int va_add_bank(int *p2fev, int fevlen, 
      char *name, int num, char *format, int ncol, int nrow, int ndata, int &banksize, ...);
E 37
I 9
D 42
int get_run_config(char *msql_database, char *session, int *run, char **config);
E 42
I 42
D 45
int get_run_config(const char *msql_database, const char *session, int *run, char **config);
E 45
I 45
int get_run_config(const char *mysql_database, const char *session, int *run, char **config);
E 45
E 42
E 9
D 6
int MSQL_Init(Tcl_Interp *interp);
E 6
}


// program start time
static time_t start=time(NULL);


I 14
D 44
// ref to cdev system object
cdevSystem &cdevsys = cdevSystem::defaultSystem();
E 14

I 14

E 44
E 14
//--------------------------------------------------------------------------
I 45
  // open file in $CLON_PARMS/run_log/archive/comment_<session>_<runnumber>.txt
E 45

I 45
int
main(int argc,char **argv)
{
  int ret;
  strstream sql_string, sql_string2;
E 45

D 45
main(int argc,char **argv){
E 45
I 45
  // decode command line
  decode_command_line(argc,argv);
E 45

D 21
  int nrun=0;
E 21
D 3
  char db_entry[BUFFERSIZE];
E 3
I 3
D 7
  char sql_string[SQLSTRINGSIZE];
E 7
I 7
D 28
  strstream sql_string;
E 28
I 28
D 45
  strstream sql_string,sql_string2;
E 45
I 45
  if(filep==0)
  {
    strstream filename;
    filename << getenv("CLON_PARMS") << "/run_log/current_usr_input.txt" << ends;
    read_user_data(filename);
  }
E 45
E 28
E 7
E 3

I 43
D 45
  // open file in $CLON_PARMS/run_log/archive/comment_'session'_0'runnumber'.txt
 strstream filename;
 filename << getenv("CLON_PARMS") << "/run_log/current_usr_input.txt" << ends;
 read_user_data(filename);
E 43

E 45
I 35
  // synch with stdio
  ios::sync_with_stdio();

I 45
  // no ipc or data in recovery mode
  if(filep!=0)
  {
    no_info=1;
    no_data=1;
  }
E 45

D 44
  // only print cdev error messages
  cdevsys.setThreshold(CDEV_SEVERITY_ERROR);


E 44
E 35
D 45
  // decode command line
  decode_command_line(argc,argv);
E 45
I 45
  // normal mode
  if(filep==0)
  {
    // set session name if not specified via env variable or on command line
    if(strlen(session)==0) strcpy(session,"clasprod");
E 45

I 45
    // collect data (returns 2 sql strings:  standard + optional photon string)
    collect_data(sql_string,sql_string2);
E 45
I 21

E 21
D 3
  // collect data
  collect_data(nrun,db_entry);
E 3
I 3
D 45
  // set session name if not specified via env variable or on command line
D 42
  if(session==NULL)session="clasprod";
E 42
I 42
  if(session==NULL)session=(char*)"clasprod";
E 45
I 45
    // inserts sql strings into data stream as special database event
    if((no_data==0)&&(debug==0))insert_into_data(sql_string.str(),sql_string2.str());
E 45
E 42
E 3

I 45
    // ship data to dbrouter and info server
    if(debug==0)insert_into_ipc(sql_string.str(),sql_string2.str());
  }
  else // recovery mode
  {
    printf("RECOVERY MODE\n");
E 45
I 21

E 21
I 14
D 35
  // only print cdev error messages
  cdevsys.setThreshold(CDEV_SEVERITY_ERROR);

E 14
I 3
D 21
  // collect data (returns run number and sql string)
  collect_data(nrun,sql_string);
E 21

E 35
I 21
D 28
  // collect data (returns sql string)
  collect_data(sql_string);
E 28
I 28
D 45
  // collect data (returns 2 sql strings:  standard + optional photon string)
  collect_data(sql_string,sql_string2);
E 45
I 45
    for(int i=filep; i<argc; i++)
    {
      // read data from text file and create sql strings
      run = atoi(argv[i]);
      printf("Trying to read archive file for run number %d (>%s<)\n",run,argv[i]);
      ret = read_from_file(sql_string,sql_string2);
      if(ret) continue; // did not get anything
E 45
E 28

I 45
      if(debug==0) insert_into_ipc(sql_string.str(),sql_string2.str());
	}
  }
E 45

D 45
  // check abort flag
D 26
  if(tk_src_status<0) exit(EXIT_FAILURE);
E 26
I 26
  if(tk_src_status<0) exit(tk_src_status);
E 26


E 21
E 3
D 5
  // insert into DD system
D 3
  if((no_dd==0)&&(debug==0))insert_into_dd(nrun,db_entry);
E 3
I 3
  if((no_dd==0)&&(debug==0))insert_into_dd(nrun,sql_string);
E 5
I 5
D 28
  // insert sql string into DD system as special database event
D 7
  if((no_dd ==0)&&(debug==0))insert_into_dd(nrun,sql_string);
E 7
I 7
D 17
  if((no_dd ==0)&&(debug==0))insert_into_dd(nrun,sql_string.str());
E 17
I 17
D 21
  if((no_dd==0)&&(debug==0))insert_into_dd(nrun,sql_string.str());
E 21
I 21
  if((no_dd==0)&&(debug==0))insert_into_dd(sql_string.str());
E 28
I 28
D 37
  // inserts sql strings into DD system as special database event
  if((no_dd==0)&&(debug==0))insert_into_dd(sql_string.str(),sql_string2.str());
E 37
I 37
  // inserts sql strings into data stream as special database event
  if((no_data==0)&&(debug==0))insert_into_data(sql_string.str(),sql_string2.str());
E 37
E 28
E 21
E 17
E 7
E 5
E 3

I 21

E 21
D 5
  // insert into database
E 5
I 5
D 20
  // ship sql string to database router
E 5
D 3
  if((no_dbr==0)&&(debug==0))insert_into_database(nrun,db_entry);
E 3
I 3
D 7
  if((no_dbr==0)&&(debug==0))insert_into_database(sql_string);
E 7
I 7
  if((no_dbr==0)&&(debug==0))insert_into_database(sql_string.str());
E 20
I 20
  // ship data to dbrouter and info server
D 21
  if(debug==0)insert_into_ipc(nrun,sql_string.str());
E 21
I 21
D 28
  if(debug==0)insert_into_ipc(sql_string.str());
E 28
I 28
  if(debug==0)insert_into_ipc(sql_string.str(),sql_string2.str());
E 28
E 21
E 20
E 7
E 3

I 21

E 45
E 21
I 3
D 28
  // debug...just print sql string
E 28
I 28
  // debug...just print sql strings
E 28
D 45
  if(debug!=0){
E 45
I 45
  if(debug!=0)
  {
E 45
D 7
    cout << "\nsql string for run " << nrun << " is:\n\n" << sql_string << endl;
E 7
I 7
D 21
    cout << "\nsql string for run " << nrun << " is:\n\n" << sql_string.str() << endl;
E 21
I 21
D 28
    cout << "\nsql string for run " << run << " is:\n\n" << sql_string.str() << endl;
E 28
I 28
    cout << "\nsql string for run " << run << " is:\n\n" << sql_string.str() << endl << endl;
D 42
    if(strncasecmp(Tcl_GetVar(interp,"runtype",0),"photon",6)==0) {
E 42
I 42
D 43
    if(strncasecmp(Tcl_GetVar(interp,(char*)"runtype",0),"photon",6)==0) {
E 43
I 43
D 45
    if(strncasecmp(runtype,"photon",6)==0) {
E 45
I 45
    if(strncasecmp(runtype,"photon",6)==0)
    {
E 45
E 43
E 42
      cout << "\nsql photon string for run " << run << " is:\n\n" << sql_string2.str() << endl;
D 45
    }      
E 45
I 45
    }
E 45
E 28
E 21
E 7
  }

E 3
D 21
  // done
D 17
  exit(EXIT_SUCCESS);
E 17
I 17
       printf("%d\n",tk_src_status);
   if(tk_src_status < 0) exit(EXIT_FAILURE); 
      else exit(EXIT_SUCCESS);
E 21
E 17

I 21
  // done
  exit(EXIT_SUCCESS);
E 21
}
       

//----------------------------------------------------------------

I 43
D 45
int read_user_data(strstream &name) {
E 45
I 45

int
read_from_file(strstream &sql, strstream &sql2)
{
  char entry_date[35];
  char target[25];
  char run_type[25];
  double beam_current_request;
  char mini_raster[20];
  char operators[101];
  int logbook_book;
  int logbook_page;
  char ignore_run[2000];
  char comment[2000];

  char trigger_type[121];
  char radiator[20];
  char scaler1_odd[20];
  char scaler1_even[20];
  char scaler2_odd[20];
  char scaler2_even[20];
  char ps_converter[20];
  char primary_collimator[20];
  char secondary_collimator[20];
  char pair_counter[20];
  char tac[20];
  char radphi[20];
  char et_coincidence[20];
  char tagger_prescaling[35];


  char comma    = ',';
  char prime    = '\'';
  int i;
  char temp[2000];
  char *p1, *p2;



  int ii,ind,flen,ret;
  char *p, date1[30], time1[30];
  char line[4096];
  static char filename[256];


  // read run log archive file
  sprintf(filename,archive_file_name,session,run);
  ifstream file(env_name("CLON_PARMS",filename));
  if(!file.is_open())
  {
    printf("File >%s< does not exist - exit\n",filename);
    return(-1);
  }
  else
  {
    printf("Use file >%s<\n",env_name("CLON_PARMS",filename));
  }

  // read file generated by rlComment


  get_string2(file,"DATE",temp);
  convert_date(entry_date,temp);
  get_string2(file,"RUNTYPE",run_type);
  runtype = strdup(run_type);
  get_string2(file,"TARGET",target);
  get_double2(file,"BEAMREQUEST",&beam_current_request);
  get_string2(file,"MINIRASTER",mini_raster);
  get_string2(file,"OPERATORS",temp);
  double_quotes(operators,temp);
  get_int2(file, "LOG_BOOK", &logbook_book);
  get_int2(file, "LOG_PAGE", &logbook_page);
  get_string(file,"*IGNORE*",ignore_run);
  get_string3(file,"*COMMENT*",temp);
  double_quotes(comment,temp);


  // form sql string
  sql << "insert into run_log_comment (run,session_name,entry_date,run_type,target,"
	 << "beam_current_request," 
	 << "mini_raster,operators,logbook_book,logbook_page,ignore_run,comment) values ("
         << run << comma
	 << prime << trim(session) << prime << comma
	 << prime << trim(entry_date) << prime << comma
	 << prime << trim(run_type) << prime << comma
	 << prime << trim(target) << prime << comma
	 << beam_current_request << comma
	 << prime << trim(mini_raster) << prime << comma
	 << prime << trim(operators) << prime << comma
         << logbook_book << comma
         << logbook_page << comma
     << prime << ignore_run << prime << comma
	 << prime << trim(comment) << prime 
	 << ")" << ends;


  // is this a photon run
  if(strncasecmp(runtype,"photon",6)==0)
  {
    get_string2(file,"Photon Trigger",trigger_type);
    get_string2(file,"Radiator",radiator);
    get_string2(file,"Scaler Gate",temp);
    p1=temp;
    *(p2=strchr(p1,' '))='\0'; strcpy(scaler1_odd,p1);  p1=p2+1;
    *(p2=strchr(p1,' '))='\0'; strcpy(scaler1_even,p1); p1=p2+1;
    *(p2=strchr(p1,' '))='\0'; strcpy(scaler2_odd,p1);  p1=p2+1;
    strcpy(scaler2_even,p1);

    get_string2(file,"PS_convertor",ps_converter);    // typo in comment file!
    get_string2(file,"Collimator1",primary_collimator);
    get_string2(file,"Collimator2",secondary_collimator);
    get_string2(file,"PC",pair_counter);
    get_string2(file,"TAC",tac);
    get_string2(file,"RadPhi",radphi);
    get_string2(file,"ET_coincidence",et_coincidence);
    get_string2(file,"Tagger_prescaling",tagger_prescaling);

    sql2 << "insert into run_log_photon (run,session_name,trigger_type,radiator,"
	   << "scaler1_odd,scaler1_even,scaler2_odd,scaler2_even,ps_converter,"
	   << "primary_collimator,secondary_collimator,pair_counter,tac,radphi,et_coincidence,"
	   << "tagger_prescaling) values ("
	   << run << comma
	   << prime << trim(session) << prime << comma
	   << prime << trim(trigger_type) << prime << comma
	   << prime << trim(radiator) << prime << comma
	   << prime << trim(scaler1_odd) << prime << comma
	   << prime << trim(scaler1_even) << prime << comma
	   << prime << trim(scaler2_odd) << prime << comma
	   << prime << trim(scaler2_even) << prime << comma
	   << prime << trim(ps_converter) << prime << comma
	   << prime << trim(primary_collimator) << prime << comma
	   << prime << trim(secondary_collimator) << prime << comma
	   << prime << trim(pair_counter) << prime << comma
	   << prime << trim(tac) << prime << comma
	   << prime << trim(radphi) << prime << comma
	   << prime << trim(et_coincidence) << prime << comma
	   << prime << trim(tagger_prescaling) << prime
	   << ")" << ends;

  }





  file.close();

  return(0);
}


//--------------------------------------------------------------------------


int
read_user_data(strstream &name)
{
E 45
  
  ifstream file(name.str());
 
  int len;
  char buffer[256];
E 43

I 43
D 45
   if (! file.is_open())
  { cout << "Error opening file"; exit (1); }
E 45
I 45
  if (! file.is_open())
  {
    cout << "Error opening file"; exit (1);
  }
E 45

I 44

   /* Sergey: need something like that 
  while(file.is_open()&&file.good()&&!file.eof()&&!file.fail()&&!file.bad()) {
   */

E 44
  while (! file.eof() )
  {
    file.getline (buffer,100);
    len = strlen(buffer);
    cout << len << " " << buffer << endl;

//Sergey: break loop if received zero length string; if 'comment' longer then 'buffer'
// we are looping forever and end_of_file never shows up ...
if(len <= 0)
{
  printf("===> len=%d - break loop\n",len);
  break;
}

    if(strncasecmp(buffer,"DATE",4)==0){file.getline (buffer,100);date = (char *)malloc(strlen(buffer)+1); strcpy(date,buffer); }
    else if(strncasecmp(buffer,"RUNTYPE",7)==0){file.getline (buffer,100);runtype = (char *)malloc(strlen(buffer)+1); strcpy(runtype,buffer);}
    else if(strncasecmp(buffer,"BEAMREQUEST",11)==0){file.getline (buffer,100);beamcurrent = (char *)malloc(strlen(buffer)+1); strcpy(beamcurrent,buffer);}
    else if(strncasecmp(buffer,"MINIRASTER",10)==0){file.getline (buffer,100);raster = (char *)malloc(strlen(buffer)+1); strcpy(raster,buffer);}
    else if(strncasecmp(buffer,"OPERATORS",9)==0){file.getline (buffer,100);shiftcrue = (char *)malloc(strlen(buffer)+1); strcpy(shiftcrue,buffer);}
    else if(strncasecmp(buffer,"COMMENT",7)==0)
    {
      file.getline (buffer,100);
      if(strlen(buffer)==99) printf("===> WARNING: comment line maybe cut !!!\n");
      printf("===> %d >%s<\n",strlen(buffer),buffer);
      comment = (char *)malloc(strlen(buffer)+1);
      strcpy(comment,buffer);
    }
    else if(strncasecmp(buffer,"LOG_BOOK",8)==0){file.getline (buffer,100);logbook = (char *)malloc(strlen(buffer)+1); strcpy(logbook,buffer);}
    else if(strncasecmp(buffer,"LOG_PAGE",8)==0){file.getline (buffer,100);page = (char *)malloc(strlen(buffer)+1); strcpy(page,buffer);}
    else if(strncasecmp(buffer,"TARGET",6)==0){file.getline (buffer,100);target = (char *)malloc(strlen(buffer)+1); strcpy(target,buffer);}
    else if(strncasecmp(buffer,"BEAMENERGY",10)==0){file.getline (buffer,100);tk_b_ener = (char *)malloc(strlen(buffer)+1); strcpy(tk_b_ener,buffer);}
    else if(strncasecmp(buffer,"TORUSCURRENT",12)==0){file.getline (buffer,100);tk_t_cur = (char *)malloc(strlen(buffer)+1); strcpy(tk_t_cur,buffer);}
    else if(strncasecmp(buffer,"MINICURRENT",11)==0){file.getline (buffer,100);tk_mt_cur = (char *)malloc(strlen(buffer)+1); strcpy(tk_mt_cur,buffer);}
    else if(strncasecmp(buffer,"TIGRIS",6)==0){file.getline (buffer,100);trig_conf = (char *)malloc(strlen(buffer)+1); strcpy(trig_conf,buffer);}
    else if(strncasecmp(buffer,"CHANNELCONFIG",13)==0){file.getline (buffer,100);chan_conf = (char *)malloc(strlen(buffer)+1); strcpy(chan_conf,buffer);}
    else if(strncasecmp(buffer,"L1MASK",6)==0){file.getline (buffer,100);l1_mask = (char *)malloc(strlen(buffer)+1); strcpy(l1_mask,buffer);}
    else if(strncasecmp(buffer,"PRESCALE",8)==0){file.getline (buffer,100);prescale = (char *)malloc(strlen(buffer)+1); strcpy(prescale,buffer); }
    else if(strncasecmp(buffer,"ECINNERLO",9)==0){file.getline (buffer,100);ec_inner_l = (char *)malloc(strlen(buffer)+1); strcpy(ec_inner_l,buffer); }
    else if(strncasecmp(buffer,"ECINNERHI",9)==0){file.getline (buffer,100);ec_inner_h = (char *)malloc(strlen(buffer)+1); strcpy(ec_inner_h,buffer); }
    else if(strncasecmp(buffer,"ECOUTERLO",9)==0){file.getline (buffer,100);ec_outer_l = (char *)malloc(strlen(buffer)+1); strcpy(ec_outer_l,buffer); }
    else if(strncasecmp(buffer,"ECOUTERHI",9)==0){file.getline (buffer,100);ec_outer_h = (char *)malloc(strlen(buffer)+1); strcpy(ec_outer_h,buffer); }
    else if(strncasecmp(buffer,"ECTOTALLO",9)==0){file.getline (buffer,100);ec_total_l = (char *)malloc(strlen(buffer)+1); strcpy(ec_total_l,buffer); }
    else if(strncasecmp(buffer,"ECTOTALHI",9)==0){file.getline (buffer,100);ec_total_h = (char *)malloc(strlen(buffer)+1); strcpy(ec_total_h,buffer); }
    else if(strncasecmp(buffer,"SCHI",4)==0){file.getline (buffer,100);sc_h = (char *)malloc(strlen(buffer)+1); strcpy(sc_h,buffer); }
    else if(strncasecmp(buffer,"CCHI",4)==0){file.getline (buffer,100);cc_h = (char *)malloc(strlen(buffer)+1); strcpy(cc_h,buffer); }
    else if(strncasecmp(buffer,"CCLO",4)==0){file.getline (buffer,100);cc_l = (char *)malloc(strlen(buffer)+1); strcpy(cc_l,buffer); }
    else if(strncasecmp(buffer,"PhotonTrigger",13)==0){file.getline (buffer,100);photon_trig_conf = (char *)malloc(strlen(buffer)+1); strcpy(photon_trig_conf,buffer); }
    else if(strncasecmp(buffer,"Radiator",8)==0){file.getline (buffer,100);radiator = (char *)malloc(strlen(buffer)+1); strcpy(radiator,buffer); }
    else if(strncasecmp(buffer,"Scalerconfig1",13)==0){file.getline (buffer,100);scaler_config1 = (char *)malloc(strlen(buffer)+1); strcpy(scaler_config1,buffer); }
    else if(strncasecmp(buffer,"Scalerconfig2",13)==0){file.getline (buffer,100);scaler_config2 = (char *)malloc(strlen(buffer)+1); strcpy(scaler_config2,buffer); }
    else if(strncasecmp(buffer,"Scalerconfig3",13)==0){file.getline (buffer,100);scaler_config3 = (char *)malloc(strlen(buffer)+1); strcpy(scaler_config3,buffer); }
    else if(strncasecmp(buffer,"Scalerconfig4",13)==0){file.getline (buffer,100);scaler_config4 = (char *)malloc(strlen(buffer)+1); strcpy(scaler_config4,buffer);}
    else if(strncasecmp(buffer,"PSconvertor",11)==0){file.getline (buffer,100);PS_converter = (char *)malloc(strlen(buffer)+1); strcpy(PS_converter,buffer);}
    else if(strncasecmp(buffer,"Collimator1",11)==0){file.getline (buffer,100);collimator1 = (char *)malloc(strlen(buffer)+1); strcpy(collimator1,buffer); }
    else if(strncasecmp(buffer,"Collimator2",11)==0){file.getline (buffer,100);collimator2 = (char *)malloc(strlen(buffer)+1); strcpy(collimator2,buffer); }
    else if(strncasecmp(buffer,"PCconvertor",11)==0){file.getline (buffer,100);PC_converter = (char *)malloc(strlen(buffer)+1); strcpy(PC_converter,buffer);}
    else if(strncasecmp(buffer,"TAC",3)==0){file.getline (buffer,100);TAC = (char *)malloc(strlen(buffer)+1); strcpy(TAC,buffer);}
    else if(strncasecmp(buffer,"RadPhi",6)==0){file.getline (buffer,100);RadPhi = (char *)malloc(strlen(buffer)+1); strcpy(RadPhi,buffer);}
    else if(strncasecmp(buffer,"ETcoincidence",13)==0){file.getline (buffer,100);et_coincidence = (char *)malloc(strlen(buffer)+1); strcpy(et_coincidence,buffer);}
    else if(strncasecmp(buffer,"Tagger_prescaling",17)==0){file.getline (buffer,100);tagger_prescaling = (char *)malloc(strlen(buffer)+1); strcpy(tagger_prescaling,buffer);}
    else
    {
      printf("===> unknown command >%s<\n",buffer);
    }    
 }

  return 0;
}   


//----------------------------------------------------------------


E 43
D 7
void collect_data(int& run, char *entry){
E 7
I 7
D 21
void collect_data(int& run, strstream &sql){
E 21
I 21
D 28
void collect_data(strstream &sql){
E 28
I 28
D 45
void collect_data(strstream &sql, strstream &sql2) {
E 28
E 21
E 7


D 20
  Tcl_Interp *interp;
  Tk_Window mainWindow; 

I 9
  char *config;
E 9
D 7
  char page[15], book[15], target[200], runnum[10], crew[240], comment[1500], 
       temp[15], entry_date[30]; 
  int bookint, pageint;
I 3
  char *prime="'", *comma=",", *end=")    ", *query;
E 3

E 7
I 7
  char entry_date[30]; 
E 20
I 9
  char crun[10];
E 45
I 45
void
collect_data(strstream &sql, strstream &sql2)
{
E 45
E 9
  strstream query;
E 7
D 9
  int conn_num;
  m_result *result;
  m_row row_out;
E 9
D 7

  time_t now;
E 7
  struct tm *tstruct;
I 7
D 42
  char *prime="'", *comma=",", *end=")";
E 42
I 42
  const char *prime="'", *comma=",", *end=")";
E 42
I 17
  int i;
D 45
  // var's for tcl
  char  ben[11];   
  char  zero[11]; 
  char  tcr[11]; 
  char  mtcr[11]; 
I 32
  char  tagcr[11];
E 45
E 32
E 17
E 7

I 35

E 35
D 7
  char *hed="insert into ingres.run_log_comment ("
    "run,entry_date,operators,target,logbook_book,logbook_page,comment,"
D 3
	"beam_energy,beam_current,torus_current,mini_current"
	") values (";
  char prime[2]="'", comma[2]=",", end[6]=")    "; 
  char *query;
E 3
I 3
    "beam_energy,beam_current,torus_current,mini_current"
    ") values (";
E 7
E 3
D 32

E 32
D 7

  /* init tcl/tk */
E 7
I 7
D 45
  // init tcl/tk
E 7
D 43
  interp = Tcl_CreateInterp();
  Tcl_InitMemory(interp);
D 42
  mainWindow=Tk_CreateMainWindow(interp, getenv("DISPLAY"), "name", "Tk");
E 42
I 42
  mainWindow=Tk_CreateMainWindow(interp, getenv("DISPLAY"), (char*)"name", (char*)"Tk");
E 42
  Tk_MainWindow(interp);
  Tcl_Init(interp);
  Tk_Init(interp);
E 43
I 43
  //  interp = Tcl_CreateInterp();
  //Tcl_InitMemory(interp);
  //mainWindow=Tk_CreateMainWindow(interp, getenv("DISPLAY"), (char*)"name", (char*)"Tk");
  //Tk_MainWindow(interp);
  //Tcl_Init(interp);
  //Tk_Init(interp);
E 43


E 45
D 7
  /* connect to msql database */
E 7
I 7
D 9
  // connect to msql database
E 7
D 6
  MSQL_Init(interp);
E 6
  conn_num = msqlConnect(getenv("MSQL_TCP_HOST"));
  msqlSelectDB(conn_num,msql_database);
  
E 9
I 9
  // get run and config
D 45
  get_run_config(msql_database,session,&run,&config);
E 45
I 45
  get_run_config(mysql_database,session,&run,&config);
E 45
E 9

I 35
D 45

  // set some gui variables
E 35
I 17
  sprintf(zero,"%d",0);
D 35
   Tcl_SetVar(interp,"abort",zero,0);
E 35
I 35
D 42
  Tcl_SetVar(interp,"abort",zero,0);
E 42
I 42
D 43
  Tcl_SetVar(interp,(char*)"abort",zero,0);
E 43
I 43
  //Tcl_SetVar(interp,(char*)"abort",zero,0);
E 43
E 42

E 35
E 17
D 7
  /* Query MSQL and close connection */
  query=(char*) malloc(120);
  sprintf(query,"select runNumber,config from sessions where name='%s'",session);
  msqlQuery(conn_num,query);
E 7
I 7
D 9
  // Query msql and close connection
  query << "select runNumber,config from sessions where name='" << session << "'" << ends;
  msqlQuery(conn_num,query.str());
E 7
  result = msqlStoreResult();
  row_out = msqlFetchRow(result);
  msqlClose(conn_num);
  
E 9

E 45
I 14
  // get epics data
  get_epics_data();
D 17
      
E 17

I 35
D 45

  // set more gui variables
E 35
I 17
  sprintf(ben,"%f",epics_val[0]);
D 35
    Tcl_SetVar(interp,"b_ener",ben,0);
E 35
I 35
D 42
  Tcl_SetVar(interp,"b_ener",ben,0);
E 42
I 42
D 43
  Tcl_SetVar(interp,(char*)"b_ener",ben,0);
E 43
I 43
  //Tcl_SetVar(interp,(char*)"b_ener",ben,0);
E 43
E 42
E 35

  sprintf(tcr,"%f",epics_val[1]);
D 35
   Tcl_SetVar(interp,"t_cur",tcr,0);
E 35
I 35
D 42
  Tcl_SetVar(interp,"t_cur",tcr,0);
E 42
I 42
D 43
  Tcl_SetVar(interp,(char*)"t_cur",tcr,0);
E 43
I 43
  //Tcl_SetVar(interp,(char*)"t_cur",tcr,0);
E 43
E 42
E 35

  sprintf(mtcr,"%f",epics_val[2]);
D 35
   Tcl_SetVar(interp,"mt_cur",mtcr,0);
E 35
I 35
D 42
  Tcl_SetVar(interp,"mt_cur",mtcr,0);
E 42
I 42
D 43
  Tcl_SetVar(interp,(char*)"mt_cur",mtcr,0);
E 43
I 43
  //Tcl_SetVar(interp,(char*)"mt_cur",mtcr,0);
E 43
E 42
E 35

I 32
D 34
  sprintf(tagcr,"%f",epics_val[2]);
E 34
I 34
  sprintf(tagcr,"%f",epics_val[3]);
E 34
D 35
   Tcl_SetVar(interp,"Tag_cur",tagcr,0);
E 35
I 35
D 42
  Tcl_SetVar(interp,"Tag_cur",tagcr,0);
E 42
I 42
D 43
  Tcl_SetVar(interp,(char*)"Tag_cur",tagcr,0);
E 43
I 43
  //Tcl_SetVar(interp,(char*)"Tag_cur",tagcr,0);
E 43
E 42
E 35
E 32

I 32

E 45
E 32
D 21

   //  for(i=0; i<nepics; i++) {
   //  cout << epics[i].name << "---->  " << epics_val[i] <<"-->"<< i << endl;
   //}      

E 21
E 17
E 14
D 7
  /* set tcl variables from MSQL data */
  Tcl_SetVar(interp,"run", row_out[0],0);
  Tcl_SetVar(interp,"mess",row_out[1],0);
E 7
I 7
D 9
  // get run number
  run=atoi(row_out[0]);
E 7


E 9
I 7
  // create entry date in ingres format
  tstruct=localtime(&start);
D 44
  strftime(entry_date,25," %d-%b-%Y %H:%M",tstruct);
E 44
E 7

I 44
  /*sergey strftime(entry_date,25," %d-%b-%Y %H:%M",tstruct);*/
  strftime(entry_date,25," %Y-%m-%d %H:%M:%S",tstruct);
E 44
D 7
  /* read Tk script and transfer control to Tk */
  Tcl_EvalFile(interp,tk_script);
  Tk_MainLoop();
  
E 7
D 45

I 44

E 44
I 7
D 35
  // set tcl variables
E 35
I 35
  // set even more tcl variables
E 35
D 9
  Tcl_SetVar(interp,"run", row_out[0],0);
  Tcl_SetVar(interp,"config",row_out[1],0);
E 9
I 9
  sprintf(crun,"%d",run);
D 42
  Tcl_SetVar(interp,"run",crun,0);
  Tcl_SetVar(interp,"config",config,0);
E 42
I 42
D 43
  Tcl_SetVar(interp,(char*)"run",crun,0);
  Tcl_SetVar(interp,(char*)"config",config,0);
E 43
I 43
  //Tcl_SetVar(interp,(char*)"run",crun,0);
  //Tcl_SetVar(interp,(char*)"config",config,0);
E 43
E 42
E 9
E 7

D 7
  /* user clicked DONE...retrieve values from tcl */
  strcpy(runnum,  Tcl_GetVar(interp,"run",0));
  strcpy(crew,    Tcl_GetVar(interp,"crew",0));
  strcpy(target,  Tcl_GetVar(interp,"tar",0));
  strcpy(comment, Tcl_GetVar(interp,"db",0));
  strcpy(book,    Tcl_GetVar(interp,"bkn",0));
  strcpy(page,    Tcl_GetVar(interp,"bkp",0));
E 7

I 23
  // read and process Tk script
D 43
  strstream script;
  if(tk_script==NULL) {
    script << getenv("CLON_BIN") << "/" << def_tk_script << ends;
  } else {
    script << tk_script << ends;
  }
  Tcl_EvalFile(interp,script.str());
E 43
I 43
  //strstream script;
  //if(tk_script==NULL) {
  //script << getenv("CLON_BIN") << "/" << def_tk_script << ends;
  //} else {
  // script << tk_script << ends;
  //}
  //Tcl_EvalFile(interp,script.str());
E 43
E 23

D 7
  /* convert number strings to ints and back to strings */
  sscanf(book,"%d",&bookint);
  sprintf(book,"%d",bookint);
  sscanf(page,"%d",&pageint);
  sprintf(page,"%d",pageint);

E 7
I 7
D 23
  // read Tk script and transfer control to Tk
  Tcl_EvalFile(interp,tk_script);
E 23
I 23

  // transfer control to Tk
E 23
D 43
  Tk_MainLoop();
E 43
I 43
  //Tk_MainLoop();
E 45
E 43
E 7
  
I 21
D 45

  // get abort flag 
E 21
I 17
D 42
  tk_src_status = atoi(Tcl_GetVar(interp,"abort",0));
E 42
I 42
D 43
  tk_src_status = atoi(Tcl_GetVar(interp,(char*)"abort",0));
E 43
I 43
  //  tk_src_status = atoi(Tcl_GetVar(interp,(char*)"abort",0));
E 43
E 42
E 17
D 7
  /* create entry date */
  now=time(NULL);
  tstruct=localtime(&now);
  strftime(entry_date,25," %d-%b-%Y %H:%M",tstruct);
E 7

D 21

E 21
I 21
  
E 45
E 21
D 7
  /* now have all info...construct Ingres sql string */
  strcat(entry,hed);
  strncat(entry,runnum,10);
  strncat(entry,comma,1);
  strncat(entry,prime,1);
  strncat(entry,entry_date,26);
  strncat(entry,prime,1);
  strncat(entry,comma,1);
  strncat(entry,prime,1);
  strncat(entry,crew,240);
  strncat(entry,prime,1);
  strncat(entry,comma,1);
  strncat(entry,prime,1);
  strncat(entry,target,200);
  strncat(entry,prime,1);
  strncat(entry,comma,1);
  strncat(entry,book,15);
  strncat(entry,comma,1);
  strncat(entry,page,15);
  strncat(entry,comma,1);
  strncat(entry,prime,1);
  strncat(entry,comment,1500);
  strncat(entry,prime,1);
  strncat(entry,comma,1);
  strcat(entry,"0.,0.,0.,0.");        // temporary until new cols added to gui...ejw
  strcat(entry,end);                  // includes add'l blank padding
E 7
I 7
  //  construct sql string
I 10
  sql.setf(ios::showpoint);
E 10
D 44
  sql << "insert into ingres.run_log_comment ("
E 44
I 44
  sql << "insert into run_log_comment ("
E 44
D 10
    "run,entry_date,run_type,operators,target,logbook_book,logbook_page,comment,"
D 9
    "beam_current,hv_status,active_sectors"
E 9
I 9
    "beam_current_request,hv_status,active_sectors"
E 10
I 10
D 13
    "run,entry_date,run_type,target,beam_current_request,hv_status,active_sectors,"
E 13
I 13
D 17
    "session_name,run,entry_date,run_type,target,beam_current_request,hv_status,active_sectors,"
E 13
    "operators,comment,logbook_book,logbook_page"
E 17
I 17
D 23
    "session_name,run,entry_date,run_type,target,beam_current_request,"
E 23
I 23
    "session_name,run,entry_date,run_type,target,beam_current_request,mini_raster,"
E 23
D 21
    "operators,comment,logbook_book,logbook_page, active_sectors"
E 21
I 21
D 24
    "operators,comment,logbook_book,logbook_page,"
E 24
I 24
D 25
    "operators,comment,logbook_book,logbook_page"
E 25
I 25
    "operators,comment,logbook_book,logbook_page,ignore_run"
E 25
E 24
E 21
E 17
E 10
E 9
    ") values ("
D 13
      << run
E 13
I 13
      << prime << session << prime 
      << comma << run
E 13
D 10
      << comma << prime << Tcl_GetVar(interp,"runtype",0) << prime
E 10
      << comma << prime << entry_date << prime
D 10
      << comma << prime << Tcl_GetVar(interp,"crew",0) << prime
      << comma << prime << Tcl_GetVar(interp,"tar",0) << prime
      << comma << atoi(Tcl_GetVar(interp,"bkn",0))
      << comma << atoi(Tcl_GetVar(interp,"bkp",0))
      << comma << prime << Tcl_GetVar(interp,"db",0) << prime
E 10
D 42
      << comma << prime << Tcl_GetVar(interp,"runtype",0) << prime
I 10
      << comma << prime << Tcl_GetVar(interp,"target",0) << prime
D 12
      << comma << atof("100.0")
    //      << comma << atof(Tcl_GetVar(interp,"beamrequest",0))
E 12
I 12
D 17
      << comma << atof(Tcl_GetVar(interp,"beamrequest",0))
E 12
E 10
      << comma << prime << Tcl_GetVar(interp,"hvstatus",0) << prime
D 10
      << comma << prime << Tcl_GetVar(interp,"sectors",0) << prime 
E 10
I 10
      << comma << prime << Tcl_GetVar(interp,"activesectors",0) << prime 
      << comma << prime << Tcl_GetVar(interp,"operators",0) << prime
E 17
I 17
      << comma << atof(Tcl_GetVar(interp,"beamcurrent",0))
I 23
      << comma << prime << Tcl_GetVar(interp,"raster",0) << prime
E 23
      << comma << prime << Tcl_GetVar(interp,"shiftcrue",0) << prime
E 17
      << comma << prime << Tcl_GetVar(interp,"comment",0) << prime
D 17
      << comma << atoi(Tcl_GetVar(interp,"bkn",0))
      << comma << atoi(Tcl_GetVar(interp,"bkp",0))
E 17
I 17
      << comma << atoi(Tcl_GetVar(interp,"logbook",0))
      << comma << atoi(Tcl_GetVar(interp,"page",0))
E 42
I 42
D 43
      << comma << prime << Tcl_GetVar(interp,(char*)"runtype",0) << prime
      << comma << prime << Tcl_GetVar(interp,(char*)"target",0) << prime
      << comma << atof(Tcl_GetVar(interp,(char*)"beamcurrent",0))
      << comma << prime << Tcl_GetVar(interp,(char*)"raster",0) << prime
      << comma << prime << Tcl_GetVar(interp,(char*)"shiftcrue",0) << prime
      << comma << prime << Tcl_GetVar(interp,(char*)"comment",0) << prime
      << comma << atoi(Tcl_GetVar(interp,(char*)"logbook",0))
      << comma << atoi(Tcl_GetVar(interp,(char*)"page",0))
E 43
I 43
      << comma << prime << runtype << prime
      << comma << prime << target << prime
      << comma << atof(beamcurrent)
      << comma << prime << raster << prime
      << comma << prime << shiftcrue << prime
      << comma << prime << comment << prime
      << comma << atoi(logbook)
      << comma << atoi(page)
E 43
E 42
I 25
      << comma << prime << "N" << prime
E 25
D 21
      << comma << prime << "x" << prime
E 21
E 17
E 10
      << end << ends;
E 7


I 28
  //  optional photon string
I 44
D 45
  /*Sergey: do we need it ? no such table in DB anyway ...
E 45
E 44
D 42
  if(strncasecmp(Tcl_GetVar(interp,"runtype",0),"photon",6)==0) {
E 42
I 42
D 43
  if(strncasecmp(Tcl_GetVar(interp,(char*)"runtype",0),"photon",6)==0) {
E 43
I 43
  if(strncasecmp(runtype,"photon",6)==0) {
E 43
E 42
D 33
    sql2 << "insert into run_log_photon ("
E 33
I 33
D 44
    sql2 << "insert into ingres.run_log_photon ("
E 44
I 44
    sql2 << "insert into run_log_photon ("
E 44
E 33
D 31
      "trigger_type,radiator,scaler1_odd,scaler1_even,scaler2_odd,"
E 31
I 31
      "session_name,run,trigger_type,radiator,scaler1_odd,scaler1_even,scaler2_odd,"
E 31
      "scaler2_even,ps_converter,primary_collimator,secondary_collimator,"
D 31
      "pair_counter,tac,radphi) values ("
E 31
I 31
      "pair_counter,tac,radphi,et_coincidence,tagger_prescaling) values ("
	 << prime << session << prime 
	 << comma << run
E 31
D 33
	 << prime << Tcl_GetVar(interp,"photon_trig_conf",0) << prime
E 33
I 33
D 42
	 << comma << prime << Tcl_GetVar(interp,"photon_trig_conf",0) << prime
E 33
D 29
	 << prime << Tcl_GetVar(interp,"radiator",0) << prime
	 << prime << Tcl_GetVar(interp,"scaler_config1",0) << prime
	 << prime << Tcl_GetVar(interp,"scaler_config2",0) << prime
	 << prime << Tcl_GetVar(interp,"scaler_config3",0) << prime
	 << prime << Tcl_GetVar(interp,"scaler_config4",0) << prime
	 << prime << Tcl_GetVar(interp,"PS_converter",0) << prime
	 << prime << Tcl_GetVar(interp,"collimator1",0) << prime
	 << prime << Tcl_GetVar(interp,"collimator2",0) << prime
	 << prime << Tcl_GetVar(interp,"PC_converter",0) << prime
	 << prime << Tcl_GetVar(interp,"TAC",0) << prime
	 << prime << Tcl_GetVar(interp,"RadPhi",0) << prime
E 29
I 29
	 << comma << prime << Tcl_GetVar(interp,"radiator",0) << prime
	 << comma << prime << Tcl_GetVar(interp,"scaler_config1",0) << prime
	 << comma << prime << Tcl_GetVar(interp,"scaler_config2",0) << prime
	 << comma << prime << Tcl_GetVar(interp,"scaler_config3",0) << prime
	 << comma << prime << Tcl_GetVar(interp,"scaler_config4",0) << prime
	 << comma << prime << Tcl_GetVar(interp,"PS_converter",0) << prime
	 << comma << prime << Tcl_GetVar(interp,"collimator1",0) << prime
	 << comma << prime << Tcl_GetVar(interp,"collimator2",0) << prime
	 << comma << prime << Tcl_GetVar(interp,"PC_converter",0) << prime
	 << comma << prime << Tcl_GetVar(interp,"TAC",0) << prime
	 << comma << prime << Tcl_GetVar(interp,"RadPhi",0) << prime
I 31
	 << comma << prime << Tcl_GetVar(interp,"et_coincidence",0) << prime
	 << comma << prime << Tcl_GetVar(interp,"tagger_prescaling",0) << prime
E 42
I 42
D 43
	 << comma << prime << Tcl_GetVar(interp,(char*)"photon_trig_conf",0) << prime
	 << comma << prime << Tcl_GetVar(interp,(char*)"radiator",0) << prime
	 << comma << prime << Tcl_GetVar(interp,(char*)"scaler_config1",0) << prime
	 << comma << prime << Tcl_GetVar(interp,(char*)"scaler_config2",0) << prime
	 << comma << prime << Tcl_GetVar(interp,(char*)"scaler_config3",0) << prime
	 << comma << prime << Tcl_GetVar(interp,(char*)"scaler_config4",0) << prime
	 << comma << prime << Tcl_GetVar(interp,(char*)"PS_converter",0) << prime
	 << comma << prime << Tcl_GetVar(interp,(char*)"collimator1",0) << prime
	 << comma << prime << Tcl_GetVar(interp,(char*)"collimator2",0) << prime
	 << comma << prime << Tcl_GetVar(interp,(char*)"PC_converter",0) << prime
	 << comma << prime << Tcl_GetVar(interp,(char*)"TAC",0) << prime
	 << comma << prime << Tcl_GetVar(interp,(char*)"RadPhi",0) << prime
	 << comma << prime << Tcl_GetVar(interp,(char*)"et_coincidence",0) << prime
	 << comma << prime << Tcl_GetVar(interp,(char*)"tagger_prescaling",0) << prime
E 43
I 43
	 << comma << prime << photon_trig_conf << prime
	 << comma << prime << radiator << prime
	 << comma << prime << scaler_config1 << prime
	 << comma << prime << scaler_config2 << prime
	 << comma << prime << scaler_config3 << prime
	 << comma << prime << scaler_config4 << prime
	 << comma << prime << PS_converter << prime
	 << comma << prime << collimator1 << prime
	 << comma << prime << collimator2 << prime
	 << comma << prime << PC_converter << prime
	 << comma << prime << TAC << prime
	 << comma << prime << RadPhi << prime
	 << comma << prime << et_coincidence << prime
	 << comma << prime << tagger_prescaling << prime
E 43
E 42
E 31
E 29
	 << end << ends;
  } else {
    sql2 << ends;
  }
I 44
D 45
  */
E 45
E 44

I 45

E 45
D 44

E 44
E 28
D 7
  // return run number
  run=atoi(runnum);


E 7
D 3
  // debug printout
  if(debug!=0){
    cout << entry << endl;
  }


E 3
  return;
}


//----------------------------------------------------------------
  

I 14
D 44
void get_epics_data(){
E 44
I 44
void
get_epics_data()
{
  int result;
E 44

D 44
  int i,status;
  cdevGroup group;


  // create all request objects and callbacks
  for(i=0; i<nepics; i++){
D 42
    obj[i] = cdevRequestObject::attachPtr(epics[i].chan,epics[i].get);
E 42
I 42
    obj[i] = cdevRequestObject::attachPtr((char*)epics[i].chan,(char*)epics[i].get);
E 42
    cb[i] = new cdevCallback(epics_callback_func,(void*)i);
  }
  

  // read channels
  group.start();
  for(i=0; i<nepics; i++) {
E 44
I 44
  // read channels (use CA !)
  for(int i=0; i<nepics; i++)
  {
E 44
    epics_val[i]=-1.0;
D 44
    status=obj[i]->sendCallback(NULL,*cb[i]);
E 44
  }
I 44
  result = getepics(nepics, epics_chan, epics_val);
E 44

D 44

  // process group of callbacks
  group.pend((double)cdev_pend_time);
  

E 44
  return;
}


D 45
//---------------------------------------------------------------------------
E 45
I 45
//----------------------------------------------------------------
E 45

D 45

E 45
D 44
void epics_callback_func(int status, void *userarg, cdevRequestObject &epics_req_obj,
			    cdevData& result){

  epics_val[(int)userarg] =    (float) result;

  return;
}


//---------------------------------------------------------------------------


E 14
D 3
void insert_into_database(int& run, char *entry){
E 3
I 3
D 20
void insert_into_database(char *entry){
E 20
I 20
D 21
void insert_into_ipc(int &run, char *entry){
E 21
I 21
D 28
void insert_into_ipc(char *entry){
E 28
I 28
void insert_into_ipc(char *entry, char *entry2) {
E 28
E 21
E 20
E 3


E 44
I 44
void
insert_into_ipc(char *entry, char *entry2)
{
E 44
D 4
  T_IPC_MSG msg;


  // connect to server after disabling gmd timeout
E 4
I 4
  // disable gmd timeout
E 4
D 42
  T_OPTION opt=TutOptionLookup("Server_Delivery_Timeout");
E 42
I 42
  T_OPTION opt=TutOptionLookup((T_STR)"Server_Delivery_Timeout");
E 42
  TutOptionSetNum(opt,0.0);
I 4

D 44

E 44
  // connect to server
  TipcSrv &server=TipcSrv::Instance();
E 4
D 5
  dbr_init(uniq_dg,application,id_string);
E 5
I 5
  dbr_init(uniq_dgrp,application,id_string);
E 5


D 4
  // construct message
  msg = TipcMsgCreate(TipcMtLookup("dbr_request"));
  TipcMsgSetUserProp(msg,0);
  TipcMsgSetDeliveryMode(msg,T_IPC_DELIVERY_ALL);
  TipcMsgSetDest(msg,dest);
E 4
I 4
D 20
  // construct dbr_request message
D 5
  TipcMsg msg = TipcMsg(2,dest,"run_log_comment");
E 5
I 5
  TipcMsg msg = TipcMsg("dbr_request");
  msg.Dest(dest);
  msg.Sender(uniq_dgrp);
E 5
  msg.UserProp(0.0);
  msg.DeliveryMode(T_IPC_DELIVERY_ALL);
E 20
I 20
D 35
  // dbr_request message
E 35
I 35
  // dbrouter message
E 35
D 44
  if(no_dbr==0) {
E 44
I 44
  if(no_dbr==0)
  {
E 44
D 42
    TipcMsg msg = TipcMsg("dbr_request");
E 42
I 42
    TipcMsg msg = TipcMsg((T_STR)"dbr_request");
E 42
    msg.Dest(dest);
    msg.Sender(uniq_dgrp);
    msg.UserProp(0.0);
    msg.DeliveryMode(T_IPC_DELIVERY_ALL);
    
D 28
    // fill and send
E 28
I 28
    // fill and send...check for photon run
E 28
    msg << (T_INT4) 1 << entry;
I 28
D 42
    if(strncasecmp(Tcl_GetVar(interp,"runtype",0),"photon",6)==0) {
E 42
I 42
D 43
    if(strncasecmp(Tcl_GetVar(interp,(char*)"runtype",0),"photon",6)==0) {
E 43
I 43
    if(strncasecmp(runtype,"photon",6)==0) {
E 43
E 42
      msg << (T_INT4) 1 << entry2;
    }
E 28
    server.Send(msg);
  }
E 20
E 4


D 4
  /* fill message data */
  TipcMsgAppendInt4(msg,1);
  TipcMsgAppendStr(msg,entry);
E 4
I 4
D 20
  // fill message 
  msg << (T_INT4) 1 << entry;
E 20
I 20
  // info server message
  if(no_info==0) {
D 42
    TipcMsg msg = TipcMsg("info_server");
D 36
    msg.Dest("info_server");
E 36
I 36
    msg.Dest("info_server/in/run_log_comment");
E 42
I 42
    TipcMsg msg = TipcMsg((T_STR)"info_server");
    msg.Dest((T_STR)"info_server/in/run_log_comment");
E 42
E 36
    msg.Sender(uniq_dgrp);
D 35
    msg.DeliveryMode(T_IPC_DELIVERY_BEST_EFFORT);
E 35
    
    // fill and send
D 28
    msg << "run_log_comment" << (T_INT4) run << session << entry_date
E 28
I 28
D 42
    msg << "run_log_comment" 
E 42
I 42
    msg << (T_STR)"run_log_comment" 
E 42
	<< (T_INT4) run << session << entry_date
E 28
D 42
	<< Tcl_GetVar(interp,"runtype",0)
	<< Tcl_GetVar(interp,"target",0)
D 36
	<< (T_REAL4) atof(Tcl_GetVar(interp,"beamcurrent",0))
E 36
I 36
	<< (T_REAL8) atof(Tcl_GetVar(interp,"beamcurrent",0))
E 36
	<< Tcl_GetVar(interp,"shiftcrue",0)
	<< Tcl_GetVar(interp,"comment",0)
	<< (T_INT4) atoi(Tcl_GetVar(interp,"logbook",0))
D 35
	<< (T_INT4) atoi(Tcl_GetVar(interp,"page",0));
E 35
I 35
	<< (T_INT4) atoi(Tcl_GetVar(interp,"page",0))
D 36
	<< (T_REAL4) atof(Tcl_GetVar(interp,"tk_b_ener",0))
E 36
I 36
	<< (T_REAL8) atof(Tcl_GetVar(interp,"tk_b_ener",0))
E 36
	<< Tcl_GetVar(interp,"raster",0) 
D 36
	<< (T_REAL4) atof(Tcl_GetVar(interp,"tk_t_cur",0))
	<< (T_REAL4) atof(Tcl_GetVar(interp,"tk_mt_cur",0))
E 36
I 36
	<< (T_REAL8) atof(Tcl_GetVar(interp,"tk_t_cur",0))
	<< (T_REAL8) atof(Tcl_GetVar(interp,"tk_mt_cur",0))
E 36
	<< Tcl_GetVar(interp,"trig_conf",0) 
	<< Tcl_GetVar(interp,"chan_conf",0) 
	<< Tcl_GetVar(interp,"l1_mask",0) 
	<< Tcl_GetVar(interp,"prescale",0)
	<< (T_INT4) atoi(Tcl_GetVar(interp,"ec_inner_h",0))
	<< (T_INT4) atoi(Tcl_GetVar(interp,"ec_inner_l",0))
	<< (T_INT4) atoi(Tcl_GetVar(interp,"ec_outer_h",0))
	<< (T_INT4) atoi(Tcl_GetVar(interp,"ec_outer_l",0))
	<< (T_INT4) atoi(Tcl_GetVar(interp,"ec_total_h",0))
	<< (T_INT4) atoi(Tcl_GetVar(interp,"ec_total_l",0))
	<< (T_INT4) atoi(Tcl_GetVar(interp,"sc_h",0))
	<< (T_INT4) atoi(Tcl_GetVar(interp,"cc_h",0))
	<< (T_INT4) atoi(Tcl_GetVar(interp,"cc_l",0));
E 42
I 42
D 43
	<< Tcl_GetVar(interp,(char*)"runtype",0)
	<< Tcl_GetVar(interp,(char*)"target",0)
	<< (T_REAL8) atof(Tcl_GetVar(interp,(char*)"beamcurrent",0))
	<< Tcl_GetVar(interp,(char*)"shiftcrue",0)
	<< Tcl_GetVar(interp,(char*)"comment",0)
	<< (T_INT4) atoi(Tcl_GetVar(interp,(char*)"logbook",0))
	<< (T_INT4) atoi(Tcl_GetVar(interp,(char*)"page",0))
	<< (T_REAL8) atof(Tcl_GetVar(interp,(char*)"tk_b_ener",0))
	<< Tcl_GetVar(interp,(char*)"raster",0) 
	<< (T_REAL8) atof(Tcl_GetVar(interp,(char*)"tk_t_cur",0))
	<< (T_REAL8) atof(Tcl_GetVar(interp,(char*)"tk_mt_cur",0))
	<< Tcl_GetVar(interp,(char*)"trig_conf",0) 
	<< Tcl_GetVar(interp,(char*)"chan_conf",0) 
	<< Tcl_GetVar(interp,(char*)"l1_mask",0) 
	<< Tcl_GetVar(interp,(char*)"prescale",0)
	<< (T_INT4) atoi(Tcl_GetVar(interp,(char*)"ec_inner_h",0))
	<< (T_INT4) atoi(Tcl_GetVar(interp,(char*)"ec_inner_l",0))
	<< (T_INT4) atoi(Tcl_GetVar(interp,(char*)"ec_outer_h",0))
	<< (T_INT4) atoi(Tcl_GetVar(interp,(char*)"ec_outer_l",0))
	<< (T_INT4) atoi(Tcl_GetVar(interp,(char*)"ec_total_h",0))
	<< (T_INT4) atoi(Tcl_GetVar(interp,(char*)"ec_total_l",0))
	<< (T_INT4) atoi(Tcl_GetVar(interp,(char*)"sc_h",0))
	<< (T_INT4) atoi(Tcl_GetVar(interp,(char*)"cc_h",0))
	<< (T_INT4) atoi(Tcl_GetVar(interp,(char*)"cc_l",0));
E 43
I 43
	<< runtype
	<< target
	<< (T_REAL8) atof(beamcurrent)
	<< shiftcrue
	<< comment
	<< (T_INT4) atoi(logbook)
	<< (T_INT4) atoi(page)
	<< (T_REAL8) atof(tk_b_ener)
	<< raster 
	<< (T_REAL8) atof(tk_t_cur)
	<< (T_REAL8) atof(tk_mt_cur)
	<< trig_conf 
	<< chan_conf 
	<< l1_mask 
	<< prescale
	<< (T_INT4) atoi(ec_inner_h)
	<< (T_INT4) atoi(ec_inner_l)
	<< (T_INT4) atoi(ec_outer_h)
	<< (T_INT4) atoi(ec_outer_l)
	<< (T_INT4) atoi(ec_total_h)
	<< (T_INT4) atoi(ec_total_l)
	<< (T_INT4) atoi(sc_h)
	<< (T_INT4) atoi(cc_h)
	<< (T_INT4) atoi(cc_l);
E 43
E 42
E 35
    server.Send(msg);
I 28

I 35

E 35
D 42
    if(strncasecmp(Tcl_GetVar(interp,"runtype",0),"photon",6)==0) {
      TipcMsg msg2 = TipcMsg("info_server");
      msg2.Dest("info_server");
E 42
I 42
D 43
    if(strncasecmp(Tcl_GetVar(interp,(char*)"runtype",0),"photon",6)==0) {
E 43
I 43
    if(strncasecmp(runtype,"photon",6)==0) {
E 43
      TipcMsg msg2 = TipcMsg((T_STR)"info_server");
      msg2.Dest((T_STR)"info_server");
E 42
      msg2.Sender(uniq_dgrp);
D 35
      msg2.DeliveryMode(T_IPC_DELIVERY_BEST_EFFORT);
E 35
D 42
      msg2 << "run_log_photon" 
E 42
I 42
      msg2 << (T_STR)"run_log_photon" 
E 42
I 31
	   << (T_INT4) run << session << entry_date
E 31
D 42
	   << Tcl_GetVar(interp,"photon_trig_conf",0)
	   << Tcl_GetVar(interp,"radiator",0)
	   << Tcl_GetVar(interp,"scaler_config1",0)
	   << Tcl_GetVar(interp,"scaler_config2",0)
	   << Tcl_GetVar(interp,"scaler_config3",0)
	   << Tcl_GetVar(interp,"scaler_config4",0)
	   << Tcl_GetVar(interp,"PS_converter",0)
	   << Tcl_GetVar(interp,"collimator1",0)
	   << Tcl_GetVar(interp,"collimator2",0)
	   << Tcl_GetVar(interp,"PC_converter",0)
	   << Tcl_GetVar(interp,"TAC",0)
D 31
	   << Tcl_GetVar(interp,"RadPhi",0);
E 31
I 31
	   << Tcl_GetVar(interp,"RadPhi",0)
	   << Tcl_GetVar(interp,"et_coincidence",0)
	   << Tcl_GetVar(interp,"tagger_prescaling",0);
E 42
I 42
D 43
	   << Tcl_GetVar(interp,(char*)"photon_trig_conf",0)
	   << Tcl_GetVar(interp,(char*)"radiator",0)
	   << Tcl_GetVar(interp,(char*)"scaler_config1",0)
	   << Tcl_GetVar(interp,(char*)"scaler_config2",0)
	   << Tcl_GetVar(interp,(char*)"scaler_config3",0)
	   << Tcl_GetVar(interp,(char*)"scaler_config4",0)
	   << Tcl_GetVar(interp,(char*)"PS_converter",0)
	   << Tcl_GetVar(interp,(char*)"collimator1",0)
	   << Tcl_GetVar(interp,(char*)"collimator2",0)
	   << Tcl_GetVar(interp,(char*)"PC_converter",0)
	   << Tcl_GetVar(interp,(char*)"TAC",0)
	   << Tcl_GetVar(interp,(char*)"RadPhi",0)
	   << Tcl_GetVar(interp,(char*)"et_coincidence",0)
	   << Tcl_GetVar(interp,(char*)"tagger_prescaling",0);
E 43
I 43
	   << photon_trig_conf
	   << radiator
	   << scaler_config1
	   << scaler_config2
	   << scaler_config3
	   << scaler_config4
	   << PS_converter
	   << collimator1
	   << collimator2
	   << PC_converter
	   << TAC
	   << RadPhi
	   << et_coincidence
	   << tagger_prescaling;
E 43
E 42
E 31
      server.Send(msg2);
    }
E 28
  }
E 20
E 4


D 4
  // send, flush, destroy
  TipcSrvMsgSend(msg,FALSE);
  TipcSrvFlush();
  TipcMsgDestroy(msg);
E 4
I 4
D 20
  // send, flush msg
  server.Send(msg);
E 20
I 20
  // flush all messages
E 20
  server.Flush();
E 4
D 20


E 20
I 20
  
  
E 20
  // allow gmd to acknowledge receipt
D 20
  dbr_check((double) gmd_time);
E 20
I 20
  if(no_dbr==0)dbr_check((double) gmd_time);
E 20


  // close ipc connection
  dbr_close();


  return;
}

//----------------------------------------------------------------
  

D 21
void insert_into_dd(int &run, char *entry){
E 21
I 21
D 28
void insert_into_dd(char *entry){
E 28
I 28
D 37
void insert_into_dd(char *entry, char *entry2) {
E 37
I 37
D 44
void insert_into_data(char *entry, char *entry2) {
E 37
E 28
E 21
  
D 37
  int status;
  int *p,i,nused,banksize,nhead,buflen;
  struct fifo_mode fmode;
  fifo_entry fev;
D 3
  int dblen;
E 3
  int ctl[4] = {-1,-1,-1,-1};


  // connect to DD system INPUT fifo
  fmode.mode     = FMODE_ALL;
  fmode.wait     = FWAIT_SLEEP;
  fmode.suser    = FMODE_MULTI_USER;
  fmode.prescale = 1;
  fmode.p2ctl    = ctl;
  status=ddu_init("INPUT",fmode);
  if(status!=0){
    cerr << "?unable to attach to DD system INPUT fifo, status is: " << status << endl;
    return;
  }
E 37

E 44
I 44
void
insert_into_data(char *entry, char *entry2)
{
E 44
D 37

  // get free fifo event
D 3
  status=ddu_req_fev(BUFFERSIZE,&fev);
E 3
I 3
  status=ddu_req_fev(DDBUFFERSIZE,&fev);
E 3
  if(status!=0){
    cerr << "?unable to get fev, status is: " << status << endl;
    return;
  }
E 37
I 37
  TipcSrv &server=TipcSrv::Instance();
  dbr_init(uniq_dgrp,application,id_string);
E 37


D 37
  // set pointer, reset counts, fill ctl words, etc.
  p=fev.p2da;
  nused=0;
  nhead=0;
  fev.ctlw1=ddctl[0];
  fev.ctlb1=ddctl[1];
  fev.ctlw2=ddctl[2];
  fev.ctlb2=ddctl[3];


  // create segment header, then update pointer and counters
D 3
  status=create_header(p,BUFFERSIZE-nused,nhead,run,nevnt,nphys,trig);
E 3
I 3
D 15
  status=create_header(p,DDBUFFERSIZE-nused,nhead,run,nevnt,nphys,trig);
E 15
I 15
  status=create_header(p,DDBUFFERSIZE-nused,nhead,'RUNP','ARMS',run,nevnt,nphys,trig);
E 15
E 3
  if(status==0){
    p+=nhead;
    nused+=nhead;
  }  


  // head bank
D 3
  status=va_add_bank(p,BUFFERSIZE-nused,"HEAD",0,"I",8,1,8,banksize,
E 3
I 3
  status=va_add_bank(p,DDBUFFERSIZE-nused,"HEAD",0,"I",8,1,8,banksize,
E 3
	      nvers,run,nevnt,start,type,rocst,evcls,presc);
  if(status==0){
    p+=banksize;
    nused+=banksize;
  }
E 37
I 37
D 42
  TipcMsg msg("evt_bosbank");
  msg.Sender("run_log_comment");
E 42
I 42
  TipcMsg msg((T_STR)"evt_bosbank");
  msg.Sender((T_STR)"run_log_comment");
E 42
D 38
  sprintf(dest,"evt_bosbank/%s",session);
  msg.Dest(dest);
E 38
I 38
  sprintf(temp,"evt_bosbank/%s",session);
  msg.Dest(temp);
E 38
E 37


  // fill data bank with logbook info
D 11
  buflen=strlen(entry)/4;
E 11
I 11
D 37
  buflen=(strlen(entry)+3)/4;
E 11
D 3
  status=add_bank(p,BUFFERSIZE-nused,"RNLG",2,"A",1,1,buflen,banksize,(int *)entry);
E 3
I 3
  status=add_bank(p,DDBUFFERSIZE-nused,"RNLG",2,"A",1,1,buflen,banksize,(int *)entry);
E 3
  if(status==0){
    p+=banksize;
    nused+=banksize;
  }
E 37
I 37
  int buflen=(strlen(entry)+3)/4;
D 42
  msg << "RNLG" << (T_INT4)2 << "(A)" << (T_INT4)1 << (T_INT4)1 << (T_INT4)buflen
E 42
I 42
  msg << (T_STR)"RNLG" << (T_INT4)2 << (T_STR)"(A)" << (T_INT4)1 << (T_INT4)1 << (T_INT4)buflen
E 42
      << SetSize(buflen) << (T_INT4*)entry;
E 37

I 28

  // fill data bank with optional photon info
D 42
  if(strncasecmp(Tcl_GetVar(interp,"runtype",0),"photon",6)==0) {
E 42
I 42
D 43
  if(strncasecmp(Tcl_GetVar(interp,(char*)"runtype",0),"photon",6)==0) {
E 43
I 43
  if(strncasecmp(runtype,"photon",6)==0) {
E 43
E 42
    buflen=(strlen(entry2)+3)/4;
D 37
    status=add_bank(p,DDBUFFERSIZE-nused,"RNLG",3,"A",1,1,buflen,banksize,(int *)entry2);
    if(status==0){
      p+=banksize;
      nused+=banksize;
    }
  }

E 28

  // all banks added...set fev and fpack overall word counts
  fev.len=nused;
  *(fev.p2da+10)=nused-nhead;


  // insert event into DD system
  status=ddu_put_fev(fev);
  if(status!=0){
    cerr << "?unable to put fev, status is: " << status << endl;
    return;
E 37
I 37
D 42
    msg << "RNLG" << (T_INT4)3 << "(A)" << (T_INT4)1 << (T_INT4)1 << (T_INT4)buflen
E 42
I 42
    msg << (T_STR)"RNLG" << (T_INT4)3 << (T_STR)"(A)" << (T_INT4)1 << (T_INT4)1 << (T_INT4)buflen
E 42
	<< SetSize(buflen) << (T_INT4*)entry2;
E 37
  }


D 37
  // disconnect from DD system
  ddu_close();

E 37
I 37
  server.Send(msg);
  server.Flush();
  dbr_close();
E 37

  return;
}

I 45
//---------------------------------------------------------------------

void
get_string(ifstream &file, const char* tag, char *var)
{
  char line[1024];
  find_tag_line(file,tag,line,sizeof(line));
  get_next_line(file,line,sizeof(line));
  strcpy(var,line);
  return;
}

//---------------------------------------------------------------------

void
get_double2(ifstream &file, const char* tag, double *var)
{
  char line[1024];
  file.setf(ios::skipws);
  file.seekg(0,ios::beg);

  for(;;) {
    if(!file.is_open()||!file.good()||file.eof()||file.fail()||file.bad()) return;
    file.getline(line,sizeof(line));
    if(strncasecmp(line+strspn(line," \t\n\r\b"),tag,strlen(tag))==0) {
      *var = atof(strstr(line," - ")+3);
      return;
    }
  }

  return;
}


//---------------------------------------------------------------------


void
get_int2(ifstream &file, const char* tag, int *var)
{
  char line[1024];
  file.setf(ios::skipws);
  file.seekg(0,ios::beg);

  for(;;) {
    if(!file.is_open()||!file.good()||file.eof()||file.fail()||file.bad()) return;
    file.getline(line,sizeof(line));
    if(strncasecmp(line+strspn(line," \t\n\r\b"),tag,strlen(tag))==0) {
      *var = atoi(strstr(line," - ")+3);
      return;
    }
  }

  return;
}


//---------------------------------------------------------------------


void
get_string2(ifstream &file, const char* tag, char *var)
{
  char line[1024];
  file.setf(ios::skipws);
  file.seekg(0,ios::beg);

  for(;;) {
    if(!file.is_open()||!file.good()||file.eof()||file.fail()||file.bad()) return;
    file.getline(line,sizeof(line));
    if(strncasecmp(line+strspn(line," \t\n\r\b"),tag,strlen(tag))==0) {
      strcpy(var,strstr(line," - ")+3);
      return;
    }
  }

  return;
}
//---------------------------------------------------------------------


void
double_quotes(char out[], char in[])
{
  int i,p;

  p=0;
  for(i=0; i<strlen(in); i++) {
    if(in[i]!='\'') {
      out[p]=in[i];
      p++;
    } else {
      out[p]='\'';
      out[p+1]='\'';
      p+=2;
    }
  }
  out[p]='\0';
}


//---------------------------------------------------------------------


void
get_string3(ifstream &file, const char* tag, char *var)
{
  char line[1024];
  strcpy(var,"");
  find_tag_line(file,tag,line,sizeof(line));
  for(;;) {
    if(!file.is_open()||!file.good()||file.eof()||file.fail()||file.bad()) return;
    file.getline(line,sizeof(line));
    strcat(var,line);
  }
}


//---------------------------------------------------------------------


void
convert_date(char *out, char *in)
{
  char *p;
  char wkday[5];
  char month[5];
  int day;
  int mon;
  int year;
  char time[10];
  char edt[5];

  strcpy(out,"");
E 45
  
I 45
  strncpy(wkday,strtok(in," "),3);

  strncpy(month,strtok(NULL," "),3); month[3]='\0';
  if(!strncmp(month,"Jan",3))      mon=1;
  else if(!strncmp(month,"Feb",3)) mon=2;
  else if(!strncmp(month,"Mar",3)) mon=3;
  else if(!strncmp(month,"Apr",3)) mon=4;
  else if(!strncmp(month,"May",3)) mon=5;
  else if(!strncmp(month,"Jun",3)) mon=6;
  else if(!strncmp(month,"Jul",3)) mon=7;
  else if(!strncmp(month,"Aug",3)) mon=8;
  else if(!strncmp(month,"Sep",3)) mon=9;
  else if(!strncmp(month,"Oct",3)) mon=10;
  else if(!strncmp(month,"Nov",3)) mon=11;
  else if(!strncmp(month,"Dec",3)) mon=12;
  else printf("ERROR: unknown month >%s<\n",month);

  day=atoi(strtok(NULL," "));

  strncpy(time,strtok(NULL," "),8); time[8]='\0';

  strncpy(edt,strtok(NULL," "),3);

  year=atoi(strtok(NULL," "));

  /*print time in following form: 2009-05-14 08:05:46*/
  sprintf(out,"%d-%02d-%02d %s",year,mon,day,time);
  return;
}


//---------------------------------------------------------------------


char *
trim(char *in)
{
  char *p=in+strspn(in," \t\n\r\b");
  for(int i=strlen(p)-1; i>0; i--) {
    if((p[i]==' ')||(p[i]=='\t')||(p[i]=='\n')||(p[i]=='\r')||(p[i]=='\b')) {
      p[i]='\0';
    } else {
      break;
    }
  }
  //  p[strcspn(p," \t\n\r\b")]='\0';
  return(p);

}

//---------------------------------------------------------------------


char *
env_name(const char *env, const char *name)
{
  static char bigname[200];
  char *e=getenv(env);

  if(e!=NULL) {
    strcpy(bigname,e);
    strcat(bigname,"/");
    strcat(bigname,name);
  } else {
    strcpy(bigname,name);
  }
  
  return(bigname);
}

E 45
//----------------------------------------------------------------


D 44
void decode_command_line(int argc, char **argv)
E 44
I 44
void
decode_command_line(int argc, char **argv)
E 44
{

  int i=1;
D 42
  char *help="\nusage:\n\n  run_log_comment [-a application] [-u uniq_dgrp] [-i id_string] [-debug]\n"
E 42
I 42
  const char *help="\nusage:\n\n  run_log_comment [-a application] [-u uniq_dgrp] [-i id_string] [-debug]\n"
E 42
D 45
               "        [-d destination] [-t tk_script] [-m msql_database]\n"
D 14
               "        [-s session]     [-no_dbr]      [-no_dd]     [-g gmd_time]\n\n\n";
E 14
I 14
D 20
               "        [-s session] [-no_dbr] [-no_dd] [-c cdev_pend_time] [-g gmd_time]\n\n\n";
E 20
I 20
D 37
               "        [-s session] [-no_dbr] [-no_info] [-no_dd] [-c cdev_pend_time] [-g gmd_time]\n\n\n";
E 37
I 37
D 44
               "        [-s session] [-no_dbr] [-no_info] [-no_data] [-c cdev_pend_time] [-g gmd_time]\n\n\n";
E 44
I 44
               "        [-s session] [-no_dbr] [-no_info] [-no_data] [-g gmd_time]\n\n\n";
E 45
I 45
               "        [-d destination] [-m mysql_database] [-s session] [-no_dbr]\n"
               "        [-no_info] [-no_data] [-g gmd_time] file1 file2 ...\n\n\n";
E 45
E 44
E 37
E 20
E 14


D 45
  while(i<argc) {
    
E 45
I 45
  while(i<argc)
  {  
E 45
    if(strncasecmp(argv[i],"-h",2)==0){
      printf(help);
      exit(EXIT_SUCCESS);
    }
I 45
    else if (strncasecmp(argv[i],"-",1)!=0){
      filep=i;
      return;
    }
E 45
    else if (strncasecmp(argv[i],"-debug",6)==0){
      debug=1;
      i=i+1;
    }
    else if (strncasecmp(argv[i],"-no_dbr",7)==0){
      no_dbr=1;
      i=i+1;
    }
I 20
    else if (strncasecmp(argv[i],"-no_info",8)==0){
      no_info=1;
      i=i+1;
    }
E 20
D 37
    else if (strncasecmp(argv[i],"-no_dd",6)==0){
      no_dd=1;
E 37
I 37
    else if (strncasecmp(argv[i],"-no_data",8)==0){
      no_data=1;
E 37
      i=i+1;
    }
    else if (strncasecmp(argv[i],"-a",2)==0){
      application=strdup(argv[i+1]);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-u",2)==0){
D 5
      uniq_dg=strdup(argv[i+1]);
E 5
I 5
      uniq_dgrp=strdup(argv[i+1]);
E 5
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-i",2)==0){
      id_string=strdup(argv[i+1]);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-d",2)==0){
      dest=strdup(argv[i+1]);
      i=i+2;
    }
I 14
D 44
    else if (strncasecmp(argv[i],"-c",2)==0){
      cdev_pend_time=atoi(argv[i+1]);
      i=i+2;
    }
E 44
E 14
    else if (strncasecmp(argv[i],"-g",2)==0){
      gmd_time=atoi(argv[i+1]);
      i=i+2;
    }
D 45
    else if (strncasecmp(argv[i],"-t",2)==0){
      tk_script=strdup(argv[i+1]);
      i=i+2;
    }
E 45
    else if (strncasecmp(argv[i],"-s",2)==0){
D 45
      session=strdup(argv[i+1]);
E 45
I 45
      strcpy(session,argv[i+1]);
E 45
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-m",2)==0){
D 45
      msql_database=strdup(argv[i+1]);
E 45
I 45
      mysql_database=strdup(argv[i+1]);
E 45
      i=i+2;
    }
  }
}


D 7
/*---------------------------------------------------------------------*/
E 7
I 7
//---------------------------------------------------------------------
E 7

E 1
