/*
   Purpose and Methods : fit one track segment in a SuperLayer
     (replacement for dclramb.c)

   Input:    isec       - sector number
             is         - superlayer number
             psi        - projection track angle w.r. to R (or normal to SL)
             digi[6][5] - hit info {iw,tdc,Td,-/+Dm,SigDm} for segment in a SL:
               digi[la][0] - Wire number "iw"
               digi[la][1] - Raw TDC [counts]
               digi[la][2] - Drift Time Td [ns] to the hit wire# "iw"
               digi[la][3] - Drift Distance (measured) -/+Dm [cm]
               digi[la][4] - Sigma of Drift Distance SigDm [cm]

 sdageom._pln[ip][isec][6]  - Radius of DC arc
 sdageom._pln[ip][isec][11] - Phi angle of the 1-st logical sense wire in BCS
 sdageom._pln[ip][isec][12] - DeltaPhi (between adjacent sense wires in cyl. part)
 sdageom._pln[ip][isec][16] - Last sense wire number in cylindrical part
 sdageom._pln[ip][isec][18] - Radius of a cell (= DeltaPhi*R/2)



   Outputs : chib        - best chi2 from all 4 solutions.
             slopD       - slope difference between track segment & PR fit
             dat0B       - strait line intercept at layer#1
             digi[la][3] - SIGNED Drift Distance (measured) -/+Dm [cm]

   Controls:


   Library belongs    : libana.a

   Calls              : none

   Created    2-SEP-2001   Sergey Boyarinov

   Called by dcdcam
*/

#include <stdio.h>
#include <math.h>
#include "dclib.h"
#include "sdakeys.h"
#include "sdageom.h"

#define ABS(x) ((x) < 0 ? -(x) : (x))
#define SIGN(x1,x2) ((x2) < 0 ? -ABS(x1) : ABS(x1))

#define NLAY     6
#define MIN_NLAY 3    /* min. number of layers needed */
#define SLcut    0.10

#define NBIN 100
#define NBIN2 (NBIN/2)
#define xcell 1.5

static float
MIN(float a1, float a2, float a3, float a4)
{
  float amin;

  amin = a1;
  if(a2 < amin) amin = a2;
  if(a3 < amin) amin = a3;
  if(a4 < amin) amin = a4;
  return(amin);
}

void
dcfitsl_(int *isec, int *is, float digi[6][5], float *psi, float *chib,
         float *slopD, float *dat0B)
{
  dcfitsl(*isec, *is, digi, *psi, chib, slopD, dat0B);
  return;
}

void
dcfitsl(int isec, int is, float digi[6][5], float psi, float *chib,
        float *slopD, float *dat0B)
{
  int i, j, il,il3, J1, J2, JW, max_miss, nmiss, nw0,
      ilmin, LLL, LLR, LRL, LRR, LRB;
  int miss[NLAY];  /* inefficiency of any cause */
  float xr[NLAY], phw[NLAY],dlw[NLAY], wstg[NLAY], w, Scut;
  float dw1LL, dw2LL, dw1LR, dw2LR, dw1RL, dw2RL, dw1RR, dw2RR;
  float fw0, fw1, fw2, fdet;
  float chiLL, chiLR, chiRL, chiRR;
  float dat0LL, dat0LR, dat0RL, dat0RR;
  float drawLL, drawLR, drawRL, drawRR;
  float dsegLL, dsegLR, dsegRL, dsegRR;
  float predLL, predLR, predRL, predRR;
  float sgnLL, sgnLR, sgnRL, sgnRR;
  float slopLL, slopLR, slopRL, slopRR, slopTF, slopB;
  float cpsi, df, deti, ddist[NLAY], derr[NLAY], deltaR;
  int itmp, jtmp;
  float tmp, tmp1;

  /* */
  static int NLinSL[6]  = {4, 6, 6, 6, 6, 6};

  /* space resolution in SL (cm) */
  static float resSL[6] = {0.09, 0.09, 0.15, 0.15, 0.15, 0.15};
  static float wfit[6]  = {10., 10., 10., 10., 10., 10.};

  int i0, i1, i2, i3, i4, i5, ibin, ibin1, ibin2, iarray[NBIN];
  float y[6], yfit[2][6], a, b, e;
  float digi3[6];
  for(i=0; i<NLAY; i++) digi3[i] = digi[i][3];

  /* Maximum inefficiency (in terms of #layer) possible */
  max_miss =  NLAY - MIN_NLAY;

  /* Initialize chi-square best and second best to huge values */
  *chib = 1000.0;

  cpsi = cos(psi);
  slopTF = tan(psi);
  Scut = SLcut * sqrt( (float)NLAY / (float)NLinSL[is-1] );

  /* Local coordinate system where "xr" is X-axis along R of SL (or normal
     to SL) and "wstg", Y-axis along the layer (arc) */

  ilmin = (is-1)*NLAY + nst_max;
  il3 = ilmin + 3;
  deltaR = sdageom_.pln[isec-1][il3-1][6] - sdageom_.pln[isec-1][il3-1-1][6];
  for(i=0; i<NLAY; i++)
  {
    il = ilmin + i;
    w = ABS(digi[i][0]);
    if(w > sdageom_.pln[isec-1][il][16])
    {
      phw[i] = sdageom_.pln[isec-1][il][11]
               + (sdageom_.pln[isec-1][il][16] - 1.)
               * sdageom_.pln[isec-1][il][12];
      dlw[i] = (w - sdageom_.pln[isec-1][il][16])
               *2.*sdageom_.pln[isec-1][il3-1][18];
    }
    else
    {
      phw[i] = sdageom_.pln[isec-1][il][11]
               + (w-1.)*sdageom_.pln[isec-1][il][12];
      dlw[i] = 0.0;
    }
    xr[i]    = (float)i*deltaR;
    wstg[i]  = (phw[i] - phw[0])*sdageom_.pln[isec-1][il][6]
               + dlw[i] - dlw[0];
    ddist[i] = ABS(digi[i][3]) / cpsi;
    derr[i]  = digi[i][4] / cpsi;

    yfit[0][i] = wstg[i] - xr[i]*slopTF - ddist[i];
    yfit[1][i] = wstg[i] - xr[i]*slopTF + ddist[i];
  }










  /* fill 'pattern recognition' histogram */

  for(i=0; i<NBIN; i++) iarray[i] = 0;
  for(i=0; i<NLAY; i++)
  {
    for(j=0; j<2; j++)
    {
      ibin1 = (int)((yfit[j][i]-resSL[is-1])/resSL[is-1]) + NBIN2;
      ibin2 = (int)((yfit[j][i]+resSL[is-1])/resSL[is-1]) + NBIN2;
      for(ibin=ibin1; ibin<=ibin2; ibin++)
      {
        if(ibin>=0 && ibin<NBIN) iarray[ibin] ++;
      }
    }
  }
/*
  printf("\nis=%d\n",is);
  printf("xr=%f %f %f %f %f %f\n",xr[0],xr[1],xr[2],xr[3],xr[4],xr[5]);
  printf("yfit0=%f %f %f %f %f %f\n",yfit[0][0],yfit[0][1],yfit[0][2],yfit[0][3],yfit[0][4],yfit[0][5]);
  printf("yfit1=%f %f %f %f %f %f\n",yfit[1][0],yfit[1][1],yfit[1][2],yfit[1][3],yfit[1][4],yfit[1][5]);
*/

  /* find peak position from histogram */

  itmp = j = -1;
  for(i=1; i<(NBIN-1); i++)
  {
    jtmp = iarray[i];
    if(jtmp>itmp)
    {
      itmp = jtmp;
      j = i;
    }
    /*
    if(iarray[i]>9) printf("x");
    else            printf("%1d",iarray[i]);
    */
  }
  tmp = ((float)(j - NBIN2))*resSL[is-1];






  /* correct peak position
  tmp1 = 0;
  itmp = 0;
  for(i=0; i<NLAY; i++)
  {
    il = (is-1)*NLAY + nst_max + i;
    if(ABS(y[i]-tmp) < xcell*sdageom_.pln[isec-1][il][18])
    {
      tmp1 += y[i];
      itmp ++;
    }
  }

  printf("y0=%f %f %f %f %f %f\n",y[0],y[1],y[2],y[3],y[4],y[5]);
  printf("Max=%f corrected=%f(%f %f)\n",tmp,tmp1/(float)itmp,tmp1,(float)itmp);
  tmp = tmp1/itmp;
  */




  /* put to zero hits located too far and resolve left-right ambiguity*/

  for(i=0; i<NLAY; i++)
  {
    il = (is-1)*NLAY + nst_max + i;
    if(ABS(yfit[0][i]-tmp) < ABS(yfit[1][i]-tmp))
    {
      y[i] = yfit[0][i];
      if(ABS(y[i]-tmp) < xcell*sdageom_.pln[isec-1][il][18])
      {
        digi3[i] = -ABS(digi3[i]);
      }
    }
    else
    {
      y[i] = yfit[1][i];
      if(ABS(y[i]-tmp) < xcell*sdageom_.pln[isec-1][il][18])
      {
        digi3[i] = ABS(digi3[i]);
      }
    }
    if(ABS(y[i]-tmp) >= xcell*sdageom_.pln[isec-1][il][18])
    {
      y[i] = 0.;
    }
  }







  /* final fit */

  printf("    y1=%f %f %f %f %f %f\n",y[0],y[1],y[2],y[3],y[4],y[5]);
  for(i=0; i<NLAY; i++) if(y[i] != 0.) y[i] += xr[i]*slopTF;
  printf("    y2=%f %f %f %f %f %f\n",y[0],y[1],y[2],y[3],y[4],y[5]);

  /*lfit(xr,y,NLAY,0,&a,&b,&e);*/
  lfitw(xr,y,wfit,NLAY,0,&a,&b,&e);


  printf("  digi-> %f %f %f %f %f %f\n",
  digi3[0],digi3[1],digi3[2],digi3[3],digi3[4],digi3[5]);
  printf("  e=%f a_=%f b=%f\n\n",e,a-slopTF,b);


	
  for(i=0; i<NLAY; i++) digi[i][3] = digi3[i];
  *chib  = e;
  *slopD = a-slopTF;
  *dat0B = b;
  return;
	






  /* cleanup the number of missing */
  for(i=1; i<=NLAY; i++) miss[i-1] = 0;

  /* Find first 2 starting layers, total the no. of inefficient layers
     if no. of required layers met, J1 will be the first; J2 the second */

  nmiss = 0;
  J1 = 0;
  J2 = 0;
  for(il=1; il<=NLAY; il++)
  {
    if(digi[il-1][0] <= 0.)   /* -ve no. mean inefficiency */
    {
      nmiss++;
      miss[il-1] = 1;
    }
    else
    {
      if(J1 == 0)          /* Test if J1 is picked */
      {
        J1 = il;
      }
      else
      {
        if(J2 == 0)        /* Test if J2 is picked */
        {
          J2 = il;
        }
      }
    }
  }

  /* Too many inefficient layers, leave subroutine */

  if((nmiss > max_miss) || (J1 == 0) || (J2 == 0)) return;

  /* Initialize four starting solutions (first 2 layers) */

  nw0 = 2;
  fw0 = nw0;
  fw1 = xr[J1-1] + xr[J2-1];                    /* Sum of the x's */
  fw2 = xr[J1-1]*xr[J1-1] + xr[J2-1]*xr[J2-1];  /* Sum of the x squares */

  dw1LL = -ddist[J1-1]+wstg[J1-1]            -ddist[J2-1]+wstg[J2-1];
  dw2LL =(-ddist[J1-1]+wstg[J1-1])*xr[J1-1]+(-ddist[J2-1]+wstg[J2-1])*xr[J2-1];
  dw1LR = -ddist[J1-1]+wstg[J1-1]            +ddist[J2-1]+wstg[J2-1];
  dw2LR =(-ddist[J1-1]+wstg[J1-1])*xr[J1-1]+( ddist[J2-1]+wstg[J2-1])*xr[J2-1];
  dw1RL =  ddist[J1-1]+wstg[J1-1]            -ddist[J2-1]+wstg[J2-1];
  dw2RL =( ddist[J1-1]+wstg[J1-1])*xr[J1-1]+(-ddist[J2-1]+wstg[J2-1])*xr[J2-1];
  dw1RR =  ddist[J1-1]+wstg[J1-1]            +ddist[J2-1]+wstg[J2-1];
  dw2RR =( ddist[J1-1]+wstg[J1-1])*xr[J1-1]+( ddist[J2-1]+wstg[J2-1])*xr[J2-1];

  /* We have two hits to get started, solve lin. regress */

  fdet = fw0*fw2-fw1*fw1;
  if(fdet <= 0.0) return;
  deti = 1. / fdet;
  dat0LL = ( dw1LL*fw2 - dw2LL*fw1)*deti;
  slopLL = (-dw1LL*fw1 + dw2LL*fw0)*deti;
  dat0LR = ( dw1LR*fw2 - dw2LR*fw1)*deti;
  slopLR = (-dw1LR*fw1 + dw2LR*fw0)*deti;
  dat0RL = ( dw1RL*fw2 - dw2RL*fw1)*deti;
  slopRL = (-dw1RL*fw1 + dw2RL*fw0)*deti;
  dat0RR = ( dw1RR*fw2 - dw2RR*fw1)*deti;
  slopRR = (-dw1RR*fw1 + dw2RR*fw0)*deti;

  /* Loop over remaining wires, picking up hits for segment */

  for(JW=1; JW<=NLAY; JW++)
  {
    if(digi[JW-1][0] <= 0.0) continue;
    if(JW == J1 || JW == J2) continue;

    /* Determine predicted distance, using dat0 and slop */

    predLL = dat0LL + slopLL*xr[JW-1] - wstg[JW-1];
    sgnLL  = SIGN(1.,predLL);
    predLR = dat0LR + slopLR*xr[JW-1] - wstg[JW-1];
    sgnLR  = SIGN(1.,predLR);
    predRL = dat0RL + slopRL*xr[JW-1] - wstg[JW-1];
    sgnRL  = SIGN(1.,predRL);
    predRR = dat0RR + slopRR*xr[JW-1] - wstg[JW-1];
    sgnRR  = SIGN(1.,predRR);

    nw0++;
    fw0  = nw0;
    fw1  = fw1 + xr[JW-1];            /* Sum of the x's */
    fw2  = fw2 + xr[JW-1]*xr[JW-1];   /* Sum of the x squares */

    dsegLL = sgnLL*ddist[JW-1] + wstg[JW-1];
    dw1LL  = dw1LL + dsegLL;
    dw2LL  = dw2LL + dsegLL*xr[JW-1];
    dsegLR = sgnLR*ddist[JW-1] + wstg[JW-1];
    dw1LR  = dw1LR + dsegLR;
    dw2LR  = dw2LR + dsegLR*xr[JW-1];
    dsegRL = sgnRL*ddist[JW-1] + wstg[JW-1];
    dw1RL  = dw1RL + dsegRL;
    dw2RL  = dw2RL + dsegRL*xr[JW-1];
    dsegRR = sgnRR*ddist[JW-1] + wstg[JW-1];
    dw1RR  = dw1RR + dsegRR;
    dw2RR  = dw2RR + dsegRR*xr[JW-1];

    /* If we have more than one hit in seg, solve lin. regress. */

    fdet = fw0*fw2 - fw1*fw1;
    if(fdet <= 0.) continue;       /* avoid divding by delta=0 */
    deti = 1. / fdet;
    dat0LL = ( dw1LL*fw2 - dw2LL*fw1)*deti;
    slopLL = (-dw1LL*fw1 + dw2LL*fw0)*deti;
    dat0LR = ( dw1LR*fw2 - dw2LR*fw1)*deti;
    slopLR = (-dw1LR*fw1 + dw2LR*fw0)*deti;
    dat0RL = ( dw1RL*fw2 - dw2RL*fw1)*deti;
    slopRL = (-dw1RL*fw1 + dw2RL*fw0)*deti;
    dat0RR = ( dw1RR*fw2 - dw2RR*fw1)*deti;
    slopRR = (-dw1RR*fw1 + dw2RR*fw0)*deti;
  }


  /* Check if min. required layers is met */

  if(nw0 < MIN_NLAY) return;

  /* Get left/right ambig resol for the four solutions */

  chiLL = 0.;
  chiLR = 0.;
  chiRL = 0.;
  chiRR = 0.;
  LLL  = 0;
  LLR  = 0;
  LRL  = 0;
  LRR  = 0;

  /* "Lxx" has its first 6 bits set to one if the xx solution ends
      up on the RIGHT-hand side of the hit wire for each of the 6 layers */

  for(j=0; j<NLAY; j++)
  {
    if(!miss[j])
    {
      predLL = dat0LL + slopLL*xr[j] - wstg[j];
      if(predLL > 0.) {itmp=1; LLL = LLL | (itmp << j);}
      drawLL = SIGN(ddist[j],predLL);
      tmp = (drawLL - predLL)/derr[j];
      chiLL += tmp*tmp;

      predLR = dat0LR + slopLR*xr[j] - wstg[j];
      if(predLR > 0.) {itmp=1; LLR = LLR | (itmp << j);}
      drawLR = SIGN(ddist[j],predLR);
      tmp = (drawLR - predLR)/derr[j];
      chiLR += tmp*tmp;

      predRL = dat0RL + slopRL*xr[j] - wstg[j];
      if(predRL > 0.) {itmp=1; LRL = LRL | (itmp << j);}
      drawRL = SIGN(ddist[j],predRL);
      tmp = (drawRL - predRL)/derr[j];
      chiRL += tmp*tmp;

      predRR = dat0RR + slopRR*xr[j] - wstg[j];
      if(predRR > 0.) {itmp=1; LRR = LRR | (itmp << j);}
      drawRR = SIGN(ddist[j],predRR);
      tmp = (drawRR - predRR)/derr[j];
      chiRR += tmp*tmp;
    }
  }

  /* Normalize chi-square's by dividing by number of degrees of
   freedom for all four solutions, and correcting for the slope */

  df = nw0 - 2;
  chiLL = chiLL / df;
  chiLR = chiLR / df;
  chiRL = chiRL / df;
  chiRR = chiRR / df;

  /* Record the slope difference with the best solution */

  if(ABS(slopLL-slopTF) > Scut) chiLL += 100000.;
  if(ABS(slopLR-slopTF) > Scut) chiLR += 100000.;
  if(ABS(slopRL-slopTF) > Scut) chiRL += 100000.;
  if(ABS(slopRR-slopTF) > Scut) chiRR += 100000.;

  /* Pick the solution with the least chi-square */

  *chib = MIN(chiLL,chiLR,chiRL,chiRR);

  /* Save the set bits for the best solution and then pick the
     solution with the second best chi-square */

  if(ABS(*chib - chiLL) < 0.00001)
  {
    LRB   = LLL;
    slopB = slopLL;
    *dat0B = dat0LL * cpsi;
  }
  else if(ABS(*chib - chiLR) < 0.00001)
  {
    LRB   = LLR;
    slopB = slopLR;
    *dat0B = dat0LR * cpsi;
  }
  else if(ABS(*chib - chiRL) < 0.00001)
  {
    LRB   = LRL;
    slopB = slopRL;
    *dat0B = dat0RL * cpsi;
  }
  else if(ABS(*chib - chiRR) < 0.00001)
  {
    LRB   = LRR;
    slopB = slopRR;
    *dat0B = dat0RR * cpsi;
  }
  else
  {
    ;
  }
  *slopD = slopB - slopTF;



  /* Mark the sign to indicate LR, "-" => Left of the wire */
  for(i=1; i<=NLAY; i++)
  {
    if(!miss[i-1])
    {
      int tmp;
      tmp = 1;

      if( LRB & (tmp << (i-1)) )
      {
        digi[i-1][3] =  ABS(digi[i-1][3]);
      }
      else
      {
        digi[i-1][3] = -ABS(digi[i-1][3]);
      }
    }
  }



  /* if chi-square >7.0 (CL < 1%), re-do LR_amb with 2 diff. starting layers */


if(digi3[0]!=digi[0][3] || digi3[1]!=digi[1][3] || digi3[2]!=digi[2][3] ||
digi3[3]!=digi[3][3] || digi3[4]!=digi[4][3] || digi3[5]!=digi[5][3])
{
printf("digi1-> %f %f %f %f %f %f\n",
digi3[0],digi3[1],digi3[2],digi3[3],digi3[4],digi3[5]);
printf("digi2-> %f %f %f %f %f %f\n",
digi[0][3],digi[1][3],digi[2][3],digi[3][3],digi[4][3],digi[5][3]);

printf("dcfitsl: %f %f %f\n",e,a-slopTF,b);
printf("lramb0 : %f %f %f\n",*chib,*slopD,*dat0B);
}

  if(*chib <= sdakeys_.zcut[5]) return;

  return;
}

