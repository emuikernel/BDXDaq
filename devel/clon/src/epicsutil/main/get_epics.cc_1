/* TODO: implement ca_pend_time ?? 
 */

//
//  get_epics
//
//  Reads file of epics channel names, gets data, then writes data to stdout
//  If file doesn't exist uses file as channel name
//
//
//  File format
//  -----------
//    # first non-blank char is a comment line
//    B_xxx.DVI                   // reads channel B_xxx   via "get DVI"
//    MTIRBCK                     // reads channel MTIRBCK via "get"
//
//
//  usage:
//       get_epics [-c ca_pend_time] infile [outfile]
//
//
//  ejw, 9-may-97
// sergey: implement CA-based version, eliminate cdev

// for posix
#define _POSIX_SOURCE_ 1
#define __EXTENSIONS__


// system stuff

using namespace std;
#include <strstream>

#include <iostream.h>
#include <fstream.h>
#include <iomanip.h>

// EPICS CA includes
#include <stdio.h>
#include <epicsStdlib.h>
#include <string.h>

#include <alarm.h>
#include <cadef.h>
#include <epicsGetopt.h>

#include "tool_lib_1.h"

#define PEND_EVENT_SLICES 5     /* No. of pend_event slices for callback requests */

/* Different output formats */
typedef enum { plain, terse, all, specifiedDbr } OutputT;

/* Different request types */
typedef enum { get, callback } RequestT;

static int nConn = 0;           /* Number of connected PVs */
static int nRead = 0;           /* Number of channels that were read */
static int floatAsString = 0;   /* Flag: fetch floats as string */




// max entries in file
#define MAX_ENTRY 5000

// max number of elements in CA array
#define MAX_CHANNELS_LENGTH 1000

// max length of epics ca name
#define MAXCANAMELEN 60

// misc
static char *epics_filename    = NULL;
static char *outfile           = NULL;
static int ca_pend_time      = 60;
static int ncallback           = 0;
static char channel[MAX_ENTRY][MAXCANAMELEN];
static char channel_get[MAX_ENTRY][10];
static float channel_val[MAX_ENTRY];
static int caget_mode          = 0;


// prototypes
void decode_command_line(int argc, char **argv);
int get_epics_data(void);



/*********************************************************************************/
/*********************************************************************************/
/****************** from $EPICS_BASE/src/catools/caget.c *************************/

/*+**************************************************************************
 *
 * Function:	event_handler
 *
 * Description:	CA event_handler for request type callback
 * 		Allocates the dbr structure and copies the data
 *
 * Arg(s) In:	args  -  event handler args (see CA manual)
 *
 **************************************************************************-*/

void
event_handler(evargs args)
{
  pv *ppv;

  /* args.usr contains pointer to the 'ppv' from ca_create_subscription() call
  (see connaction_handler) */
  ppv = (pv *)args.usr;

  ppv->status = args.status;
  if (args.status == ECA_NORMAL)
  {
    ppv->dbrType = args.type;
    ppv->value   = calloc(1, dbr_size_n(args.type, args.count));
    memcpy(ppv->value, args.dbr, dbr_size_n(args.type, args.count));
    ppv->onceConnected = 1;
    nRead++;
  }
}

/*+**************************************************************************
 *
 * Function:	caget
 *
 * Description:	Issue read requests, wait for incoming data
 * 		and print the data according to the selected format
 *
 * Arg(s) In:	pvs       -  Pointer to an array of pv structures
 *              nPvs      -  Number of elements in the pvs array
 *              request   -  Request type
 *              format    -  Output format
 *              dbrType   -  Requested dbr type
 *              reqElems  -  Requested number of (array) elements
 *
 * Return(s):	Error code: 0 = OK, 1 = Error
 *
 **************************************************************************-*/

/* sergey: instead of printing values we'll fill channe1_val[] array; all error prints
   are commented out as well: we'll return '-9999' in case of any problem; only
   format='plain' is used here */
int
caget(pv *pvs, int nPvs, RequestT request, OutputT format,
      chtype dbrType, unsigned long reqElems, float valfloatarray[MAX_CHANNELS_LENGTH])
{
  unsigned int i;
  int n, result;
  float valfloat;

  for(n=0; n<nPvs; n++)
  {
    /* Set up pvs structure */
    /* -------------------- */

    /* Get natural type and array count */
    pvs[n].nElems  = ca_element_count(pvs[n].ch_id);
    pvs[n].dbfType = ca_field_type(pvs[n].ch_id);

    /* Set up value structures */
    if (format != specifiedDbr)
    {
      dbrType = dbf_type_to_DBR_TIME(pvs[n].dbfType); /* Use native type */
      if (dbr_type_is_ENUM(dbrType))                  /* Enums honour -n option */
      {
        if (enumAsNr) dbrType = DBR_TIME_INT;
        else          dbrType = DBR_TIME_STRING;
      }
      else if (floatAsString &&
                 (dbr_type_is_FLOAT(dbrType) || dbr_type_is_DOUBLE(dbrType)))
      {
        dbrType = DBR_TIME_STRING;
      }
    }

    /* Adjust array count */
    if (reqElems == 0 || pvs[n].nElems < reqElems) reqElems = pvs[n].nElems;

    /* Remember dbrType and reqElems */
    pvs[n].dbrType  = dbrType;
    pvs[n].reqElems = reqElems;

    /* Issue CA request */
    /* ---------------- */

    if (ca_state(pvs[n].ch_id) == cs_conn)
    {
      nConn++;
      pvs[n].onceConnected = 1;
      if (request == callback) /* Event handler will allocate value */
      {
        result = ca_array_get_callback(dbrType,
                                       reqElems,
                                       pvs[n].ch_id,
                                       event_handler,
                                       (void*)&pvs[n]);
      }
      else /* Allocate value structure */
      {
        pvs[n].value = calloc(1, dbr_size_n(dbrType, reqElems));
        result = ca_array_get(dbrType,
                              reqElems,
                              pvs[n].ch_id,
                              pvs[n].value);
      }
      pvs[n].status = result;
    }
    else
    {
      pvs[n].status = ECA_DISCONN;
    }
  }
  if (!nConn) return(1);              /* No connection? We're done. */

  /* Wait for completion */
  /* ------------------- */

  result = ca_pend_io(caTimeout);
  if (result == ECA_TIMEOUT)
	fprintf(stderr, "Read operation timed out: some PV data was not read.\n");

  if (request == callback)    /* Also wait for callbacks */
  {
    double slice = caTimeout / PEND_EVENT_SLICES;
    for (n = 0; n < PEND_EVENT_SLICES; n++)
    {
      ca_pend_event(slice);
      if (nRead >= nConn) break;
    }
    if (nRead < nConn)
            fprintf(stderr, "Read operation timed out: some PV data was not read.\n");
  }

  /* Print the data */
  /* -------------- */

  for(n=0; n<nPvs; n++)
  {
    reqElems = pvs[n].reqElems;

    switch (format)
    {
        case plain:             /* Emulate old caget behaviour */
            if (reqElems <= 1) /*printf("%-30s ", pvs[n].name)*/;
            else               /*printf("%s", pvs[n].name)*/;
        case terse:
            if (pvs[n].status == ECA_DISCONN)
			  printf("*** not connected\n");
            else if (pvs[n].status == ECA_NORDACCESS)
			  printf("*** no read access\n");
            else if (pvs[n].status != ECA_NORMAL)
			  printf("*** CA error %s\n", ca_message(pvs[n].status));
            else if (pvs[n].value == 0)
			  printf("*** no data available (timeout)\n");
            else
            {
              char *ss;
              if (reqElems > 1) /*printf(" %lu ", reqElems)*/;
              for (i=0; i<reqElems; ++i)
			  {
                ss = val2str(pvs[n].value, pvs[n].dbrType, i, &valfloat);
                printf("%s ", ss);
			  }
              printf("\n");
              if(reqElems == 1) valfloatarray[n] = valfloat; /* no CA arrays here */
            }
            break;
        case all:
            print_time_val_sts(&pvs[n], reqElems, valfloatarray);
            break;
        case specifiedDbr:
            printf("%s\n", pvs[n].name);
            if (pvs[n].status == ECA_DISCONN)
                printf("    *** not connected\n");
            else if (pvs[n].status == ECA_NORDACCESS)
                printf("    *** no read access\n");
            else if (pvs[n].status != ECA_NORMAL)
                printf("    *** CA error %s\n", ca_message(pvs[n].status));
            else
            {
              printf("    Data type:      %s (native: %s)\n",
                       dbr_type_to_text(pvs[n].dbrType),
                       dbf_type_to_text(pvs[n].dbfType));
              if (pvs[n].dbrType == DBR_CLASS_NAME)
			  {
                printf("    Class Name:     %s\n",
                           *((dbr_string_t*)dbr_value_ptr(pvs[n].value,
                                                          pvs[n].dbrType)));
			  }
              else
              {
                printf("    Element count:  %lu\n"
                           "    Value:          ",
                           reqElems);
                for (i=0; i<reqElems; ++i)       /* Print value(s) */
                        printf("%s ", val2str(pvs[n].value, pvs[n].dbrType, i, &valfloat));
                printf("\n");

                /* Extended type extra info */
                if (pvs[n].dbrType > DBR_DOUBLE)
                        printf("%s\n", dbr2str(pvs[n].value, pvs[n].dbrType));
                   
              }
            }
            break;
        default :
            break;
    }
  }
  return(0);
}


/*********************************************************/
/*********************************************************/
/*********************************************************/



//--------------------------------------------------------------------------

int
main(int argc,char **argv)
{
  // decode command line
  decode_command_line(argc,argv);

  // get HV data
  get_epics_data();

  // done
  exit(EXIT_SUCCESS);

}
       

//----------------------------------------------------------------

/*
input:
 nPvs - the number of PVs
 */

int
getepics(int nPvs, char canames[MAX_ENTRY][MAXCANAMELEN], float valfloats[MAX_ENTRY])
{
  int n = 0;
  int result;
  OutputT format = plain;     /* User specified format */
  RequestT request = get;     /* User specified request type */
  int count = 0;              /* 0 = not specified by -# option */
  int type = -1;              /* getopt() data type argument */
  pv *pvs = 0;                /* Array of PV structures */

  if(nPvs < 1)
  {
    fprintf(stderr, "No pv name specified. ('get_epics -h' for help.)\n");
    return(1);
  }

  /* Start up Channel Access */

  result = ca_context_create(ca_disable_preemptive_callback);
  if(result != ECA_NORMAL)
  {
    fprintf(stderr, "CA error %s occurred while trying "
            "to start channel access '%s'.\n", ca_message(result), pvs[n].name);
    return(1);
  }

  /* Allocate PV structure array */
  pvs = (pv *) calloc(nPvs, sizeof(pv));
  if (!pvs)
  {
    fprintf(stderr, "Memory allocation for channel structures failed.\n");
    return(1);
  }

  /* Connect channels */
  for(n=0; n<nPvs; n++)
  {
    pvs[n].name = (char *)&canames[n][0];       /* Copy PV names */
  }
  connect_pvs(pvs, nPvs);

  /* Read and print data */
  result = caget(pvs, nPvs, request, format, type, count, valfloats);

  /* Shut down Channel Access */
  ca_context_destroy();

  return(0);
}

int
get_epics_data()
{
  char buffer[120];
  int nentry=0;
  char chget[20];
  int result;

  // read channel names from file and create request objects...ignore comments and blank lines
  ifstream file(epics_filename);
  if(file.is_open())
  {
    while(file.is_open()&&file.good()&&!file.eof()&&!file.fail()&&!file.bad())
    {
      file.getline(buffer,sizeof(buffer));
      if(strlen(buffer)==0)continue;
      if(strlen(buffer)==strspn(buffer," \t\n\r\b"))continue;
      if(strncasecmp(buffer+strspn(buffer," \t\n\r\b"),"#",1)==0)continue;
      if(nentry>=MAX_ENTRY)
      {
	    cout << "?too many entries..." << MAX_ENTRY << " max...the rest are being ignored!" << endl;
	    break;
      }
      nentry++;
      sscanf(buffer+strspn(buffer," \t\n\r\b"),"%[^ .].%[^. ]",
	     channel[nentry-1],channel_get[nentry-1]);
      channel_val[nentry-1]=-9999.;
      if(strlen(channel_get[nentry-1])==0) strcpy(channel_get[nentry-1],"VAL");
    }
    file.close();
  }
  else
  {
    caget_mode=1;
    ca_pend_time=1;
    nentry=1;
    sscanf(epics_filename+strspn(epics_filename," \t\n\r\b"),"%[^ .].%[^. ]",
	   channel[0],channel_get[0]);
    channel_val[0]=-9999.;
    if(strlen(channel_get[0])==0) strcpy(channel_get[0],"VAL");
  }







  /*** sergey: new CA stuff ***/

  result = getepics(nentry, channel, channel_val);
  printf("%d %d >%s< -> %f\n",result,nentry,channel[0],channel_val[0]);

  /****************************/







  /*
  // check if all callbacks received
  if(ncallback<nentry) {
    if(caget_mode==0) {
      cerr << "?only received " << ncallback << " callbacks" << " out of " 
	 << nentry << " expected" << endl;
    } else {
      cout << channel_val[0] << endl;
      return;
    }
  }    
  */



  // write results
  if(outfile==NULL)
  {
    cout.setf(ios::left);
    for(int i=0; i<nentry; i++)
    {
      if(caget_mode==0)
      {
	    strstream name;
	    name << channel[i] << "." << channel_get[i] << ends;
	    cout << setw(30) << name.str() << channel_val[i] << endl;
      }
      else
      {
	    cout << channel_val[0] << endl;
      }
    }
  }
  else
  {
    ofstream ofile(outfile);
    ofile.setf(ios::left);
    for(int i=0; i<nentry; i++)
    {
      strstream name;
      name << channel[i] << "." << channel_get[i] << ends;
      ofile << setw(30) << name.str() << channel_val[i] << endl;
    }
  }

  return(result);
}



//---------------------------------------------------------------------------


void
decode_command_line(int argc, char **argv)
{
  int i=1;
  const char *help = "\n  get_epics [-c ca_pend_time] infile [outfile]\n\n";

  if(argc<2)
  {
    cout << help;
    exit(EXIT_SUCCESS);
  }

  while(i<argc)
  {
    if(strncasecmp(argv[i],"-h",2)==0)
    {
      printf(help);
      exit(EXIT_SUCCESS);
    }
    else if (strncasecmp(argv[i],"-c",2)==0)
    {
      ca_pend_time=atoi(argv[i+1]);
      i += 2;
    }
    else if (strncasecmp(argv[i],"-",1)!=0)
    {
      epics_filename=strdup(argv[i]);
      if(argc>i+1) outfile=strdup(argv[i+1]);
      break;
    }
  }

  if(epics_filename==NULL)
  {
    cout << help;
    exit(EXIT_SUCCESS);
  }

  return;
}


/*---------------------------------------------------------------------*/

