h04657
s 00002/00002/00228
d D 1.5 03/08/12 16:24:38 sergpozd 6 5
c uncomented "define LASER_CODA_ENABLE 1"
e
s 00005/00000/00225
d D 1.4 03/07/21 17:47:42 sergpozd 5 4
c *** empty log message ***
e
s 00002/00004/00223
d D 1.3 03/07/21 17:15:02 sergpozd 4 3
c added current_mpos[]
e
s 00172/00814/00055
d D 1.2 03/07/21 14:12:53 sergpozd 3 1
c Completely new revision
e
s 00000/00000/00000
d R 1.2 03/03/03 14:04:15 Codemgr 2 1
c SunPro Code Manager data about conflicts, renames, etc...
c Name history : 1 0 laser/sc/s/TOF_laser.c
e
s 00869/00000/00000
d D 1.1 03/03/03 14:04:14 boiarino 1 0
c date and time created 03/03/03 14:04:14 by boiarino
e
u
U
f e 0
t
T
I 1
D 3
/*************************************************
 * 
 * TOF_laser.c
E 3
I 3
/*
 * TOF_laser.c - operate lasers for TOF calibration.
E 3
 *
D 3
 * 8/00
 * change the wait from 10 t0 5 in the motor moving loop
 * broadcast the status at the end
E 3
I 3
 *    written by:    Kevin Giovanetti, 1999-2000
E 3
 *
D 3
 * written by kevin Giovanetti 99-00
E 3
I 3
 *    modified by:   SP, June 2003
E 3
 *
D 3
 * Code that will set up the laser for TOF calibration
 * (see other docs in /logbook)
E 3
 *
D 3
 * Code will be started by the DAQ for calibration runs
 * the status will be checked for DAQ, VXworks crates, lasrs, filters.
 * when all is okay the lasers and filters 
 * controlling intensity  will be setup
 * and started.  The reuslting data generated by the laser
 * will be collected by the DAQ. Status will be inserted in the
 * data stream to record the setup.
E 3
I 3
 * Code will be started by the DAQ for calibration runs.
 * DAQ will operate independently of this code and will
 * collect data generated by these lasers. If the code
 * crashes or functions improperly DAQ should not be affected.
E 3
 *
D 3
 * DAQ will operate independently of this code. If the code crashes
 * or functions improperly the lasers or filters may not be
 * intialized or run correctly but the DAQ should not be affected.
 * (The data may be bad.)
 * 
 * The smartsocket broadcasts are used to send messages
 *   progress: These two lines are equivalent to a print
 *     sprintf(  messge to a char string prog_msg)
 *     ss_prog to broadcast the messge
 *   status: ID, Value
 *      add_status(id,val)   loads or updates status array
 *      ss_status    broadcasts all loaded status variables
 *  You need to run an additional program to receive the messages (ss_receive.java, ss_receive.c)
E 3
I 3
 * Logic of this code:
E 3
 *
I 3
 * 1. Get initial values for the checks and procedure:
 *      - read configuration file configuration.txt,
 *        get and set initial values;
 *      - check rationality of continuation.
 * 2. System setup:
 *      - turn ON (gas ON and power ON) all selected lasers
 *        to the point from where they can be easily enabled;
 *      - disable all lasers, only 1 laser will be enabled
 *        and used at an appropriate moment;
 *      - initialize masks and filters (set them to the CCW
 *        limits and nullify mask's and filter's motors);
 *      - set masks and filters speeds.
 * 3. System check:
 *      - get and check statuses for all the lasers;
 *      - get and check trigger bit setting;
 *      - get and check coda configuration;
 *      - get coda state;
 *      - check and return lasers ready status and coda state.
 * 4. Main execution:
 *      - main loop over all selected lasers;
 *      - inside laser_loop loop over all choosen mask
 *        positions selected in configuration.txt;
 *      - inside mask_loop for each mask positions activate
 *        n-times filter_loop, n get form configuration.txt;
 *      - for each step in mask_loop:
 *         . pause the run,
 *         . move mask at new position,
 *         . resume the run,
 *         . enable appropriate laser,
 *         . activate filter_loop n-times,
 *         . disable current laser.
 * 5. Shutdown:
 *      - close motor ports;
 *      - turn OFF all lasers.
E 3
 *
D 3
 *
 *
 *
 *******************************************************/
E 3
I 3
 */
E 3

D 3

/******
 * determines if the variables are defined or referenced   
 * by defining init varialbes are intialized in the .h files 
 ********/

E 3
I 3
D 6
/*
E 6
I 6

E 6
#define LASER_CODA_ENABLE 1
D 6
*/
E 6
I 6

E 6
E 3
#define INIT 1

D 3
#define BLABLA 1
E 3
I 3
#define TIMEOUT 600
E 3

#include <stdio.h>
D 3
#include <stdlib.h>
#include <string.h>
E 3
#include <time.h>
D 3
#include <sys/times.h>
#include <sys/param.h>
E 3
#include <stdlib.h>
D 3

E 3
I 3
#include <strings.h>
E 3
#include "laser.h"
#include "init_checks.h"
D 3
#include "flags.h"
E 3

I 3
extern int  chnlN[];
extern char *rocname[];
I 4
extern int  current_mpos[];
E 4

E 3
char prog_msg[1024]; /* message buffer; extern in subroutines */
D 3
int  nopairs = 0;
char status_id[100][50] = {"001","002","003"};
int  status_val[100];
E 3

D 3
/* prototype system commands */
int system(const char *string);
E 3

int
D 3
main (int argc, char *argv[])
{  
  /****** variables for general use */
  int i,j,k,l,m,n,n1,n2,nseq,laser,loop,laspnt;
E 3
I 3
main(int argc, char *argv[])
{
  time_t tp;
  int  tmpval;
  int  lsri, mski, fltri, i;
  int  step;
E 3
  
D 3
  /* for the ss sockets to tape routine BOSwrite */
  int tape_event_buffer[100];
  int no_of_events=0;
  char *tmpstr;
  int tmpval;
  int tape_id=0;

  /*   varialbes for the dp_cmd  command, returned buffer */
  char exename[111];
  char result[BUFFER_LENGTH];
  int success=1;
E 3
  
I 3
  /***********!!!!!!!!   Init, Setup and Check   !!!!!!!!***********/
E 3
  
D 3
  /***** control ************/
  int debug=0;
  
  
  /* 
     tp is the integer number of seconds since 1/1/1970 
     via program Thu Jun  4 10:57:38 1998 numerical time= 896972258
  */
  
  time_t tp;
  
  /**********************!!!!!!!!!! excecution !!!!!!!!!!!!!!!!!!!!*/

  /**************************get time *****************/
E 3
I 3
  /* Get time */
E 3
  tp=time(NULL);
D 3
  printf("start time= %s(seconds since 1970= %d)  \n\n ",ctime(&tp),tp);

  /**********  broadcast 1st status ************/
  tmpstr="TOF_laser";
  add_status(tmpstr,1);
  tmpstr="broadcast" ;
  tmpval=0;
  add_status(tmpstr,tmpval);
  tmpstr="flag_RT_broadcast" ;
  tmpval=0;
  add_status(tmpstr,tmpval);

  /*****************  get intial values for the checks and procedure:read donfiguration.txt **/
  tmpval=init_checks(debug);
  sprintf(prog_msg,"read file return status=%d\n",tmpval);
E 3
I 3
  sprintf(prog_msg,"\n TOF_laser \n\n Start time = %s \n", ctime(&tp));
E 3
  ss_prog(prog_msg);
D 3
  tmpstr="config_file_read" ;
  add_status(tmpstr,tmpval);
 
  /**************************** configurastion file read DONE *************/
  sprintf(prog_msg," Begin Intialization check \n");
E 3
I 3
  
  /* Get initial values for the checks and procedure:  */
  /* read configuration.txt                            */
  ss_prog("Read configuration.txt");
  tmpval = init_checks(debug_value);
  sprintf(prog_msg,"init_checks() return status = %d \n", tmpval);
E 3
  ss_prog(prog_msg);
  
D 3

  /****** first thing is to intialize the DP system  both setup_system and
       check_system  will initalize if flag (flag_clon10_init) is 0  *******/
E 3
I 3
  /* Check rationality of continuation */
  if(!use_laser[1] && !use_laser[2] && !use_laser[3] && !use_laser[4]) {
    ss_prog("All use_laser[i]=0,  Program stopped !!! \n");
    return(-1);
  }
E 3
  
D 3
  /* check status of the system lasers on ? , filters postioned .. ?. */
  tmpval=system_check(debug);
  sprintf(prog_msg,"do system check  status=%d\n",tmpval);
E 3
I 3
  /* Begin system setup */
  ss_prog("Begin system setup");
  tmpval = system_setup(debug_value);
  sprintf(prog_msg,"system_setup() return status = %d \n", tmpval);
E 3
  ss_prog(prog_msg);
I 3
  if(tmpval != 0) {
    ss_prog("Some error occurred. Fix problem and restart program. \n");
    return(-1);
  }
E 3
  
I 3
  /* Begin system check */
  ss_prog("Begin system check");
  tmpval=10;
  while(tmpval != 0) {
    printf(" wait a few second ");
    for(i=0; i<10; i++) { printf("."); fflush(stdout); sleep(1); }
    printf("\n");
    tmpval = system_check(debug_value);
    sprintf(prog_msg,"system_check() return status = %d \n", tmpval);
    ss_prog(prog_msg);
    if(tmpval < 0) {
      ss_prog("Some error occurred. Fix problem and restart program. \n");
      return(-1);
    }
    if((time(NULL) - tp) > TIMEOUT) {
      sprintf(prog_msg,"SYSTEM_CHECK_TIMEOUT of %d seconds passed.\n",TIMEOUT);
      ss_prog(prog_msg);
      ss_prog("TIMEOUT EXIT: System still not ready for Main Execution. \n");
      return(-1);
    }
  }
E 3
  
D 3
  /**************  start to setup and check system ***************/
  while(flag_all_seq_done == 0)
    {
      while(flag_someone_ready == 0)
	{
E 3
I 3
  
  /***********!!!!!!!!   Execution   !!!!!!!!***********/
  ss_prog("Main Execution");
E 3

D 3
	  /* set up the system lasers on, filters postioned ...*/
	  tmpval=system_setup(debug);
	  sprintf(prog_msg,"do system setup status=%d\n",tmpval);
	  ss_prog(prog_msg);
	  
	  
	  /* check status of the system lasers on ? , filters postioned .. ?. */
	  tmpval=system_check(debug);
	  sprintf(prog_msg,"do system check  status=%d\n",tmpval);
	  ss_prog(prog_msg);
	  
	  
	  /******* find the first ready laser ***** */
	  
	  j=0;
	  sprintf(prog_msg,"j=%d,flag==%d, seq no= %d \n",j,flag_someone_ready,seq_no);
	  if(debug)ss_prog(prog_msg);

	
	  while( (flag_someone_ready == 0) && (j < seq_no ))
	    {
	      sprintf(prog_msg,"j=%d,flag==%d\n",j,flag_someone_ready);
	      if(debug)ss_prog(prog_msg);
	      if(flag_seq_done[j] != 1 )
		{
		  n=seq_laser[j];
		  /*  enter 106 for debug to bypass lasers */
		  /* flag_someone_ready=evaluate_ready(n,106); */
		  flag_someone_ready=evaluate_ready(n,debug);  

		  if(flag_someone_ready) current_seq=j+1;
		  sprintf(prog_msg,"seq checked=%d,flag==%d\n",current_seq,flag_someone_ready);
		  if(debug)ss_prog(prog_msg);
		}
	      j++;
	    }
	  
	  
	  /*********** report progress  **********************/
	  sprintf(prog_msg," review the system \n\n");
	  ss_prog(prog_msg);
	  
	  flag_laser_all_ok=1;
	  flag_filter_all_ok=1;
	  j=0;
      while(j <= 3)
      {
        flag_laser_ok[j] = flag_laser_power[j] && flag_laser_ready[j] && flag_laser_gas[j];
        if(use_laser[j] == 0) flag_laser_ok[j]=1;
        flag_laser_all_ok=flag_laser_all_ok && flag_laser_ok[j];
        flag_filter_all_ok=flag_filter_all_ok && flag_filter[j];
        j++;
      }
	  /**** laser and fiter check done *****/

      flag_all_init = flag_clon10_init  && 
                      flag_camac3_ok    &&
                      flag_sc_laser1_ok && 
                      flag_coda_go      && 
                      flag_trigbit_ok   && 
                      flag_laser_all_ok &&
                      flag_config       &&
                      flag_filter_all_ok;


	  /***********   load status and broadcast ***************/
	  sprintf(prog_msg," broadcast status  \n\n");
	  ss_prog(prog_msg);

	  tmpval=update_all_status();
	  tmpval=general_progress();
	
	  /****************** sleep for time dterimend by file: few seconds *****************************/
	  sleep(interim); 
	} /* endo for one system ready flag_someone_ready  */
E 3
I 3
  for(lsri=1; lsri<=4; lsri++) {
    if(use_laser[lsri] == 1) {
E 3
      
D 3
      flag_someone_ready=0;  
      flag_error=0; /* reset the error flag */
E 3
I 3
      for(mski=0; mski<=seq_mask[lsri]; mski++) {
E 3

D 3
      /**********************************  start sequences   ***********/

      nseq=current_seq-1;  /* nseq points to the right variables in seq variables */
      laser=seq_laser[nseq];
      laspnt=laser-1;    /* indexing from 0 s0 0 is the index to first laser */
      loop=seq_loops[nseq];
      /************************** broadcast event to tape *********/

      pause_resume(10);
 

      
      sprintf(prog_msg," broadcast a event for tape before seq ");
      ss_prog(prog_msg);
      /******* send 1200 1100 event to the event stream ****/ 
      tp=time(NULL);
      tape_id=laser*100;
      tape_event_buffer[0]=tape_id;
      tape_event_buffer[1]=tp;
      tape_event_buffer[2]=current_seq;
      tape_event_buffer[3]=laser;
      
 
      tape_event_buffer[4]=tape_id+1;
      tape_event_buffer[5]=seq_filter[nseq];
      tape_event_buffer[6]=seq_speed[nseq];
      tape_event_buffer[7]=seq_loops[nseq];
      no_of_events=2;
      boswrite(tape_event_buffer,no_of_events);
      
      sprintf(prog_msg," broadcast a two event for tape ");
      ss_prog(prog_msg);
      
      /******************************************************/
      
      
      
      
      /******************************************************/
      
      /************** start  of sequ do   */
      sprintf(prog_msg," starting  seq=%d out of %d requested \n",nseq+1,seq_no);
      ss_prog(prog_msg);
      sprintf(prog_msg," laser=%d \n",seq_laser[nseq]);
      ss_prog(prog_msg);
      sprintf(prog_msg," filter=%d \n",seq_filter[nseq]);
      ss_prog(prog_msg);
      sprintf(prog_msg," speed=%d \n",seq_speed[nseq]);
      ss_prog(prog_msg);
      sprintf(prog_msg," number of loops=%d \n",seq_loops[nseq]);
      ss_prog(prog_msg);
      
      /**step 1******** laser enable   ****************************   */     
      /***  no special checking done here. Assume that the laser ect will be enabled
	    and that motor command will be executed.  If the computer crashes I assume
	    that the process will still complete okay
      ***/

      enable_laser(laser,debug);
      tmpval=update_all_status();
      for(i=0;i<loop;i++)
	{
	  /********************  execution motor _command ******************************/
	  flag_done[laspnt]=0;
	  flag_motor_moving[laspnt]=2;  /* fyi motor to do loop */
     
	  sprintf(tmpstr,"motor_moving_%d",laspnt+1); 
	  tmpval=flag_motor_moving[laspnt];
	  add_status(tmpstr,tmpval);
	  
	  sprintf(tmpstr,"done_%d",laspnt+1); 
	  tmpval=flag_done[laspnt];
	  add_status(tmpstr,tmpval);
      

	  ss_status();

#ifdef BLABLA

	  sprintf(exename,"exec loop_filter(%d)",laser);
	  if(laser == 1)
	    {      
              success=camac3cmd(exename);	
E 3
I 3
	ss_prog("  ---------------------------------------------");
	sprintf(prog_msg,"  main loop for laser#%d  mask's position = %d",
		lsri, seq_mpos[lsri][mski]);
	ss_prog(prog_msg);
E 3
	
D 3
	      if ( success != 0)
		{
		  sprintf(prog_msg,"return %d for success when trying to loop laser1 ",success);
		  ss_prog(prog_msg);   
		  /**********  execute a systems command    *********/
		  reboot("camac3",0);
		  flag_camac3_ok=0;
		  flag_error=1;
		  /************end of system request to reboot****************************/	           
		}
	    }
	  else
	    {
	      success=DP_cmd("sc-laser1",exename,result,111);
	      sprintf(prog_msg," sc_laser1 loop filter laser %d loop=%d \n",laser,i+1);
	      ss_prog(prog_msg);
	      if ( success != 0)
		{
		  sprintf(prog_msg,"unable to reach controller ");
		  ss_prog(prog_msg); 
		  /**********  execute a systems command    *********/
		  reboot("sc-laser1",0);
		  flag_sc_laser1_ok=0;
		  flag_error=1;
		  /************end of system request to reboot****************************/         
		}   
	    }
		
E 3
I 3
#ifdef LASER_CODA_ENABLE
	/* pause the run */
	if(coda_pause() == 0) {
	  if(debug_value) ss_prog("  run paused");
	}
	ELSE_Error("clastrig2");
E 3
#endif

D 3
	  get_motor_pos(laser,debug);
	  sprintf(prog_msg," 1st call flag  motor moving [%d]=%d \n",laspnt,flag_motor_moving[laspnt]);
	  ss_prog(prog_msg);
 

	  /******************/
	  /* if you have requested a loop and have no problem the the system will probably complete */
	  while(   (flag_motor_moving[laspnt] != 0)  &&  (flag_error == 0)    )
	    {
	      tmpval=get_motor_pos(laser,debug);
	      sprintf(prog_msg,"  found motor moving postion=%d",current_filter_position[laspnt]);
	      ss_prog(prog_msg);
	      sprintf(prog_msg,"  flag  motor moving [%d]=%d \n",laspnt,flag_motor_moving[laspnt]);
	      if(debug)ss_prog(prog_msg);
 
              tmpstr="     ";
	      sprintf(tmpstr,"current_filter_position_%d",laser); 
	      tmpval=current_filter_position[laspnt];
	      add_status(tmpstr,tmpval);
	      ss_status();
	      sleep(5);

	    }
E 3
I 3
	/* move mask at new position */
D 4
	if(mski == 0)
	  step = seq_mpos[lsri][0];
	else
	  step = seq_mpos[lsri][mski] - seq_mpos[lsri][mski-1];
E 4
I 4
	step = seq_mpos[lsri][mski] - current_mpos[lsri];
I 5
	/*
	printf("seq_mpos[lsri][mski] = %d;; \n", seq_mpos[lsri][mski]);
	printf("current_mpos[lsri]   = %d;; \n", current_mpos[lsri]);
	printf("step                 = %d;; \n", step);
	*/
E 5
E 4
	if(step != 0) {
	  ss_prog("  move mask at new position \n");
	  if(move_mask_ctrl(chnlN[lsri], step) < 0) {
	    ss_prog("\n Error: Can not set mask properly \n");
	    return(-1);
	  }
E 3
	}
D 3

      /******************************  end of laser enable  *****************/

      disable_laser(laser,debug);
      if(flag_error == 0) 
	{
	flag_seq_done[nseq]=1;
	tape_id=laser*100+10;
E 3
I 3
	
#ifdef LASER_CODA_ENABLE
	/* resume the run */
	if(coda_resume() == 0) {
	  if(debug_value) ss_prog("  run resumed");
E 3
	}
D 3
      else
	{
	  tape_id=laser*100+20;
	  sprintf(prog_msg," ****  error flag encountered  flag for seq=%d =%d ",nseq+1,flag_seq_done[nseq]); 
	  ss_prog(prog_msg); 
E 3
I 3
	ELSE_Error("clastrig2");
	
	/* enable laser */
	if(TOF_laser_enable(lsri) == 0) {
	  if(debug_value) {
	    sprintf(prog_msg,"  laser#%d enabled", lsri);
	    ss_prog(prog_msg);
	  }
E 3
	}
D 3
      flag_all_seq_done=1;
      for(l=0;l<seq_no;l++)
	{
	  flag_all_seq_done=flag_all_seq_done && flag_seq_done[l];
	  sprintf(prog_msg,"done flaf for seq=%d =%d ",l+1,flag_seq_done[l]); 
	  ss_prog(prog_msg); 
	}
     /************************** broadcast event to tape *********/

      pause_resume(10);
 
   
      sprintf(prog_msg," broadcast a event for tape before seq ");
      ss_prog(prog_msg);
      /******* send 1200 1100 event to the event stream ****/ 
      tp=time(NULL);
      tape_event_buffer[0]=tape_id;
      tape_event_buffer[1]=tp;
      tape_event_buffer[2]=current_seq;
      tape_event_buffer[3]=laser;
      
 
      tape_event_buffer[4]=tape_id+1;
      tape_event_buffer[5]=seq_filter[nseq];
      tape_event_buffer[6]=seq_speed[nseq];
      tape_event_buffer[7]=seq_loops[nseq];
      no_of_events=2;
      boswrite(tape_event_buffer,no_of_events);
      
      sprintf(prog_msg," broadcast a two event for tape ");
      ss_prog(prog_msg);
      
      /****** general broadcast of status *************************/
	      tmpval=update_all_status();
          ss_status();
     /*******************/

    }  /*end of sequence loop flag_all_seq_done */ 
  

      /****** general broadcast of status *************************/
	      tmpval=update_all_status();
          ss_status();
     /*******************/


  /*******************shutdown  *********/
  j=0;
while(j < 4)
{
  if(use_laser[j] == 0) 	 j++;  /* skip this laser */
  if(use_laser[j] == 0) 	 j++;  /* skip this laser */
  if(use_laser[j] == 0) 	 j++;  /* skip this laser */
  if(use_laser[j] == 0) 	 j++;  /* skip this laser */
  if(j > 3) break;

  /*******************************  turn of motor ports  *********************/
  sprintf(exename,"exec close_port(%d)",j+1);
  printf("%s \n",exename);
  if(j+1 == 1)
    {
      DP_cmd("camac3",exename,result,111); 
      if(debug) printf(" camac3 laser %d\n",j+1);
    }
  else
    {
      DP_cmd("sc-laser1",exename,result,111);
      if(debug)   printf(" sc-laser1 laser %d\n",j+1);
    }
  if(debug) printf("%s \n",result);
  /***************************  command end **************************/

  /* turn off the lasers ******************/
  sprintf(exename,"exec pwr(%d,0)",j+1);
  sprintf(prog_msg,"%s \n",exename);
  ss_prog(prog_msg);
  if(j == 0)
    {
      success = DP_cmd("camac3",exename,result,111);
    }
  else
    {
      success = DP_cmd("sc-laser1",exename,result,111);
    }
E 3
I 3
	ELSE_Error(rocname[lsri]);
#endif
E 3
	
D 3
  if ( success == 0)
    {
      sprintf(prog_msg," sucessful excecution \n buffer= %s \n",result); 
      ss_prog(prog_msg);
    }
  else
    {
      sprintf(prog_msg,"unable to reach controller "); 
      ss_prog(prog_msg);

      /**********  execute a systems command    *********/
      if(j == 0)
	{
	  reboot("camac3",0);
	  flag_camac3_ok=0;
E 3
I 3
	/* activate filter loop */
	for(fltri=1; fltri<=seq_floops[lsri]; fltri++) {
	  ss_prog("  =============");
	  sprintf(prog_msg,"  filter loop#%d \n", fltri);
	  ss_prog(prog_msg);
	  if(loop_filter_ctrl(chnlN[lsri]) != 0) {
	    ss_prog("\n Error: Can not loop filter properly \n");
	    return(-1);
	  }
E 3
	}
D 3
      else
	{
	  reboot("sc-laser1",0);
	  flag_sc_laser1_ok=0;
	}	   
E 3

D 3
    }
  /* turn off the gas ******************/
  sprintf(exename,"exec gas(%d,0)",j+1);
  sprintf(prog_msg,"%s \n",exename);
  ss_prog(prog_msg);
  if(j == 0)
    {
      success = DP_cmd("camac3",exename,result,111);
    }
  else
    {
      success = DP_cmd("sc-laser1",exename,result,111);
    }
E 3
I 3
	/* disable laser */
	if(TOF_laser_disable(lsri) == 0) {
	  if(debug_value) {
	    sprintf(prog_msg,"  laser#%d disabled", lsri);
	    ss_prog(prog_msg);
	  }
	}
	ELSE_Error(rocname[lsri]);
E 3
	
D 3
  if ( success == 0)
    {
      sprintf(prog_msg," sucessful excecution \n buffer= %s \n",result); 
      ss_prog(prog_msg);
    }
  else
    {
      sprintf(prog_msg,"unable to reach controller "); 
      ss_prog(prog_msg);
E 3
I 3
      } /* end of "for(mski=1; mski<=seq_mask[lsri]; mski++)" */
E 3

D 3
      /**********  execute a systems command    *********/
      if(j == 0)
	{
	  reboot("camac3",0);
	  flag_camac3_ok=0;
	}
      else
	{
	  reboot("sc-laser1",0);
	  flag_sc_laser1_ok=0;
	}	   

    }
  j++;
     /****** general broadcast of status *************************/
	      tmpval=update_all_status();
          ss_status();
     /*******************/

}
 


exit;
} 


/***************************************  routines ***************************************************/
int update_all_status()
{
  char *tmpstr;
  int tmpval;

  int j=0;

E 3
I 3
    } /* end of "if(use_laser[lsri] == 1)" */
  } /* end of "for(lsri=1; lsri<=4; lsri++)" */
  ss_prog("main execution done \n");
E 3
  
D 3
  tmpstr="flag_RT_broadcast" ;
  tmpval=0;
  add_status(tmpstr,tmpval);

E 3
  
D 3
  tmpstr="flag_all_init" ;
  tmpval=flag_all_init;
  add_status(tmpstr,tmpval);
E 3
I 3
  /***********!!!!!!!!   Shutdown   !!!!!!!!***********/
  ss_prog("Begin system shutdown");
E 3
  
D 3
  tmpstr="flag_clon10_init" ;
  tmpval=flag_clon10_init;
  add_status(tmpstr,tmpval);
  
  tmpstr="flag_config" ;
  tmpval=flag_config;
  add_status(tmpstr,tmpval);
  
  tmpstr="flag_coda_go" ;
  tmpval=flag_coda_go;
  add_status(tmpstr,tmpval);
  
  tmpstr="flag_camac3_ok" ;
  tmpval=flag_camac3_ok;
  add_status(tmpstr,tmpval);
  
  tmpstr="flag_rebooting_c3" ;
  tmpval=flag_rebooting_c3;
  add_status(tmpstr,tmpval);
  
  tmpstr="flag_sc_laser1_ok" ;
  tmpval=flag_sc_laser1_ok;
  add_status(tmpstr,tmpval);
  
  tmpstr="flag_rebooting_sc" ;
  tmpval=flag_rebooting_sc;
  add_status(tmpstr,tmpval);
  
  tmpstr="flag_trigbit_ok" ;
  tmpval=flag_trigbit_ok;
  add_status(tmpstr,tmpval);
  
  tmpstr="flag_someone_ready" ;
  tmpval=flag_someone_ready;
  add_status(tmpstr,tmpval);
  
  tmpstr="time_reboot_c3" ;
  tmpval=time_reboot_c3;
  add_status(tmpstr,tmpval);
  
  tmpstr="time_reboot_sc" ;
  tmpval=time_reboot_sc;
  add_status(tmpstr,tmpval);
  
  tmpstr="flag_filter_all_ok" ;
  tmpval=flag_filter_all_ok;
  add_status(tmpstr,tmpval);
  
  
  tmpstr="flag_setting" ;
  tmpval=flag_setting;
  add_status(tmpstr,tmpval);
  
  
  tmpstr="number_of_sequences" ;
  tmpval=seq_no;
  add_status(tmpstr,tmpval);
  
  tmpstr="current_sequence" ;
  tmpval=current_seq;
  add_status(tmpstr,tmpval);
  
  
  for(j=0;j<seq_no;j++) 
    {  

      tmpstr="     ";
      sprintf(tmpstr,"seq_laser_%d",j+1); 
      tmpval=seq_laser[j];
      add_status(tmpstr,tmpval);
      
      tmpstr="     ";
      sprintf(tmpstr,"seq_filter_%d",j+1); 
      tmpval=seq_filter[j];
      add_status(tmpstr,tmpval);
  

      sprintf(tmpstr,"seq_loops_%d",j+1); 
      tmpval=seq_loops[j];
      add_status(tmpstr,tmpval);


      sprintf(tmpstr,"seq_speed_%d",j+1); 
      tmpval=seq_speed[j];
      add_status(tmpstr,tmpval);

      sprintf(tmpstr,"seq_done_%d",j+1);   
      tmpval=flag_seq_done[j];
      add_status(tmpstr,tmpval);
    }
      
      
  for(j=0;j<4;j++)
    {
      tmpstr="     ";
      sprintf(tmpstr,"laser_power_%d",j+1); 
      tmpval=flag_laser_power[j];
      add_status(tmpstr,tmpval);
      
      sprintf(tmpstr,"laser_gas_%d",j+1); 
      tmpval=flag_laser_gas[j];
      add_status(tmpstr,tmpval);
      
      sprintf(tmpstr,"laser_ready_%d",j+1); 
      tmpval=flag_laser_ready[j];
      add_status(tmpstr,tmpval);
      
      sprintf(tmpstr,"laser_enable_%d",j+1); 
      tmpval=flag_laser_enable[j];
      add_status(tmpstr,tmpval);
      
      sprintf(tmpstr,"laser_ok_%d",j+1); 
      tmpval=flag_laser_ok[j];
      add_status(tmpstr,tmpval);
      
      sprintf(tmpstr,"port_open_%d",j+1); 
      tmpval=flag_port_open[j];
      add_status(tmpstr,tmpval);
      
      sprintf(tmpstr,"filter_%d",j+1); 
      tmpval=flag_filter[j];
      add_status(tmpstr,tmpval);
      
      sprintf(tmpstr,"current_filter_position_%d",j+1); 
      tmpval=current_filter_position[j];
      add_status(tmpstr,tmpval);
      
      sprintf(tmpstr,"CW_limit_%d",j+1); 
      tmpval=flag_CW_limit[j];
      add_status(tmpstr,tmpval);
      
      sprintf(tmpstr,"CCW_limit_%d",j+1); 
      tmpval=flag_CCW_limit[j];
      add_status(tmpstr,tmpval);
      
      sprintf(tmpstr,"motor_moving_%d",j+1); 
      tmpval=flag_motor_moving[j];
      add_status(tmpstr,tmpval);
      
      sprintf(tmpstr,"done_%d",j+1); 
      tmpval=flag_done[j];
      add_status(tmpstr,tmpval);
      
    }
  
  tmpstr="flag_laser_all_ok" ;
  tmpval=flag_laser_all_ok;
  add_status(tmpstr,tmpval);

  tmpstr="flag_filter_all_ok" ;
  tmpval=flag_filter_all_ok;
  add_status(tmpstr,tmpval);

  return(1);
}
  /************************  end status broadcast ***********/

int general_progress()
{
  char *tmpstr;
  int tmpval;
  int j=0;

  sprintf(prog_msg," \n end of intialization loop all ready= %d \n\n", flag_all_init);
E 3
I 3
  tmpval = system_shutdown(debug_value);
  sprintf(prog_msg,"system_shutdown() return status = %d \n", tmpval);
E 3
  ss_prog(prog_msg);
D 3
  sprintf(prog_msg," clon10      = %d ",flag_clon10_init);
  ss_prog(prog_msg);
  sprintf(prog_msg," camac3      = %d ",flag_camac3_ok);
  ss_prog(prog_msg);
  sprintf(prog_msg," sc_laser1     = %d ",flag_sc_laser1_ok);
  ss_prog(prog_msg);
  sprintf(prog_msg," coda st ok  = %d ",flag_coda_go);
  ss_prog(prog_msg);
  sprintf(prog_msg," trigger bit = %d \n",flag_trigbit_ok);
  ss_prog(prog_msg);
  j=0;
  while(j <= 3)
  {
    sprintf(prog_msg," laser%d = %d ",j+1,flag_laser_ok[j]);
    ss_prog(prog_msg);
    j++;
E 3
I 3
  if(tmpval != 0) {
    ss_prog("Some error occurred. Do shutdown manually. \n");
    return(-1);
E 3
  }
D 3
  sprintf(prog_msg," all lasers  = %d \n",flag_laser_all_ok);
  ss_prog(prog_msg);
  sprintf(prog_msg," config      = %d \n",flag_config);
  ss_prog(prog_msg);
  j=0;
  while(j <= 3)
  {
    sprintf(prog_msg," laser%d filter = %d ",j+1,flag_filter[j]);
    ss_prog(prog_msg);
    j++;
  }
  sprintf(prog_msg," filter      = %d \n",flag_filter_all_ok);
  ss_prog(prog_msg);
  /*****
    sprintf(prog_msg," pulser      = %d \n",flag_pulser_ready);
    ss_prog(prog_msg);
  *****/
  sprintf(prog_msg,"current seq =%d,someonerdyflag==%d, no of seq req=%d\n",current_seq,flag_someone_ready,seq_no);
  ss_prog(prog_msg);
E 3
  
D 3
  return(1);
}
E 3
  
D 3


int pause_resume(int time)
{
  char *tmpstr;
  int tmpval;
  
  int j=0;

  /*   varialbes for the dp_cmd  command, returned buffer */
  char exename[111];
  char result[BUFFER_LENGTH];
  int success=1;
  
  /* **************** for sync  pause run */
  sprintf(exename,"exec pause_run");
  sprintf(prog_msg,"%s \n",exename);
  ss_prog(prog_msg);
  success = DP_cmd("clastrig2",exename,result,111);
  if ( success == 0)
    {
      sprintf(prog_msg," sucessful excecution \n buffer= %s \n",result); 
      ss_prog(prog_msg);
    }
  else
    {
      sprintf(prog_msg,"unable to reach controller "); 
      ss_prog(prog_msg);
    }
  sleep(time);
  /*****   resume run *******/
  sprintf(exename,"exec resume_run");
  sprintf(prog_msg,"%s \n",exename);
  ss_prog(prog_msg);
  success = DP_cmd("clastrig2",exename,result,111);
  if ( success == 0)
    {
      sprintf(prog_msg," sucessful excecution \n buffer= %s \n",result); 
      ss_prog(prog_msg);
    }
  else
    {
      sprintf(prog_msg,"unable to reach controller "); 
      ss_prog(prog_msg);
    }
  /***************************************/
  
  return(1);
E 3
I 3
  return(0);
E 3
}

D 3






int camac3cmd(char* cmd)
{

  /*   varialbes for the dp_cmd  command, returned buffer */
  char exename[111];
  char result[BUFFER_LENGTH];
  int success=1;
  

 
  sprintf(prog_msg,"%s \n",cmd);
  ss_prog(prog_msg);
  success = DP_cmd("camac3",cmd,result,111);
  if ( success == 0)
    {
      sprintf(prog_msg," sucessful excecution \n buffer= %s \n",result); 
      ss_prog(prog_msg);
    }
  else
    {
      sprintf(prog_msg,"unable to reach controller \n buffer=%s \n ",result); 
      ss_prog(prog_msg);
    }

  
  return(success);
}


int sclaser1cmd(char* cmd)
{

  /*   varialbes for the dp_cmd  command, returned buffer */
  char exename[111];
  char result[BUFFER_LENGTH];
  int success=1;
  

 
  sprintf(prog_msg,"%s \n",cmd);
  ss_prog(prog_msg);
  success = DP_cmd("sc-laser1",cmd,result,111);
  if ( success == 0)
    {
      sprintf(prog_msg," sucessful excecution \n buffer= %s \n",result); 
      ss_prog(prog_msg);
    }
  else
    {
      sprintf(prog_msg,"unable to reach controller \n buffer=%s \n ",result); 
      ss_prog(prog_msg);
    }

  
  return(success);
}
E 3
E 1
