h27065
s 00005/00003/01266
d D 1.53 07/10/12 10:16:49 boiarino 56 55
c *** empty log message ***
e
s 00002/00002/01267
d D 1.52 06/11/28 15:06:13 boiarino 55 54
c *** empty log message ***
e
s 00001/00001/01268
d D 1.51 06/11/28 00:37:27 boiarino 54 53
c *** empty log message ***
e
s 00027/00011/01242
d D 1.50 06/11/28 00:32:15 boiarino 53 52
c *** empty log message ***
e
s 00019/00004/01234
d D 1.49 06/11/27 12:36:48 boiarino 52 51
c *** empty log message ***
e
s 00000/00000/01238
d D 1.48 06/11/12 00:15:49 boiarino 51 50
c nothing
c 
e
s 00008/00005/01230
d D 1.47 05/12/05 12:54:22 wolin 50 49
c Removed scaler time check since it has been changing
e
s 00020/00015/01215
d D 1.46 03/04/22 15:58:56 wolin 49 48
c Switched to timeline_put
e
s 00036/00036/01194
d D 1.45 02/10/28 15:33:08 wolin 48 47
c diskcheck working, did not do anything, evmon still not working
e
s 00002/00002/01228
d D 1.44 02/01/28 16:03:12 wolin 47 46
c Typo filling evstatmon_names 
e
s 00014/00003/01216
d D 1.43 02/01/18 13:25:42 wolin 46 45
c Added new DC region channels
e
s 00008/00002/01211
d D 1.42 01/11/30 14:33:33 wolin 45 44
c Added min_evt to evstatmon
e
s 00031/00015/01182
d D 1.41 01/11/13 12:22:37 wolin 44 43
c Reverting to old scaler scheme...change was a mistake
e
s 00001/00001/01196
d D 1.40 01/11/13 11:48:08 wolin 43 42
c scaler, not scaler_timeline
e
s 00016/00032/01181
d D 1.39 01/11/13 11:43:20 wolin 42 41
c Scaler update set in info_server.cfg
e
s 00008/00001/01205
d D 1.38 01/11/08 12:06:06 wolin 41 40
c Added live_or,live_random
e
s 00002/00002/01204
d D 1.37 01/10/29 14:50:41 wolin 40 39
c Only 6 ec scalers per sector
e
s 00001/00001/01205
d D 1.36 01/10/15 16:00:51 wolin 39 38
c Bug looping over fields in generic message
e
s 00003/00003/01203
d D 1.35 01/10/12 09:25:55 wolin 38 37
c types[] must be in same order as callback arg
e
s 00000/00072/01206
d D 1.34 01/10/11 16:06:54 wolin 37 36
c Removed epics callbacks
e
s 00094/00035/01184
d D 1.33 01/10/11 16:00:41 wolin 36 35
c Added generic callback
e
s 00030/00020/01189
d D 1.32 01/06/04 11:43:30 wolin 35 34
c Added 2 new raids, rearranged order of diskcheck message
e
s 00129/00030/01080
d D 1.31 00/11/21 10:48:10 wolin 34 33
c eb and ts status entered into epics variables
e
s 00068/00077/01042
d D 1.30 00/11/13 11:04:10 wolin 33 30
i 32
c Accepted child's version in workspace "/usr/local/clas/devel/source".
c 
e
s 00011/00003/01099
d D 1.28.1.2 00/11/13 11:03:30 wolin 32 31
c Added clock_rate
e
s 00068/00068/01034
d D 1.28.1.1 00/10/26 14:26:00 wolin 31 29
c const
e
s 00011/00003/01099
d D 1.29 00/11/09 14:30:01 wolin 30 29
c Clock rate now 100000, other minor mods
e
s 00009/00008/01093
d D 1.28 00/10/19 14:05:58 wolin 29 28
c Added mon_rate
e
s 00011/00013/01090
d D 1.27 00/10/19 10:48:52 wolin 28 27
c For et2et
e
s 00001/00001/01102
d D 1.26 00/03/01 12:08:37 wolin 27 26
c Typo
e
s 00009/00008/01094
d D 1.25 00/02/29 10:55:07 wolin 26 25
c Added l2_or, l2_ok
e
s 00063/00001/01039
d D 1.24 00/02/24 17:35:21 wolin 25 24
c Added trigmon
e
s 00038/00010/01002
d D 1.23 00/02/24 13:50:14 wolin 24 23
c Typos
e
s 00002/00002/01010
d D 1.22 00/02/14 15:32:39 wolin 23 22
c Typos
e
s 00064/00002/00948
d D 1.21 00/02/14 14:45:19 wolin 22 21
c Added alarm_checker
e
s 00006/00006/00944
d D 1.20 00/02/11 15:56:19 wolin 21 20
c l1,l2 error hist now working
e
s 00012/00005/00938
d D 1.19 00/02/11 15:13:54 wolin 20 19
c Added l1,l2 error plots
e
s 00001/00001/00942
d D 1.18 00/02/11 13:44:59 wolin 19 18
c Rates finally working
e
s 00014/00010/00929
d D 1.17 00/02/11 13:27:53 wolin 18 17
c Plotting all evt rates
e
s 00021/00012/00918
d D 1.16 00/02/11 13:03:28 wolin 17 16
c Added scaler and trigmon rates
e
s 00078/00021/00852
d D 1.15 00/02/10 13:40:07 wolin 16 15
c Scalers working, still need to add a few hist
e
s 00003/00004/00870
d D 1.14 00/02/07 11:13:00 wolin 15 14
c Added check on scaler deltat 9 to 11 secs to avoid nonsense entries
e
s 00019/00020/00855
d D 1.13 00/02/04 12:38:53 wolin 14 13
c event_monitor and scaler_server seem to be working
e
s 00017/00006/00858
d D 1.12 00/01/28 15:42:52 wolin 13 12
c Added clonfs and clon00,clon10 local disks to diskcheck
e
s 00044/00016/00820
d D 1.11 00/01/27 15:51:08 wolin 12 11
c Added scalers, still need to test evmon
e
s 00015/00010/00821
d D 1.10 00/01/24 14:40:44 wolin 11 10
c Finally got systats working
e
s 00430/00122/00401
d D 1.9 00/01/24 12:54:39 wolin 10 9
c Added systats
e
s 00029/00008/00494
d D 1.8 99/11/17 17:00:35 wolin 9 8
c diskcheck now working
e
s 00091/00016/00411
d D 1.7 99/11/15 17:13:36 wolin 8 7
c Added diskcheck
e
s 00003/00018/00424
d D 1.6 99/11/05 15:18:13 wolin 7 6
c Minor cleanup
e
s 00010/00006/00432
d D 1.5 99/11/05 12:31:15 wolin 6 5
c Added daq_rate check
e
s 00076/00008/00362
d D 1.4 99/11/05 12:24:17 wolin 5 4
c Added evtstatmon rates
e
s 00083/00020/00287
d D 1.3 99/11/05 11:33:37 wolin 4 3
c Now making evstatmon entries
e
s 00023/00006/00284
d D 1.2 99/06/08 15:34:59 wolin 3 1
c Just need to fill in timeline entries
c 
e
s 00000/00000/00000
d R 1.2 99/05/26 15:01:18 Codemgr 2 1
c SunPro Code Manager data about conflicts, renames, etc...
c Name history : 1 0 dbutil/s/ipc2timeline.cc
e
s 00290/00000/00000
d D 1.1 99/05/26 15:01:17 wolin 1 0
c 
e
u
U
f e 0
t
T
I 1
//  ipc2timeline
//
//  fills timeline hist with info server data
I 34
D 37
//  also fills epics records with ipc data (to interface to Arne's stuff)
E 37
E 34
I 10
//   
//  Still to do:
D 12
//     scaler
//     systats
E 12
I 12
D 16
//     test event_monitor and scalers
E 16
I 16
D 17
//     why negative trgd, other bizarre values
E 17
E 16
E 12
E 10
//
I 3
D 8
//  still to do:
D 4
//    subscribe to proper subject
E 4
//    make timeline entries
//
E 3
D 5
//  ejw, 26-may-99
E 5
I 5
//  ejw, 5-nov-99
E 8
I 8
D 10
//  ejw, 10-nov-99
E 10
I 10
D 12
//  ejw, 21-jan-00
E 12
I 12
D 17
//  ejw, 26-jan-2000
E 17
I 17
D 24
//  ejw, 11-feb-2000
E 24
I 24
D 34
//  ejw, 21-feb-2000
E 34
I 34
D 36
//  ejw, 20-nov-2000
E 36
I 36
//  ejw, 11-oct-2001
E 36
E 34
E 24
E 17
E 12
E 10
E 8
E 5


// for posix
#define _POSIX_SOURCE_ 1
#define __EXTENSIONS__


// for smartsockets
#include <rtworks/cxxipc.hxx>


// system
#include <fstream.h>
#include <iomanip.h>
I 10
D 56
#include <macros.h>
E 56
E 10
I 4
D 7
#include <time.h>
#include <sys/types.h>
E 7
E 4


// for tcl
extern "C" {
#include <tcl.h>
Tcl_Interp *tclinterp_init(void);
void tclipc_init(Tcl_Interp *interp);
}


// for CLAS ipc
#include <clas_ipc_prototypes.h>
I 4


//  for timeline
extern "C" {
E 4
I 3
#include <timeline.h>
I 4
}
E 4
E 3

I 56
#define MIN(a,b)  ( (a) < (b) ? (a) : (b) )
#define MAX(a,b)  ( (a) > (b) ? (a) : (b) )
E 56

I 56

E 56
// misc variables
D 8
static char *application      = "clastest";
E 8
I 8
D 31
D 33
static char *project          = "clastest";
static char *session          = "clasprod";
E 8
static char *unique_id        = "ipc2timeline";
I 8
static char *msql_database    = "clasrun";
E 33
I 33
static char *project          = (char*)"clastest";
static char *session          = (char*)"clasprod";
static char *unique_id        = (char*)"ipc2timeline";
static char *msql_database    = (char*)"clasrun";
E 33
E 31
I 31
static char *project          = (char*)"clastest";
static char *session          = (char*)"clasprod";
static char *unique_id        = (char*)"ipc2timeline";
static char *msql_database    = (char*)"clasrun";
E 31
E 8
D 53
static Tcl_Interp *interp;  
E 53
I 53
static Tcl_Interp *interp;
E 53
static char *init_tcl_script  = NULL;
I 30
static int clock_rate         = 100000;
I 45
static int min_evt            = 1000;
I 49
D 53
static int min_rate           = 100;
E 53
I 53
D 54
static int min_rate           = 2;
E 54
I 54
static int min_rate           = 100;
E 54
E 53
E 49
E 45
E 30
I 32
D 33
static int clock_rate         = 100000;
E 33
E 32
D 10
static int nmsg               = 0;
I 5
static int nentry             = 0;
E 10
E 5
I 3
D 4
static int ntimeline          = 0;
E 4
E 3
static int done               = 0;
I 10
static int no_timeline        = 0;
E 10
static int debug              = 0;
static char temp[512];


I 10
D 38
// stats
D 31
D 33
static char *types[] = {"evstatmon","evtstatus","diskcheck","evmon","scaler","systats00",
D 23
			"systats10"};
E 23
I 23
D 25
			"systats10","alarm"};
E 25
I 25
			"systats10","alarm","trigmon"};
E 33
I 33
static const char *types[] = {"evstatmon","evtstatus","diskcheck","evmon","scaler","systats00",
D 34
			      "systats10","alarm","trigmon"};
E 34
I 34
D 36
			      "systats10","alarm","trigmon","eber","ts"};
E 36
I 36
			      "systats10","alarm","trigmon","eber","ts","generic"};
E 38
I 38
// stats...types MUST be in same order as callback arg
static const char *types[] = {"generic","evstatmon","evtstatus","diskcheck","evmon","scaler","systats00",
			      "systats10","alarm","trigmon"};
E 38
E 36
E 34
E 33
E 31
I 31
static const char *types[] = {"evstatmon","evtstatus","diskcheck","evmon","scaler","systats00",
			      "systats10","alarm","trigmon"};
E 31
E 25
E 23
static int nmsgtot=0;
static int nentrytot=0;
static int nmsg[sizeof(types)/sizeof(char*)];
static int nentry[sizeof(types)/sizeof(char*)];
static int ntype = sizeof(types)/sizeof(char*);


E 10
I 4
D 5
// timeline stuff
E 5
I 5
D 7
// evstatmon timeline stuff
E 7
I 7
// evstatmon
E 7
E 5
D 31
D 33
static char *snam[6] = {"s1","s2","s3","s4","s5","s6"};
static char *dnam[5] = {"dc","ec","sc","cc","ec1"};
E 33
I 33
static const char *snam[6] = {"s1","s2","s3","s4","s5","s6"};
static const char *dnam[5] = {"dc","ec","sc","cc","ec1"};
E 33
E 31
I 31
static const char *snam[6] = {"s1","s2","s3","s4","s5","s6"};
static const char *dnam[5] = {"dc","ec","sc","cc","ec1"};
E 31
D 5
static char *evstatmon_names[60+2];
static float evstatmon_vals[60+2];
static int last_evstatmon=0;
E 5
I 5
D 46
static int nevstatmon      = 62;
static char *evstatmon_names[62];
D 8
static float  evstatmon_vals[62];
E 8
I 8
static float evstatmon_vals[62];
E 46
I 46
D 47
static const char *rnam[3] = {"r1","r2","r2"};
E 47
I 47
static const char *rnam[3] = {"r1","r2","r3"};
E 47
static int nevstatmon      = 80;
static char *evstatmon_names[80];
static float evstatmon_vals[80];
E 46
E 8
D 7
static int last_evstatmon  = 0;
E 7


D 7
// evtstatus timeline stuff
E 7
I 7
// evtstatus
E 7
D 17
static char *evtstatus_names[] = {"daq_rate","mon_rate","evtstatmon_rate","evmon_rate","recsis_rate"};
E 17
I 17
D 31
D 33
static char *evtstatus_names[] = {
E 33
I 33
static const char *evtstatus_names[] = {
E 33
E 31
I 31
static const char *evtstatus_names[] = {
E 31
D 18
    "daq_rate","mon_rate","evtstatmon_rate","scaler_rate","evmon_rate","recsis_rate",
    "trigmon_rate"

E 18
I 18
D 28
    "daq_rate",
    "mon_rate","ipcbank_rate","ptp2et_rate","evtstatmon_rate",
E 28
I 28
D 29
    "daq_rate","et2et_rate",
E 29
I 29
    "daq_rate","et2et_rate","mon_rate",
E 29
    "ipcbank_rate","evtstatmon_rate",
E 28
D 48
    "scaler_rate","evmon_rate","recsis_rate","trigmon_rate"
E 48
I 48
    "scaler_rate","evmon_rate","recsis_rate"
E 48
E 18
};
E 17
static float evtstatus_vals[sizeof(evtstatus_names)/sizeof(char*)];
static int nevtstatus          = sizeof(evtstatus_names)/sizeof(char*);
D 7
static int last_evtstatus      = 0;
E 7
E 5

E 4

I 8
// diskcheck
D 9
static char *diskcheck_names[] = {"active_count","empty_count","backed_up_count",
				  "not_backed_up_count","moving_count","active_free"};
static int diskcheck_vals[sizeof(diskcheck_names)/sizeof(char*)];
E 9
I 9
D 31
D 33
static char *diskcheck_names[] = {
E 33
I 33
static const char *diskcheck_names[] = {
E 33
E 31
I 31
static const char *diskcheck_names[] = {
E 31
D 13
    "RAID0_status","RAID1_status","RAID2_status","RAID3_status","RAID4_status","RAID5_status",
    "active_count","empty_count","backed_up_count","not_backed_up_count","moving_count",
    "active_free"};
E 13
I 13
D 35
  "RAID0_status","RAID1_status","RAID2_status","RAID3_status","RAID4_status","RAID5_status",
  "active_count","empty_count","backed_up_count","not_backed_up_count","moving_count","active_free",
E 35
D 48
  "clon00_slash","clon00_usr","clon00_tmp",
  "clon10_slash","clon10_usr","clon10_tmp",
E 48
I 48
  "clon00_slash","clon00_tmp",
  "clon10_slash","clon10_tmp",
E 48
D 35
  "ssa","home","usr_local","opt","apps","work","www","var_mail","usr_clas_msql",     
  "usr_clas_cmlog","usr_clas_archives","mnt_admin_clonfs","mnt_admin_hpdb"
E 35
I 35
  "ssa","home","usr_local","opt","apps",
D 48
  "work","www","var_mail","usr_clas_msql","usr_clas_cmlog",
E 48
I 48
  "work","var_mail","usr_clas_msql","usr_clas_cmlog",
E 48
  "usr_clas_archives","mnt_admin_clonfs","mnt_admin_hpdb",
D 48
  "active_count","empty_count","backed_up_count","not_backed_up_count","moving_count","active_free",
E 48
I 48
  "active_count","empty_count","backed_up_count","not_backed_up_count","moving_count",
  "active_free",
E 48
  "RAID0_status","RAID1_status","RAID2_status","RAID3_status",
D 48
  "RAID4_status","RAID5_status","RAID6_status","RAID7_status",
E 48
I 48
  "RAID4_status","RAID5_status","RAID6_status","RAID7_status"
E 48
E 35
};
E 13
static float diskcheck_vals[sizeof(diskcheck_names)/sizeof(char*)];
E 9
static int ndiskcheck = sizeof(diskcheck_names)/sizeof(char*);


I 10
// evmon
D 31
D 33
static char *evmon_group="evmon_trig";
static char *evmon_evt_name="evt_wds";
static char *evmon_names[7][7] = {
E 33
I 33
static const char *evmon_group="evmon_trig";
static const char *evmon_evt_name="evt_wds";
static const char *evmon_names[7][7] = {
E 33
E 31
I 31
static const char *evmon_group="evmon_trig";
static const char *evmon_evt_name="evt_wds";
static const char *evmon_names[7][7] = {
E 31
  "tot_wds"   ,"sc_wds"   ,"ec_wds"   ,"cc_wds"   ,"dc_wds"   ,"lac_wds"   ,"tg_wds",
  "tot_wds_s1","sc_wds_s1","ec_wds_s1","cc_wds_s1","dc_wds_s1","lac_wds_s1","tg_wds_s1",
  "tot_wds_s2","sc_wds_s2","ec_wds_s2","cc_wds_s2","dc_wds_s2","lac_wds_s2","tg_wds_s2",
  "tot_wds_s3","sc_wds_s3","ec_wds_s3","cc_wds_s3","dc_wds_s3","lac_wds_s3","tg_wds_s3",
  "tot_wds_s4","sc_wds_s4","ec_wds_s4","cc_wds_s4","dc_wds_s4","lac_wds_s4","tg_wds_s4",
  "tot_wds_s5","sc_wds_s5","ec_wds_s5","cc_wds_s5","dc_wds_s5","lac_wds_s5","tg_wds_s5",
  "tot_wds_s6","sc_wds_s6","ec_wds_s6","cc_wds_s6","dc_wds_s6","lac_wds_s6","tg_wds_s6"
};


// scaler
I 44
D 48
static int scaler_update = 60;  // seconds
static last_scaler       = 0;
E 48
I 48
static time_t scaler_update  = 60;  // seconds
static time_t last_scaler    = 0;
E 48
E 44
D 42
static int scaler_update = 60;  // seconds
static last_scaler       = 0;
E 42
I 12
D 31
D 33
static char *scaler_names[] = {
E 33
I 33
static const char *scaler_names[] = {
E 33
E 31
I 31
static const char *scaler_names[] = {
E 31
  "trig1_ug","trig2_ug","trig3_ug","trig4_ug","trig5_ug","trig6_ug",
  "trig7_ug","trig8_ug","trig9_ug","trig10_ug","trig11_ug","trig12_ug",
  "trig_or_ug","l1accept","l2fail","l2pass","l2start","l2clear",
D 16
  "l2accept","l3accept"
E 16
I 16
  "l2accept","l3accept",
  "live_clock","live_fcup","live_trig","fcup_int","fcup_diff",
  "ec_sec1","ec_sec2","ec_sec3","ec_sec4","ec_sec5","ec_sec6",
  "sc_sec1","sc_sec2","sc_sec3","sc_sec4","sc_sec5","sc_sec6",
I 20
  "latch1_state_err","latch2_state_err",
D 24
  "l2spf","l2fcl","l2apl","l2acc_l3acc"
E 24
I 24
  "l2spf","l2fcl","l2apl","l2acc_l3acc",
D 26
  "l2_s1","l2_s2","l2_s3","l2_s4","l2_s5","l2_s6",
E 26
I 26
  "l2_s1","l2_s2","l2_s3","l2_s4","l2_s5","l2_s6","l2_or","l2_ok",
E 26
  "s1l1_b1","s1l1_b2","s1l1_b3","s1l1_b4","s1l1_b5","s1l1_b6",
  "s1l1_b7","s1l1_b8","s1l1_b9","s1l1_b10","s1l1_b11","s1l1_b12",
  "s1l1_rate",
  "s1l2_s1","s1l2_s2","s1l2_s3","s1l2_s4","s1l2_s5","s1l2_s6",
D 41
  "s1l2_pass","s1l2_fail"
E 41
I 41
  "s1l2_pass","s1l2_fail",
  "live_or","live_random"
E 41
D 26

E 26
E 24
E 20
E 16
};
D 16

E 16
I 16
D 20
//  "l1_error","l2_error"
E 20
I 20
D 22
//  "l1_errors","l2_errors"
E 20
E 16

E 22
static float scaler_vals[sizeof(scaler_names)/sizeof(char*)];
static int nscaler = sizeof(scaler_names)/sizeof(char*);
E 12


// systats
D 11
static int ncpu00 	   = 4;
static int ncpu10 	   = 6;     
E 11
I 11
static int ncpu00 	   = 6;
D 49
static int ncpu10 	   = 4;     
E 49
I 49
static int ncpu10 	   = 4;
E 49
E 11
D 31
D 33
static char *systats_names[] = {
E 33
I 33
static const char *systats_names[] = {
E 33
E 31
I 31
static const char *systats_names[] = {
E 31
    "temp_free","swap_free","net_in","net_in_err","net_out","net_out_err",
    "net_collision","mem_free","cpu_idle_avg",
D 11
    "cpu_idle0","cpu_idle1","cpu_idle2","cpu_idle3","cpu_idle4","cpu_idle5","cpu_idle6"
E 11
I 11
    "cpu_idle0","cpu_idle1","cpu_idle2","cpu_idle3","cpu_idle4","cpu_idle5"
E 11
};
static float systats_vals[sizeof(systats_names)/sizeof(char*)];
D 56
static int nsystats = sizeof(systats_names)/sizeof(char*)-max(ncpu10,ncpu00);
E 56
I 56
static int nsystats = sizeof(systats_names)/sizeof(char*)-MAX(ncpu10,ncpu00);
E 56
E 10

E 8
D 10
// prototypes
void decode_command_line(int argc, char **argv);
void init_tcl();
void init_timeline();
E 10
I 10

I 22
// alarm_checker
D 31
D 33
static char *alarm_names[] = {
E 33
I 33
static const char *alarm_names[] = {
E 33
E 31
I 31
static const char *alarm_names[] = {
E 31
    "alarm_count"
};
static float alarm_vals[sizeof(alarm_names)/sizeof(char*)];
static int nalarm= sizeof(alarm_names)/sizeof(char*);



I 25
// trigmon
D 31
D 33
static char *trigmon_names[] = {
E 33
I 33
static const char *trigmon_names[] = {
E 33
E 31
I 31
static const char *trigmon_names[] = {
E 31
    "s1_l2effic","s2_l2effic","s3_l2effic","s4_l2effic","s5_l2effic","s6_l2effic"
};
static float trigmon_vals[sizeof(trigmon_names)/sizeof(char*)];
static int ntrigmon= sizeof(trigmon_names)/sizeof(char*);


D 34

E 34
E 25
E 22
D 12

E 12
// subject callback prototypes
I 36
void generic_callback(T_IPC_CONN,
		      T_IPC_CONN_PROCESS_CB_DATA,
		      T_CB_ARG);
E 36
E 10
D 4
void info_server_callback(T_IPC_CONN,
			  T_IPC_CONN_PROCESS_CB_DATA,
			  T_CB_ARG);
E 4
I 4
void evstatmon_callback(T_IPC_CONN,
			T_IPC_CONN_PROCESS_CB_DATA,
			T_CB_ARG);
I 5
void evtstatus_callback(T_IPC_CONN,
			T_IPC_CONN_PROCESS_CB_DATA,
			T_CB_ARG);
I 8
void diskcheck_callback(T_IPC_CONN,
			T_IPC_CONN_PROCESS_CB_DATA,
			T_CB_ARG);
I 10
void evmon_callback(T_IPC_CONN,
		    T_IPC_CONN_PROCESS_CB_DATA,
		    T_CB_ARG);
void scaler_callback(T_IPC_CONN,
		     T_IPC_CONN_PROCESS_CB_DATA,
		     T_CB_ARG);
void systats_callback(T_IPC_CONN,
		      T_IPC_CONN_PROCESS_CB_DATA,
		      T_CB_ARG);
I 22
void alarm_callback(T_IPC_CONN,
		    T_IPC_CONN_PROCESS_CB_DATA,
		    T_CB_ARG);
I 25
void trigmon_callback(T_IPC_CONN,
		      T_IPC_CONN_PROCESS_CB_DATA,
		      T_CB_ARG);
I 34
D 37
void epics_callback(T_IPC_CONN,
		    T_IPC_CONN_PROCESS_CB_DATA,
		    T_CB_ARG);
E 37
E 34
E 25
E 22


// prototypes
void decode_command_line(int argc, char **argv);
void init_tcl();
I 34
void create_callbacks();
E 34
void init_timeline();
I 33
extern "C" {
E 33
I 31
extern "C" {
E 31
E 10
E 8
E 5
E 4
void quit_callback(int sig);
void status_poll_callback(T_IPC_MSG msg);
int tcl_help(ClientData clientdata, Tcl_Interp *interp, 
		int argc, char **argv);
int tcl_quit(ClientData clientdata, Tcl_Interp *interp, 
		int argc, char **argv);
D 31
D 33
extern "C" {
I 8
int get_run_number(char *msql_database, char *session);
E 8
int insert_msg(char *name, char *facility, char *process, char *msgclass, 
D 4
	      int severity, char *msgstatus, int code, char *text);
E 4
I 4
	       int severity, char *msgstatus, int code, char *text);
E 33
I 33
int get_run_number(const char *msql_database, const char *session);
I 34
D 37
void put_epics_ca_d(const char *chan, const char *attrib, double d);
void put_epics_ca_l(const char *chan, const char *attrib, long l);
E 37
E 34
int insert_msg(const char *name, const char *facility, const char *process, const char *msgclass, 
	       int severity, const char *msgstatus, int code, const char *text);
E 33
E 31
I 31
int get_run_number(const char *msql_database, const char *session);
int insert_msg(const char *name, const char *facility, const char *process, const char *msgclass, 
	       int severity, const char *msgstatus, int code, const char *text);
E 31
E 4
}	


// ref to IPC server (connection created later)
TipcSrv &server=TipcSrv::Instance();


//--------------------------------------------------------------------------


main(int argc,char **argv) {

  int status;


  // synch with c i/o
  ios::sync_with_stdio();


  // decode command line flags
  decode_command_line(argc,argv);


  // get Tcl interp, create tcl commands, link vars, process Tcl startup script, etc.
  interp=tclinterp_init();
  init_tcl();
  if(init_tcl_script!=NULL)Tcl_EvalFile(interp,init_tcl_script);


  // set ipc parameters and connect to ipc system
D 8
  ipc_set_application(application);
E 8
I 8
  ipc_set_application(project);
E 8
  ipc_set_user_status_poll_callback(status_poll_callback);
  ipc_set_quit_callback(quit_callback);
D 8
  status=ipc_init(unique_id,"ipc2timeline");
E 8
I 8
  status=ipc_init(unique_id,"ipc to timeline hist");
E 8
  if(status<0) {
    cerr << "\n?Unable to connect to server...probably duplicate unique id\n"
	 << "   ...check for another ipc2timeline using ipc_info\n"
	 << "   ...only one instance allowed!" << endl << endl;
    exit(EXIT_FAILURE);
  }


D 3
  // subscribe to info server messages
E 3
I 3
D 34
  // subscribe to info server output messages
E 3
D 31
D 33
  TipcMt mt("info_server");
D 4
  server.ProcessCbCreate(mt,info_server_callback,0);
D 3
  server.SubjectSubscribe("info_server/out/???",TRUE);
E 3
I 3
  server.SubjectSubscribe("info_server/out/*",TRUE);
E 4
I 4
  server.SubjectSubscribe("info_server/out/ipc2timeline/evstatmon",TRUE);
D 10
  server.SubjectCbCreate("info_server/out/ipc2timeline/evstatmon",mt,evstatmon_callback,0);
E 10
I 10
  server.SubjectCbCreate("info_server/out/ipc2timeline/evstatmon",mt,evstatmon_callback,(T_CB_ARG)0);
E 10
I 5
  server.SubjectSubscribe("info_server/out/ipc2timeline/evtstatus",TRUE);
D 10
  server.SubjectCbCreate("info_server/out/ipc2timeline/evtstatus",mt,evtstatus_callback,0);
E 10
I 10
  server.SubjectCbCreate("info_server/out/ipc2timeline/evtstatus",mt,evtstatus_callback,(T_CB_ARG)1);
E 10
I 8
  server.SubjectSubscribe("info_server/out/ipc2timeline/diskcheck",TRUE);
D 10
  server.SubjectCbCreate("info_server/out/ipc2timeline/diskcheck",mt,diskcheck_callback,0);
E 10
I 10
  server.SubjectCbCreate("info_server/out/ipc2timeline/diskcheck",mt,diskcheck_callback,(T_CB_ARG)2);
  server.SubjectSubscribe("info_server/out/ipc2timeline/event_monitor",TRUE);
  server.SubjectCbCreate("info_server/out/ipc2timeline/event_monitor",mt,evmon_callback,(T_CB_ARG)3);
  server.SubjectSubscribe("info_server/out/ipc2timeline/scaler",TRUE);
  server.SubjectCbCreate("info_server/out/ipc2timeline/scaler",mt,scaler_callback,(T_CB_ARG)4);

  server.SubjectSubscribe("info_server/out/ipc2timeline/systats/clon00",TRUE);
  server.SubjectCbCreate("info_server/out/ipc2timeline/systats/clon00",mt,systats_callback,(T_CB_ARG)5);
  server.SubjectSubscribe("info_server/out/ipc2timeline/systats/clon10",TRUE);
  server.SubjectCbCreate("info_server/out/ipc2timeline/systats/clon10",mt,systats_callback,(T_CB_ARG)6);
I 22
  server.SubjectSubscribe("info_server/out/ipc2timeline/alarm_checker",TRUE);
  server.SubjectCbCreate("info_server/out/ipc2timeline/alarm_checker",mt,alarm_callback,(T_CB_ARG)7);
I 25
  server.SubjectSubscribe("info_server/out/ipc2timeline/trigmon",TRUE);
  server.SubjectCbCreate("info_server/out/ipc2timeline/trigmon",mt,trigmon_callback,(T_CB_ARG)8);
E 33
I 33
  TipcMt mt((char*)"info_server");
  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/evstatmon",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/evstatmon",mt,evstatmon_callback,(T_CB_ARG)0);
  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/evtstatus",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/evtstatus",mt,evtstatus_callback,(T_CB_ARG)1);
  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/diskcheck",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/diskcheck",mt,diskcheck_callback,(T_CB_ARG)2);
  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/event_monitor",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/event_monitor",mt,evmon_callback,(T_CB_ARG)3);
  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/scaler",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/scaler",mt,scaler_callback,(T_CB_ARG)4);
E 34
I 34
  // create message callbacks
  create_callbacks();
E 34

D 34
  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/systats/clon00",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/systats/clon00",mt,systats_callback,(T_CB_ARG)5);
  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/systats/clon10",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/systats/clon10",mt,systats_callback,(T_CB_ARG)6);
  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/alarm_checker",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/alarm_checker",mt,alarm_callback,(T_CB_ARG)7);
  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/trigmon",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/trigmon",mt,trigmon_callback,(T_CB_ARG)8);
E 33
E 31
I 31
  TipcMt mt((char*)"info_server");
  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/evstatmon",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/evstatmon",mt,evstatmon_callback,(T_CB_ARG)0);
  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/evtstatus",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/evtstatus",mt,evtstatus_callback,(T_CB_ARG)1);
  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/diskcheck",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/diskcheck",mt,diskcheck_callback,(T_CB_ARG)2);
  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/event_monitor",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/event_monitor",mt,evmon_callback,(T_CB_ARG)3);
  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/scaler",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/scaler",mt,scaler_callback,(T_CB_ARG)4);

  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/systats/clon00",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/systats/clon00",mt,systats_callback,(T_CB_ARG)5);
  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/systats/clon10",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/systats/clon10",mt,systats_callback,(T_CB_ARG)6);
  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/alarm_checker",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/alarm_checker",mt,alarm_callback,(T_CB_ARG)7);
  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/trigmon",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/trigmon",mt,trigmon_callback,(T_CB_ARG)8);
E 31
E 25
E 22

E 10
E 8
E 5
E 4
E 3
  server.Flush();
E 34

D 34

  // enable tcl callback
E 34
I 34
  // create tcl callback
E 34
  tclipc_init(interp);


  // init timeline stuff
  init_timeline();


  // post startup message
D 8
  sprintf(temp,"Process startup:  %15s in application %s",unique_id,application);
E 8
I 8
  sprintf(temp,"Process startup:  %15s in project %s",unique_id,project);
E 8
D 3
  //  status=insert_msg("ipc2timeline","online",unique_id,"status",0,"START",0,temp);
E 3
I 3
  status=insert_msg("ipc2timeline","online",unique_id,"status",0,"START",0,temp);
E 3


I 4
  // flush pending output
  fflush(NULL);
  

E 4
D 3
  //  wait for info server messages
E 3
I 3
  // process info server messages
E 3
  while (done==0) {
D 3
    server.MainLoop(1.0);
E 3
I 3
    server.MainLoop(2.0);
E 3
  }


  // done
  ipc_close();
  sprintf(temp,"Process shutdown:  %15s",unique_id);
D 3
  //  status=insert_msg("ipc2timeline","online",unique_id,"status",0,"STOP",0,temp);
E 3
I 3
  status=insert_msg("ipc2timeline","online",unique_id,"status",0,"STOP",0,temp);
E 3
D 34

E 34
  exit(EXIT_SUCCESS);
}
       

//--------------------------------------------------------------------------


I 34
void create_callbacks() {

D 36
    
  TipcMt mt((char*)"info_server");
E 36


I 36
  // generic callback
  TipcMt mt_generic((char*)"ipc2timeline");
  server.SubjectSubscribe((char*)"ipc2timeline/generic",TRUE);
  server.SubjectCbCreate((char*)"ipc2timeline/generic",
			 mt_generic,generic_callback,(T_CB_ARG)0);


  // info_server callbacks
  TipcMt  mt((char*)"info_server");

E 36
  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/evstatmon",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/evstatmon",
D 36
			 mt,evstatmon_callback,(T_CB_ARG)0);
E 36
I 36
			 mt,evstatmon_callback,(T_CB_ARG)1);
E 36

  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/evtstatus",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/evtstatus",
D 36
			 mt,evtstatus_callback,(T_CB_ARG)1);
E 36
I 36
			 mt,evtstatus_callback,(T_CB_ARG)2);
E 36

  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/diskcheck",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/diskcheck",
D 36
			 mt,diskcheck_callback,(T_CB_ARG)2);
E 36
I 36
			 mt,diskcheck_callback,(T_CB_ARG)3);
E 36

  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/event_monitor",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/event_monitor",
D 36
			 mt,evmon_callback,(T_CB_ARG)3);
E 36
I 36
			 mt,evmon_callback,(T_CB_ARG)4);
E 36

  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/scaler",TRUE);
D 42
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/scaler",
E 42
I 42
D 43
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/scaler_timeline",
E 43
I 43
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/scaler",
E 43
E 42
D 36
			 mt,scaler_callback,(T_CB_ARG)4);
E 36
I 36
			 mt,scaler_callback,(T_CB_ARG)5);
E 36

  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/systats/clon00",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/systats/clon00",
D 36
			 mt,systats_callback,(T_CB_ARG)5);
E 36
I 36
			 mt,systats_callback,(T_CB_ARG)6);
E 36

  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/systats/clon10",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/systats/clon10",
D 36
			 mt,systats_callback,(T_CB_ARG)6);
E 36
I 36
			 mt,systats_callback,(T_CB_ARG)7);
E 36

  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/alarm_checker",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/alarm_checker",
D 36
			 mt,alarm_callback,(T_CB_ARG)7);
E 36
I 36
			 mt,alarm_callback,(T_CB_ARG)8);
E 36

  server.SubjectSubscribe((char*)"info_server/out/ipc2timeline/trigmon",TRUE);
  server.SubjectCbCreate((char*)"info_server/out/ipc2timeline/trigmon",
D 36
			 mt,trigmon_callback,(T_CB_ARG)8);
E 36
I 36
			 mt,trigmon_callback,(T_CB_ARG)9);
E 36

D 37
  server.SubjectSubscribe((char*)"info_server/in/hardware_monitor/eber",TRUE);
  server.SubjectCbCreate((char*)"info_server/in/hardware_monitor/eber",
D 36
			 mt,epics_callback,(T_CB_ARG)9);
E 36
I 36
			 mt,epics_callback,(T_CB_ARG)10);
E 36

  server.SubjectSubscribe((char*)"info_server/in/hardware_monitor/ts",TRUE);
  server.SubjectCbCreate((char*)"info_server/in/hardware_monitor/ts",
D 36
			 mt,epics_callback,(T_CB_ARG)10);
E 36
I 36
			 mt,epics_callback,(T_CB_ARG)11);


E 37
E 36

  server.Flush();

  return;
}


//--------------------------------------------------------------------------


E 34
void init_timeline() {

I 4
  int i,j;
D 5
  char temp[64];
E 5


I 10
  // clear counts
  for(i=0; i<ntype; i++) nmsg[i]=0,nentry[i]=0;


E 10
  // evstatmon
  for(i=0; i<5; i++) {
    for(j=0; j<6; j++) {
      sprintf(temp,"%s%s_banks",dnam[i],snam[j]);
      evstatmon_names[6*i+j]=strdup(temp);
      sprintf(temp,"%s%s_words",dnam[i],snam[j]);
      evstatmon_names[30+6*i+j]=strdup(temp);
    }
  }
  evstatmon_names[60]=strdup("event_count");
  evstatmon_names[61]=strdup("clas_words");

I 46
  for(i=0; i<6; i++) {
      for(j=0; j<3; j++) {
	  sprintf(temp,"DC%s%s_mean",snam[i],rnam[j]);
D 47
	  evstatmon_names[62+6*i+j]=strdup(temp);
E 47
I 47
	  evstatmon_names[62+3*i+j]=strdup(temp);
E 47
      }
  }


E 46
E 4
  return;
}

  
//----------------------------------------------------------------


I 10
void status_poll_callback(T_IPC_MSG msg) {

  int i;


  // get stat totals
I 12
  nmsgtot=0;
  nentrytot=0;
E 12
  for(i=0; i<ntype; i++) nmsgtot+=nmsg[i],nentrytot+=nentry[i];


D 31
D 33
  TipcMsgAppendStr(msg,"Total number of messages received");
E 33
I 33
  TipcMsgAppendStr(msg,(char*)"Total number of messages received");
E 33
E 31
I 31
  TipcMsgAppendStr(msg,(char*)"Total number of messages received");
E 31
  TipcMsgAppendInt4(msg,nmsgtot);
D 31
D 33
  TipcMsgAppendStr(msg,"Total number of entries made");
E 33
I 33
  TipcMsgAppendStr(msg,(char*)"Total number of entries made");
E 33
E 31
I 31
  TipcMsgAppendStr(msg,(char*)"Total number of entries made");
E 31
  TipcMsgAppendInt4(msg,nentrytot);

  for(i=0; i<ntype; i++) {
D 31
D 33
    TipcMsgAppendStr(msg,"");
    TipcMsgAppendStr(msg,"");
E 33
I 33
    TipcMsgAppendStr(msg,(char*)"");
    TipcMsgAppendStr(msg,(char*)"");
E 33
E 31
I 31
    TipcMsgAppendStr(msg,(char*)"");
    TipcMsgAppendStr(msg,(char*)"");
E 31

    strcpy(temp,types[i]);
    strcat(temp," messages");
    TipcMsgAppendStr(msg,temp);
    TipcMsgAppendInt4(msg,nmsg[i]);

    strcpy(temp,types[i]);
    strcat(temp," entries");
    TipcMsgAppendStr(msg,temp);
    TipcMsgAppendInt4(msg,nentry[i]);
  }

  return;
}


//-------------------------------------------------------------------


void quit_callback(int sig) {


  cout << "...stopping...received signal " << sig << endl;
  done=1;
  return;
}


//-------------------------------------------------------------------


void decode_command_line(int argc, char**argv) {

D 30
D 31
  char *help = "\nusage:\n\n  ipc2timeline [-a project] [-s session] [-u unique_id]"
E 30
I 30
D 33
  char *help = "\nusage:\n\n  ipc2timeline [-a project] [-s session] [-u unique_id]\n"
    " [-clock clock_rate]\n"
E 33
E 30
E 31
I 31
D 32
  const char *help = "\nusage:\n\n  ipc2timeline [-a project] [-s session] [-u unique_id]"
E 31
    " [-m msql_database] [-t init_tcl_script] [-scal scaler_update] [-no_timeline] [-debug]\n";
E 32
I 32
  const char *help = "\nusage:\n\n  ipc2timeline [-a project] [-s session] [-u unique_id]\n"
D 45
    "             [-m msql_database] [-t init_tcl_script] [-clock clock_rate]\n"
E 45
I 45
    "             [-m msql_database] [-t init_tcl_script] [-clock clock_rate] [-min_evt min_evt]\n"
E 45
D 42
    "             [-scal scaler_update] [-no_timeline] [-debug]\n";
E 42
I 42
D 44
    "             [-no_timeline] [-debug]\n";
E 44
I 44
D 49
    "             [-scal scaler_update] [-no_timeline] [-debug]\n";
E 49
I 49
    "             [-min_rate min_rate] [-scal scaler_update] [-no_timeline] [-debug]\n";
E 49
E 44
E 42
E 32


  // loop over all arguments, except the 1st (which is program name)
  int i=1;
  while(i<argc) {
    if(strncasecmp(argv[i],"-h",2)==0) {
      cout << help << endl;
      exit(EXIT_SUCCESS);
    }
    else if (strncasecmp(argv[i],"-debug",6)==0) {
      debug=1;
      i=i+1;
    }
I 32
    else if (strncasecmp(argv[i],"-clock",6)==0) {
      clock_rate=atoi(argv[i+1]);
      i=i+2;
    }
I 45
    else if (strncasecmp(argv[i],"-min_evt",8)==0) {
      min_evt=atoi(argv[i+1]);
      i=i+2;
    }
I 49
    else if (strncasecmp(argv[i],"-min_rate",9)==0) {
      min_rate=atoi(argv[i+1]);
      i=i+2;
    }
E 49
E 45
E 32
    else if (strncasecmp(argv[i],"-no_timeline",12)==0) {
      no_timeline=1;
      i=i+1;
    }
I 44
    else if (strncasecmp(argv[i],"-scal",5)==0) {
      scaler_update=atoi(argv[i+1]);
      i=i+2;
    }
E 44
D 42
    else if (strncasecmp(argv[i],"-scal",5)==0) {
      scaler_update=atoi(argv[i+1]);
      i=i+2;
    }
E 42
I 30
D 33
    else if (strncasecmp(argv[i],"-clock",6)==0) {
      clock_rate=atoi(argv[i+1]);
      i=i+2;
    }
E 33
E 30
    else if (strncasecmp(argv[i],"-a",2)==0) {
      project=strdup(argv[i+1]);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-s",2)==0) {
	session=strdup(argv[i+1]);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-u",2)==0) {
      unique_id=strdup(argv[i+1]);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-m",2)==0) {
	msql_database=strdup(argv[i+1]);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-t",2)==0) {
      init_tcl_script=strdup(argv[i+1]);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-",1)==0) {
      cout << "Unknown command line arg: " << argv[i] << argv[i+1] << endl << endl;
      i=i+2;
    }
  }

  return;
}

  
//----------------------------------------------------------------


void init_tcl() {

  // link c and Tcl variables
D 31
D 33
  Tcl_LinkVar(interp,"project",    	(char *)&project,      	TCL_LINK_STRING);
  Tcl_LinkVar(interp,"unique_id",     	(char *)&unique_id,    	TCL_LINK_STRING);
  Tcl_LinkVar(interp,"session",     	(char *)&session,      	TCL_LINK_STRING);
  Tcl_LinkVar(interp,"msql_database",  	(char *)&msql_database,	TCL_LINK_STRING);
  Tcl_LinkVar(interp,"scaler_update", 	(char *)&scaler_update,	TCL_LINK_INT);
  Tcl_LinkVar(interp,"no_timeline", 	(char *)&no_timeline,	TCL_LINK_BOOLEAN);
  Tcl_LinkVar(interp,"nmsgtot",     	(char *)&nmsgtot,      	TCL_LINK_INT|TCL_LINK_READ_ONLY);
  Tcl_LinkVar(interp,"nentrytot",     	(char *)&nentrytot,    	TCL_LINK_INT|TCL_LINK_READ_ONLY);
I 30
  Tcl_LinkVar(interp,"clock_rate",     	(char *)&clock_rate,    TCL_LINK_INT);
  Tcl_LinkVar(interp,"debug",     	(char *)&debug,    	TCL_LINK_BOOLEAN);
E 33
I 33
  Tcl_LinkVar(interp,(char*)"project",       (char *)&project,        TCL_LINK_STRING);
  Tcl_LinkVar(interp,(char*)"unique_id",     (char *)&unique_id,      TCL_LINK_STRING);
  Tcl_LinkVar(interp,(char*)"session",       (char *)&session,        TCL_LINK_STRING);
  Tcl_LinkVar(interp,(char*)"msql_database", (char *)&msql_database,  TCL_LINK_STRING);
I 44
  Tcl_LinkVar(interp,(char*)"scaler_update", (char *)&scaler_update,  TCL_LINK_INT);
E 44
D 42
  Tcl_LinkVar(interp,(char*)"scaler_update", (char *)&scaler_update,  TCL_LINK_INT);
E 42
E 33
E 30
E 31
I 31
  Tcl_LinkVar(interp,(char*)"project",       (char *)&project,        TCL_LINK_STRING);
  Tcl_LinkVar(interp,(char*)"unique_id",     (char *)&unique_id,      TCL_LINK_STRING);
  Tcl_LinkVar(interp,(char*)"session",       (char *)&session,        TCL_LINK_STRING);
  Tcl_LinkVar(interp,(char*)"msql_database", (char *)&msql_database,  TCL_LINK_STRING);
  Tcl_LinkVar(interp,(char*)"scaler_update", (char *)&scaler_update,  TCL_LINK_INT);
I 32
  Tcl_LinkVar(interp,(char*)"clock_rate",    (char *)&clock_rate,     TCL_LINK_INT);
I 45
  Tcl_LinkVar(interp,(char*)"min_evt",       (char *)&min_evt,        TCL_LINK_INT);
I 49
  Tcl_LinkVar(interp,(char*)"min_rate",      (char *)&min_rate,       TCL_LINK_INT);
E 49
E 45
  Tcl_LinkVar(interp,(char*)"debug",         (char *)&debug,          TCL_LINK_BOOLEAN);
I 33
  Tcl_LinkVar(interp,(char*)"no_timeline",   (char *)&no_timeline,    TCL_LINK_BOOLEAN);
  Tcl_LinkVar(interp,(char*)"nmsgtot",       (char *)&nmsgtot,        TCL_LINK_INT|TCL_LINK_READ_ONLY);
  Tcl_LinkVar(interp,(char*)"nentrytot",     (char *)&nentrytot,      TCL_LINK_INT|TCL_LINK_READ_ONLY);
E 33
E 32
  Tcl_LinkVar(interp,(char*)"no_timeline",   (char *)&no_timeline,    TCL_LINK_BOOLEAN);
  Tcl_LinkVar(interp,(char*)"nmsgtot",       (char *)&nmsgtot,        TCL_LINK_INT|TCL_LINK_READ_ONLY);
  Tcl_LinkVar(interp,(char*)"nentrytot",     (char *)&nentrytot,      TCL_LINK_INT|TCL_LINK_READ_ONLY);
E 31


  // create Tcl commands
D 31
D 33
  Tcl_CreateCommand(interp,"help",tcl_help,
E 33
I 33
  Tcl_CreateCommand(interp,(char*)"help",tcl_help,
E 33
E 31
I 31
  Tcl_CreateCommand(interp,(char*)"help",tcl_help,
E 31
  		    (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL);
D 31
D 33
  Tcl_CreateCommand(interp,"quit",tcl_quit,
E 33
I 33
  Tcl_CreateCommand(interp,(char*)"quit",tcl_quit,
E 33
E 31
I 31
  Tcl_CreateCommand(interp,(char*)"quit",tcl_quit,
E 31
		    (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL);
D 31
D 33
  Tcl_CreateCommand(interp,"stop",tcl_quit,
E 33
I 33
  Tcl_CreateCommand(interp,(char*)"stop",tcl_quit,
E 33
E 31
I 31
  Tcl_CreateCommand(interp,(char*)"stop",tcl_quit,
E 31
		    (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL);
D 31
D 33
  Tcl_CreateCommand(interp,"exit",tcl_quit,
E 33
I 33
  Tcl_CreateCommand(interp,(char*)"exit",tcl_quit,
E 33
E 31
I 31
  Tcl_CreateCommand(interp,(char*)"exit",tcl_quit,
E 31
		    (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL);

  return;

}


//--------------------------------------------------------------------------


int tcl_help(ClientData clientdata, Tcl_Interp *interp,
		int argc, char **argv) {

D 31
D 33
    char *help =
E 33
I 33
    const char *help =
E 33
E 31
I 31
    const char *help =
E 31
    "\nTcl commands available in the alarm_handler program:\n\n"
    " help                  print this message\n"
    " stop                  stop program\n"
    " quit                  stop program\n"
    " exit                  stop program\n"
    "\n\n Type command that require args with NO args for more information\n"
    "\n";

D 31
D 33
    Tcl_SetResult(interp,help,TCL_STATIC);
E 33
I 33
    Tcl_SetResult(interp,(char*)help,TCL_STATIC);
E 33
E 31
I 31
    Tcl_SetResult(interp,(char*)help,TCL_STATIC);
E 31

  return (TCL_OK);

}


//---------------------------------------------------------------------


int tcl_quit(ClientData clientdata, Tcl_Interp *interp,
	     int argc, char **argv) {
  
  cout << "...received Tcl quit message..." << endl;
  done=1;
  
  return (TCL_OK);
}


//---------------------------------------------------------------------
//---------------------------------------------------------------------
//  info_server message callbacks
//---------------------------------------------------------------------
//---------------------------------------------------------------------


I 36
void generic_callback(T_IPC_CONN conn,
		      T_IPC_CONN_PROCESS_CB_DATA data,
		      T_CB_ARG arg) {
  
  T_INT4 run,event;
  T_STR name,group;
  T_REAL4 value,error;
  TipcMsg msg(data->msg);


  nmsg[(int)arg]++;


  //  testing?
  if(no_timeline)return;


  // connect
  if(timeline_connect()==0) {
    time_t now = time(NULL);
    if(debug!=0)cerr << types[(int)arg] << " unable to connect at " << ctime(&now) << flush;
    return;
  }


  // extract data and make entries
  msg.Current(0);
D 39
  while(msg.Current()<(msg.NumFields()-1)) {
E 39
I 39
  for(int i=0; i<msg.NumFields(); i+=6) {
E 39

    msg >> run >> event >> name >> group >> value >> error;
    nentry[(int)arg]++;
    timeline_put(run,event,name,group,value,error);
  }


  // disconnect
  timeline_disconnect(); 


  return;
}

  
//----------------------------------------------------------------


E 36
E 10
D 4
void info_server_callback(T_IPC_CONN conn,
			  T_IPC_CONN_PROCESS_CB_DATA data,
			  T_CB_ARG arg) {

E 4
I 4
void evstatmon_callback(T_IPC_CONN conn,
			T_IPC_CONN_PROCESS_CB_DATA data,
			T_CB_ARG arg) {
  
  int i,j;
  T_INT4 run,evtime,event_count;
  T_REAL8 *dvalues,clas_words;
  T_INT4  *ivalues;
D 7
  char *table_name="evstatmon";
E 7
E 4
  TipcMsg msg(data->msg);

I 4

E 4
D 10
  nmsg++;
E 10
I 10
  nmsg[(int)arg]++;
E 10

I 3
D 4
  if(debug!=0) {
    msg.Print(TutOut);
    cout << endl << endl << endl;
E 4
I 4

I 36
  //  testing?
  if(no_timeline)return;


E 36
  // extract data
  msg >> run >> evtime >> event_count >> clas_words;


  // no entry if no data
D 45
  if(event_count<=100)return;
E 45
I 45
  if(event_count<=min_evt)return;
E 45


D 7
  // no entry if too soon (why doesn't info server handle this?)
  if((evtime-last_evstatmon)<120)return;
  last_evstatmon=evtime;


E 7
I 5
D 6
  nentry++;


E 6
E 5
  for(j=0; j<30; j+=6) {
    msg >> ivalues; for(i=0; i<6; i++) {evstatmon_vals[j+i]=(float)ivalues[i]/event_count;}
E 4
  }
D 4
    
  ntimeline++;
E 4
I 4
  for(j=30; j<60; j+=6) {
    msg >> dvalues; for(i=0; i<6; i++) {evstatmon_vals[j+i]=(float)dvalues[i];}
  }
  evstatmon_vals[60]=(float)event_count;
  evstatmon_vals[61]=(float)clas_words;
I 46
  msg.Current(35);
  msg >> ivalues; for(i=0; i<18; i++) {evstatmon_vals[62+i]=(float)ivalues[i]/event_count;}
E 46


I 6
D 10
  nentry++;


I 8
  if(debug!=0)return;
E 10
I 10
D 36
  //  testing?
  if(no_timeline)return;
E 10


E 36
E 8
E 6
  // connect
D 10
  timeline_connect(); 
E 10
I 10
  if(timeline_connect()==0) {
    time_t now = time(NULL);
    if(debug!=0)cerr << types[(int)arg] << " unable to connect at " << ctime(&now) << flush;
    return;
  }
E 10


  // make entry
I 10
  nentry[(int)arg]++;
E 10
D 5
  timeline_put_group(run,0,table_name,evstatmon_names,evstatmon_vals,62);
E 5
I 5
D 7
  timeline_put_group(run,0,table_name,evstatmon_names,evstatmon_vals,nevstatmon);
E 7
I 7
D 31
D 33
  timeline_put_group(run,0,"evstatmon",evstatmon_names,evstatmon_vals,nevstatmon);
E 33
I 33
  timeline_put_group(run,0,(char*)"evstatmon",(char**)evstatmon_names,evstatmon_vals,nevstatmon);
E 33
E 31
I 31
  timeline_put_group(run,0,(char*)"evstatmon",(char**)evstatmon_names,evstatmon_vals,nevstatmon);
E 31
E 7
  

  // disconnect
  timeline_disconnect(); 


  return;
}

  
//----------------------------------------------------------------


void evtstatus_callback(T_IPC_CONN conn,
			T_IPC_CONN_PROCESS_CB_DATA data,
			T_CB_ARG arg) {
  
  int i,j;
  T_INT4 run;
D 17
  T_REAL8 daq_rate,mon_rate,evstatmon_rate,evmon_rate,recsis_rate;
E 17
I 17
D 28
  T_REAL8 daq_rate,mon_rate,evstatmon_rate,scaler_rate,evmon_rate,recsis_rate,trigmon_rate;
I 18
  T_REAL8 ipcbank_rate,ptp2et_rate;
E 28
I 28
D 48
  T_REAL8 daq_rate,evstatmon_rate,scaler_rate,evmon_rate,recsis_rate,trigmon_rate;
D 29
  T_REAL8 ipcbank_rate,et2et_rate;
E 29
I 29
  T_REAL8 ipcbank_rate,et2et_rate,mon_rate;
E 48
I 48
  T_REAL8 evstatmon_rate,scaler_rate,evmon_rate,recsis_rate,scstatmon_rate;
  T_REAL8 ipcbank_rate,mon_rate,coda_l3_rate,coda_pr_rate,coda_tr_rate;
D 49
  T_REAL8 et2et_10_00_rate,et2et_10_04_rate;
E 49
I 49
D 53
  T_REAL8 event_rate,et2et_10_00_rate,et2et_10_04_rate;
E 53
I 53
  T_REAL8 event_rate,et2et_10_00_rate,et2et_10_04_rate,et2et_eb_er_rate,et2et_er_daq_rate;
E 53
E 49
E 48
E 29
E 28
E 18
E 17
  TipcMsg msg(data->msg);


D 10
  nmsg++;
E 10
I 10
  nmsg[(int)arg]++;
E 10
D 7


  // no entry if too soon (why doesn't info server handle this?)
  if((time(NULL)-last_evtstatus)<120)return;
  last_evtstatus=time(NULL);
E 7

D 53

E 53
I 53
  //printf("1\n");
E 53
I 36
  //  testing?
  if(no_timeline)return;


I 53
  //printf("2\n");
E 53
E 36
D 6
  nentry++;


E 6
  // extract data and convert to float
D 17
  msg >> run >> daq_rate >> mon_rate >> evstatmon_rate >> evmon_rate >>recsis_rate;
E 17
I 17
D 18
  msg >> run >> daq_rate >> mon_rate >> evstatmon_rate >> scaler_rate >> evmon_rate 
      >> recsis_rate >> trigmon_rate;
E 18
I 18
D 28
  msg >> run >> daq_rate 
      >> mon_rate >> ipcbank_rate >> ptp2et_rate >> evstatmon_rate 
E 28
I 28
D 48
  msg >> run >> daq_rate >> et2et_rate >> ipcbank_rate >> evstatmon_rate 
E 28
      >> scaler_rate >> evmon_rate >> recsis_rate >> trigmon_rate;
E 18
E 17
  evtstatus_vals[0]=(float)daq_rate;
D 28
  evtstatus_vals[1]=(float)mon_rate;
E 28
I 28
  evtstatus_vals[1]=(float)et2et_rate;
E 28
D 18
  evtstatus_vals[2]=(float)evstatmon_rate;
D 17
  evtstatus_vals[3]=(float)evmon_rate;
  evtstatus_vals[4]=(float)recsis_rate;
E 17
I 17
  evtstatus_vals[3]=(float)scaler_rate;
  evtstatus_vals[4]=(float)evmon_rate;
  evtstatus_vals[5]=(float)recsis_rate;
  evtstatus_vals[6]=(float)trigmon_rate;
E 18
I 18
D 29
  evtstatus_vals[2]=(float)ipcbank_rate;
D 28
  evtstatus_vals[3]=(float)ptp2et_rate;
  evtstatus_vals[4]=(float)evstatmon_rate;
  evtstatus_vals[5]=(float)scaler_rate;
D 19
  evtstatus_vals[5]=(float)evmon_rate;
E 19
I 19
  evtstatus_vals[6]=(float)evmon_rate;
E 19
  evtstatus_vals[7]=(float)recsis_rate;
  evtstatus_vals[8]=(float)trigmon_rate;
E 28
I 28
  evtstatus_vals[3]=(float)evstatmon_rate;
  evtstatus_vals[4]=(float)scaler_rate;
  evtstatus_vals[5]=(float)evmon_rate;
  evtstatus_vals[6]=(float)recsis_rate;
  evtstatus_vals[7]=(float)trigmon_rate;
E 29
I 29
  evtstatus_vals[2]=(float)et2et_rate;
E 48
I 48
D 49
  msg >> run >> ipcbank_rate >> coda_l3_rate >> scaler_rate >> et2et_10_00_rate 
E 49
I 49
D 52
  msg >> run >> event_rate >> ipcbank_rate >> coda_l3_rate >> scaler_rate 
E 52
I 52
  // IMPORTANT: the order of fields in following statement
  //            corresponds to the order of fields in
  //            'std_id[]' array in 'evt_status_monitor'
D 53
  msg >> run >> event_rate
E 53
I 53
  //            and corresponding input and output records
  //            in info_server.cfg file
  msg >> run
E 53
      >> ipcbank_rate
      >> coda_l3_rate
      >> scaler_rate 
E 52
      >> et2et_10_00_rate 
E 49
D 52
      >> coda_pr_rate >> coda_tr_rate >> et2et_10_04_rate >> evstatmon_rate
      >> evmon_rate >> recsis_rate >> scstatmon_rate;
E 52
I 52
      >> coda_pr_rate
      >> coda_tr_rate
      >> et2et_10_04_rate
      >> evstatmon_rate
      >> evmon_rate
      >> recsis_rate
D 53
      >> scstatmon_rate;
E 53
I 53
      >> scstatmon_rate
      >> et2et_eb_er_rate 
      >> et2et_er_daq_rate;
E 53

D 53
  //Sergey: use 'coda_l3_rate' as 'event_rate'
  event_rate = coda_l3_rate;
E 53
I 53
D 55
  //Sergey: use 'et2et_eb_er_rate' as 'event_rate'
  event_rate = et2et_eb_er_rate;
E 55
I 55
  //Sergey: use 'coda_l3_rate' as 'event_rate'
  event_rate = coda_l3_rate;
E 55
E 53

I 53
  //printf("3: rates -> %f %f %f %f %f %f %f %f %f %f %f %f %f\n",
  //  ipcbank_rate,coda_l3_rate,scaler_rate,et2et_10_00_rate,coda_pr_rate,
  //  coda_tr_rate,et2et_10_04_rate,evstatmon_rate,evmon_rate,recsis_rate,scstatmon_rate,
  //  et2et_eb_er_rate,et2et_er_daq_rate);

E 53
E 52
D 49
  evtstatus_vals[0]=(float)coda_l3_rate;
E 49
I 49
  evtstatus_vals[0]=(float)event_rate;
E 49
  evtstatus_vals[1]=(float)et2et_10_04_rate;
  evtstatus_vals[2]=(float)et2et_10_04_rate;
E 48
  evtstatus_vals[3]=(float)ipcbank_rate;
  evtstatus_vals[4]=(float)evstatmon_rate;
  evtstatus_vals[5]=(float)scaler_rate;
  evtstatus_vals[6]=(float)evmon_rate;
  evtstatus_vals[7]=(float)recsis_rate;
D 48
  evtstatus_vals[8]=(float)trigmon_rate;
E 48
E 29
E 28
E 18
E 17
I 6


D 49
  // no entry if data rate < 10 Hz
D 48
  if(daq_rate<=10.0)return;
E 48
I 48
  if(coda_l3_rate<=10.0)return;
E 49
I 49
  // no entry if data rate too low
D 52
  if(event_rate<=(float)min_rate)return;
E 52
I 52
  if(event_rate<=(float)min_rate) return;
E 52
E 49
E 48

I 53
  //printf("4: %f %f %f %f %f %f %f %f\n",
  // evtstatus_vals[0],evtstatus_vals[1],evtstatus_vals[2],evtstatus_vals[3],
  // evtstatus_vals[4],evtstatus_vals[5],evtstatus_vals[6],evtstatus_vals[7]);
E 53

D 10
  nentry++;
E 6


I 8
  if(debug!=0)return;
E 10
I 10
D 36
  //  testing?
  if(no_timeline)return;
E 10


E 36
E 8
  // connect
D 10
  timeline_connect(); 
E 10
I 10
D 53
  if(timeline_connect()==0) {
E 53
I 53
  if(timeline_connect()==0)
  {
E 53
    time_t now = time(NULL);
D 53
    if(debug!=0)cerr << types[(int)arg] << " unable to connect at " << ctime(&now) << flush;
E 53
I 53
    if(debug!=0) cerr << types[(int)arg] << " unable to connect at " << ctime(&now) << flush;
    printf("unable to connect\n");
E 53
    return;
  }
E 10


  // make entry
I 10
  nentry[(int)arg]++;
E 10
D 31
D 33
  timeline_put_group(run,0,"evtstatus",evtstatus_names,evtstatus_vals,nevtstatus);
E 33
I 33
  timeline_put_group(run,0,(char*)"evtstatus",(char**)evtstatus_names,evtstatus_vals,nevtstatus);
E 33
E 31
I 31
  timeline_put_group(run,0,(char*)"evtstatus",(char**)evtstatus_names,evtstatus_vals,nevtstatus);
E 31
E 5
D 53
  
E 53
I 53
  //printf("5: arg=%d nentry=%d\n",(int)arg,nentry[(int)arg]);
E 53

I 53

E 53
  // disconnect
  timeline_disconnect(); 
E 4


E 3
  return;
}

  
//----------------------------------------------------------------


I 8
void diskcheck_callback(T_IPC_CONN conn,
			T_IPC_CONN_PROCESS_CB_DATA data,
			T_CB_ARG arg) {
  
  int i;
D 9
  T_INT4 temp;
E 9
I 9
  T_STR status;
D 35
  T_INT4 itmp;
E 35
I 35
  T_INT4 itmp,nraid;
E 35
E 9
  T_REAL8 active_free;
  TipcMsg msg(data->msg);
  T_INT4 run=get_run_number(msql_database,session);


D 10
  nmsg++;
E 10
I 10
  nmsg[(int)arg]++;
E 10


I 36
  //  testing?
  if(no_timeline)return;


E 36
D 9
  // extract data and convert to float
  msg.Current(6);
  for(i=0; i<(ndiskcheck-1); i++) { msg >> temp; diskcheck_vals[i]=temp; }
E 9
I 9
D 13
  // extract raid status data
E 13
I 13
D 35
  // extract raid status data and convert to integer
E 13
  for(i=0; i<6; i++) {
E 35
I 35
D 48
  // clon00 info
  for(i=0; i<3; i++) { msg >> itmp; diskcheck_vals[i]=(float)itmp; }
E 48
I 48
  // extract integers
  for(i=0; i<21; i++) { msg >> itmp; diskcheck_vals[i]=(float)itmp; }
E 48


D 48
  // clon10 info
  for(i=3; i<19; i++) { msg >> itmp; diskcheck_vals[i]=(float)itmp; }


  // extract raid counts
  for(i=19; i<24; i++) { msg >> itmp; diskcheck_vals[i]=(float)itmp; }


  // active_free (24th)
E 48
I 48
  // active_free is double
E 48
  msg >> active_free;
D 48
  diskcheck_vals[24]=(float)active_free;
E 48
I 48
  diskcheck_vals[21]=(float)active_free;
E 48


  // nraid (not entered into timeline hist)
  msg >> nraid;


  // raid status for 8 disks
D 48
  for(i=25; i<33; i++) {
E 48
I 48
  for(i=22; i<30; i++) {
E 48
E 35
      msg >> status;
      if (strncasecmp(status,"ACTIVE",6)==0) {
	  diskcheck_vals[i]=1.;
      } else if(strncasecmp(status,"EMPTY",5)==0) {
	  diskcheck_vals[i]=2.;
      } else if(strncasecmp(status,"MOVING",6)==0) {
	  diskcheck_vals[i]=3.;
      } else if(strncasecmp(status,"FULL (BA",8)==0) {
	  diskcheck_vals[i]=4.;
      } else if(strncasecmp(status,"FULL (NO",8)==0) {
	  diskcheck_vals[i]=5.;
      } else {
	  diskcheck_vals[i]=0.;
      }
  }
D 35


D 13
  // extract counts and active_free
  for(i=6; i<(ndiskcheck-1); i++) { msg >> itmp; diskcheck_vals[i]=(float)itmp; }
E 13
I 13
  // extract raid counts
  for(i=6; i<11; i++) { msg >> itmp; diskcheck_vals[i]=(float)itmp; }


  // extract active_free
E 13
E 9
  msg >> active_free;
  diskcheck_vals[ndiskcheck-1]=(float)active_free;
I 13


  // extract clon00,clon10 info
  for(i=12; i<ndiskcheck; i++) { msg >> itmp; diskcheck_vals[i]=(float)itmp; }
E 35
E 13


D 10
  nentry++;


  if(debug!=0)return;
E 10
I 10
D 36
  //  testing?
  if(no_timeline)return;
E 10


E 36
  // connect
D 10
  timeline_connect(); 
E 10
I 10
  if(timeline_connect()==0) {
    time_t now = time(NULL);
    if(debug!=0)cerr << types[(int)arg] << " unable to connect at " << ctime(&now) << flush;
    return;
  }
E 10


  // make entry
I 10
  nentry[(int)arg]++;
E 10
D 9
  timeline_put_group(run,0,"diskcheck",diskcheck_names,(float*)diskcheck_vals,ndiskcheck);
E 9
I 9
D 31
D 33
  timeline_put_group(run,0,"diskcheck",diskcheck_names,diskcheck_vals,ndiskcheck);
E 33
I 33
  timeline_put_group(run,0,(char*)"diskcheck",(char**)diskcheck_names,diskcheck_vals,ndiskcheck);
E 33
E 31
I 31
  timeline_put_group(run,0,(char*)"diskcheck",(char**)diskcheck_names,diskcheck_vals,ndiskcheck);
E 31
E 9
  

  // disconnect
  timeline_disconnect(); 


  return;
}

  
//----------------------------------------------------------------


E 8
D 10
void status_poll_callback(T_IPC_MSG msg) {

D 5
  TipcMsgAppendStr(msg,"Number of messages processed");
E 5
I 5
  TipcMsgAppendStr(msg,"Number of messages received");
E 5
  TipcMsgAppendInt4(msg,nmsg);
I 5
  TipcMsgAppendStr(msg,"Number of entries made");
  TipcMsgAppendInt4(msg,nentry);
E 10
I 10
void evmon_callback(T_IPC_CONN conn,
		    T_IPC_CONN_PROCESS_CB_DATA data,
		    T_CB_ARG arg) {
E 10
E 5
I 3
D 4
  TipcMsgAppendStr(msg,"Number of timeline entries");
  TipcMsgAppendInt4(msg,ntimeline);
E 4
E 3
  
D 10
  return;
}
E 10

I 10
  // n.b. evmon must send doubles
E 10

D 10
//-------------------------------------------------------------------
E 10


D 10
void quit_callback(int sig) {
E 10
I 10
  TipcMsg msg(data->msg);
D 14
  T_INT4 run;
E 14
I 14
  T_INT4 run=get_run_number(msql_database,session);
I 48
  T_REAL8 ntrig;
E 48
E 14
  T_REAL8 trig_evt_mean,trig_evt_mean_err,trig_evt_width,trig_evt_width_err;
D 12
  T_REAL8 trig_mean[7][7],trig_mean_err[7][7],trig_width[7][7],trig_width_err[7][7];
E 12
I 12
  T_REAL8 *trig_mean,*trig_mean_err,*trig_width,*trig_width_err;
E 12
E 10

I 10
  int i,j;
  char var[64];
  char group[64];
E 10

D 10
  cout << "...stopping...received signal " << sig << endl;
  done=1;
  return;
}
E 10

I 10
  nmsg[(int)arg]++;
E 10

D 10
//-------------------------------------------------------------------
E 10

I 36
  //  testing?
  if(no_timeline)return;


E 36
I 10
  // extract data
I 48
  msg >> ntrig;
D 49
  if(ntrig<2000.0)return;
E 49
I 49
  if(ntrig<(double)min_evt)return;
E 49

E 48
D 14
  msg >> run >> trig_evt_mean >> trig_evt_mean_err >> trig_evt_width >> trig_evt_width_err;
E 14
I 14
  msg >> trig_evt_mean >> trig_evt_mean_err >> trig_evt_width >> trig_evt_width_err;
E 14
D 12
  msg >> trig_mean[0][0] >> trig_mean_err[0][0] >> trig_width[0][0] >> trig_width_err[0][0];
E 12
I 12
  msg >> trig_mean >> trig_mean_err >> trig_width >> trig_width_err;
E 12
E 10

D 10
void decode_command_line(int argc, char**argv) {
E 10

D 8
  char *help = "\nusage:\n\n  ipc2timeline [-a application] [-u unique_id]"
    " [-t init_tcl_script] [-debug]\n";
E 8
I 8
D 10
  char *help = "\nusage:\n\n  ipc2timeline [-a project] [-s session] [-u unique_id]"
    " [-m msql_database] [-t init_tcl_script] [-debug]\n";
E 10
E 8

I 10
D 36
  //  testing?
  if(no_timeline)return;
E 10

D 10
  // loop over all arguments, except the 1st (which is program name)
  int i=1;
  while(i<argc) {
    if(strncasecmp(argv[i],"-h",2)==0) {
      cout << help << endl;
      exit(EXIT_SUCCESS);
    }
    else if (strncasecmp(argv[i],"-debug",6)==0) {
      debug=1;
      i=i+1;
    }
    else if (strncasecmp(argv[i],"-a",2)==0) {
D 8
      application=strdup(argv[i+1]);
E 8
I 8
      project=strdup(argv[i+1]);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-s",2)==0) {
	session=strdup(argv[i+1]);
E 8
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-u",2)==0) {
      unique_id=strdup(argv[i+1]);
      i=i+2;
    }
I 8
    else if (strncasecmp(argv[i],"-m",2)==0) {
	msql_database=strdup(argv[i+1]);
      i=i+2;
    }
E 8
    else if (strncasecmp(argv[i],"-t",2)==0) {
      init_tcl_script=strdup(argv[i+1]);
      i=i+2;
    }
    else if (strncasecmp(argv[i],"-",1)==0) {
      cout << "Unknown command line arg: " << argv[i] << argv[i+1] << endl << endl;
      i=i+2;
E 10
I 10

E 36
  // connect
  if(timeline_connect()==0) {
    time_t now = time(NULL);
    if(debug!=0)cerr << types[(int)arg] << " unable to connect at " << ctime(&now) << flush;
    return;
  }


  // make entry
  nentry[(int)arg]++;

I 48
D 49
  cout << "making evmon entry" << endl;

E 49
E 48
  strcpy(var,evmon_evt_name);   strcat(var,"_mean");
  strcpy(group,evmon_group);    strcat(group,"_mean");
D 48
  update_tables(run,0,var,group,trig_evt_mean,trig_evt_mean_err);
E 48
I 48
D 49
  //  update_tables(run,0,var,group,trig_evt_mean,trig_evt_mean_err);
E 49
I 49
  timeline_put(run,0,var,group,trig_evt_mean,trig_evt_mean_err);
E 49
E 48
  
  strcpy(var,evmon_evt_name);   strcat(var,"_width");
  strcpy(group,evmon_group);    strcat(group,"_width");
D 48
  update_tables(run,0,var,group,trig_evt_width,trig_evt_width_err);
E 48
I 48
D 49
  //  update_tables(run,0,var,group,trig_evt_width,trig_evt_width_err);
E 49
I 49
  timeline_put(run,0,var,group,trig_evt_width,trig_evt_width_err);
E 49
E 48
  
I 48

E 48
  for(i=0; i<7; i++) {
D 14
    for(j=0; i<7; j++) {
E 14
I 14
    for(j=0; j<7; j++) {
E 14
      strcpy(var,evmon_names[i][j]);  strcat(var,"_mean");
      strcpy(group,evmon_group);      strcat(group,"_mean");
D 12
      update_tables(run,0,var,group,trig_mean[i][j],trig_mean_err[i][j]);
E 12
I 12
D 48
      update_tables(run,0,var,group,trig_mean[i*7+j],trig_mean_err[i*7+j]);
E 48
I 48
D 49
      //      update_tables(run,0,var,group,trig_mean[i*7+j],trig_mean_err[i*7+j]);
E 49
I 49
      timeline_put(run,0,var,group,trig_mean[i*7+j],trig_mean_err[i*7+j]);
E 49
E 48
E 12

      strcpy(var,evmon_names[i][j]);  strcat(var,"_width");
      strcpy(group,evmon_group);      strcat(group,"_width");
D 12
      update_tables(run,0,var,group,trig_width[i][j],trig_width_err[i][j]);
E 12
I 12
D 48
      update_tables(run,0,var,group,trig_width[i*7+j],trig_width_err[i*7+j]);
E 48
I 48
D 49
      //      update_tables(run,0,var,group,trig_width[i*7+j],trig_width_err[i*7+j]);
E 49
I 49
      timeline_put(run,0,var,group,trig_width[i*7+j],trig_width_err[i*7+j]);
E 49
E 48
E 12
E 10
    }
  }
I 10
  

  // disconnect
  timeline_disconnect(); 

E 10

  return;
}

  
//----------------------------------------------------------------


D 10
void init_tcl() {
E 10
I 10
void scaler_callback(T_IPC_CONN conn,
		     T_IPC_CONN_PROCESS_CB_DATA data,
		     T_CB_ARG arg) {
  
E 10

D 10
  // link c and Tcl variables
D 8
  Tcl_LinkVar(interp,"application",    	(char *)&application,  TCL_LINK_STRING);
  Tcl_LinkVar(interp,"unique_id",     	(char *)&unique_id,    TCL_LINK_STRING);
  Tcl_LinkVar(interp,"nmsg",     	(char *)&nmsg,         TCL_LINK_INT|TCL_LINK_READ_ONLY);
I 5
  Tcl_LinkVar(interp,"nentry",     	(char *)&nentry,       TCL_LINK_INT|TCL_LINK_READ_ONLY);
E 8
I 8
  Tcl_LinkVar(interp,"project",    	(char *)&project,      	TCL_LINK_STRING);
  Tcl_LinkVar(interp,"unique_id",     	(char *)&unique_id,    	TCL_LINK_STRING);
  Tcl_LinkVar(interp,"session",     	(char *)&session,      	TCL_LINK_STRING);
  Tcl_LinkVar(interp,"msql_database",  	(char *)&msql_database,	TCL_LINK_STRING);
  Tcl_LinkVar(interp,"nmsg",     	(char *)&nmsg,         	TCL_LINK_INT|TCL_LINK_READ_ONLY);
  Tcl_LinkVar(interp,"nentry",     	(char *)&nentry,       	TCL_LINK_INT|TCL_LINK_READ_ONLY);
E 10
I 10
  TipcMsg msg(data->msg);
D 12
  T_INT4 run=get_run_number(msql_database,session);
  T_INT4 *head, *trgs, *trgd;
  T_INT4 headsize,trgssize,trgdsize;
  
E 12
I 12
D 14
  T_INT4 run;
  T_INT4 *head, *trgd;
  T_INT4 headsize,trgdsize;
E 14
I 14
  T_INT4 run=get_run_number(msql_database,session);
D 16
  T_INT4 *trgd;
  T_INT4 trgdsize;
E 16
I 16
D 17
  T_INT4 *trgs=NULL,*trgd=NULL,*scs=NULL,*ecs=NULL;
E 17
I 17
D 24
  T_INT4 *trgs=NULL,*trgd=NULL,*scs=NULL,*ecs=NULL,*s1st=NULL,*rcst30=NULL;
E 24
I 24
  T_INT4 *trgs=NULL,*trgd=NULL,*scs=NULL,*ecs=NULL,*s1st=NULL,*s1sd=NULL,*rcst30=NULL;
E 24
E 17
E 16
E 14
  double deltat;
D 16
  int i;
E 16
I 16
  int i,j;
E 16
I 14
  T_STR label;
  time_t now = time(NULL);
I 16
  char *p;
E 16
E 14

E 12
E 10
E 8
E 5
I 3
D 4
  Tcl_LinkVar(interp,"ntimeline",     	(char *)&ntimeline,    TCL_LINK_INT|TCL_LINK_READ_ONLY);
E 4
E 3

I 10
  nmsg[(int)arg]++;
E 10

D 10
  // create Tcl commands
  Tcl_CreateCommand(interp,"help",tcl_help,
  		    (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL);
  Tcl_CreateCommand(interp,"quit",tcl_quit,
		    (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL);
  Tcl_CreateCommand(interp,"stop",tcl_quit,
		    (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL);
  Tcl_CreateCommand(interp,"exit",tcl_quit,
		    (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL);
E 10

I 36
  //  testing?
  if(no_timeline)return;


I 44
  // too soon?
  if((now-last_scaler)<scaler_update)return;


E 44
E 36
I 16
D 42
  // too soon?
  if((now-last_scaler)<scaler_update)return;


E 42
E 16
D 10
  return;
E 10
I 10
  // extract data
D 12
  msg >> head >> GetSize(&headsize) >> trgs >> GetSize(&trgssize) >> trgd >> GetSize(&trgdsize);
E 12
I 12
D 14
  msg >> head >> GetSize(&headsize);
  msg >> trgd>> GetSize(&trgdsize);
E 14
I 14
D 16
  msg >> label >> trgd >> GetSize(&trgdsize);
E 16
I 16
  while(msg.Next(&label)) {
      p=strstr(label,"::")+2;
      if(strcasecmp(p,"TRGS00")==0) {
D 21
	  msg >>trgs;
E 21
I 21
	  msg >> trgs;
E 21
      } else if(strcasecmp(p,"TRGD00")==0) {
D 21
	  msg >>trgd;
E 21
I 21
	  msg >> trgd;
E 21
      } else if (strcasecmp(p,"SCS_00")==0) {
D 21
	  msg >>scs;
E 21
I 21
	  msg >> scs;
E 21
      } else if (strcasecmp(p,"ECS_00")==0) {
	  msg >> ecs;
I 17
      } else if (strcasecmp(p,"S1ST00")==0) {
D 21
	  msg >>s1st;
E 21
I 21
	  msg >> s1st;
I 24
      } else if (strcasecmp(p,"S1SD00")==0) {
	  msg >> s1sd;
E 24
E 21
      } else if (strcasecmp(p,"RCST30")==0) {
D 21
	  msg >>rcst30;
E 21
I 21
	  msg >> rcst30;
E 21
E 17
      }
  }
E 16
E 14
E 12
E 10

D 10
}
E 10

I 10
D 15
  // check for update timeout
E 15
I 15
D 16
  // check for update timeout and legal deltat (9 to 11 seconds)
E 15
D 14
  if((head[4]-last_scaler)<scaler_update)return;
  last_scaler=head[4];
I 12
  run=head[1];
E 14
I 14
  if((now-last_scaler)<scaler_update)return;
E 16
I 16
  //  check that all banks arrived
D 17
  if((trgs==NULL)||(trgd==NULL)||(scs==NULL)||(ecs==NULL)) {
E 17
I 17
D 21
  if((trgs==NULL)||(trgd==NULL)||(scs==NULL)||(ecs==NULL)||(s1st=NULL)||(rcst30==NULL)) {
E 21
I 21
D 24
  if((trgs==NULL)||(trgd==NULL)||(scs==NULL)||(ecs==NULL)||(s1st==NULL)||(rcst30==NULL)) {
E 21
E 17
      if(debug!=0)cerr << "?missing banks" << endl;
      return;
E 24
I 24
  if( (trgs==NULL)||(trgd==NULL)||(scs==NULL)||(ecs==NULL)||(s1st==NULL)||
      (s1sd==NULL)||(rcst30==NULL) ) {
D 30
    if(debug!=0)cerr << "?missing banks" << endl;
E 30
I 30
D 33
    if(debug!=0)cerr << "?missing scaler banks" << endl;
E 33
I 33
    if(debug!=0)cerr << "?missing banks" << endl;
E 33
E 30
    return;
E 24
  }


D 50
  // check for legal deltat (9 to 11 seconds)
E 50
I 50
  // calculate time between scaler events
E 50
E 16
I 15
D 30
D 32
  deltat=trgd[0]/10000;
E 30
I 30
  deltat=double(trgd[0])/clock_rate;
E 30
E 32
I 32
  deltat=double(trgd[0])/clock_rate;
E 32
D 16
  if((deltat<=9.0)||(deltat>11.0))return;
E 15
  last_scaler=now;
E 16
I 16
D 50
  if((deltat<=9.0)||(deltat>11.0)) {
      if(debug!=0)cerr << "?illegal deltat: " << deltat << endl;
      return;
  }
E 50
E 16
E 14
E 12
E 10
D 36

D 10
//--------------------------------------------------------------------------
E 10

I 10
  //  testing?
  if(no_timeline)return;
E 36
E 10

I 50
  // eliminate this check...ejw, 5-dec-2005
  // check for legal deltat (9 to 11 seconds)
//    if((deltat<=9.0)||(deltat>11.0)) {
//        if(debug!=0)cerr << "?illegal deltat: " << deltat << endl;
//        return;
//    }
E 50
D 10
int tcl_help(ClientData clientdata, Tcl_Interp *interp,
		int argc, char **argv) {
E 10

I 50

E 50
I 12
D 16
  // extract data
D 15
  deltat=trgd[0]/10000;
  if(deltat<=0.)return;

E 15
D 14
  for(i=0; i<12; i++) 
    scaler_vals[i]=trgd[48+i]/deltat;  // ungated l1 bits
E 14
I 14
  for(i=0; i<12; i++) scaler_vals[i]=trgd[48+i]/deltat;  // ungated l1 bits
E 14
  scaler_vals[12]=trgd[60]/deltat;     // or level1
  scaler_vals[13]=trgd[61]/deltat;     // l1accept
D 14
  scaler_vals[14]=trgd[63]/deltat;     // l2fail
  scaler_vals[15]=trgd[64]/deltat;     // l2pass
  scaler_vals[16]=trgd[65]/deltat;     // l2start
  scaler_vals[17]=trgd[66]/deltat;     // l2clear
  scaler_vals[18]=trgd[67]/deltat;     // l2accept
  scaler_vals[19]=trgd[68]/deltat;     // l3accept

E 14
I 14
  scaler_vals[14]=trgd[64]/deltat;     // l2fail
  scaler_vals[15]=trgd[65]/deltat;     // l2pass
  scaler_vals[16]=trgd[66]/deltat;     // l2start
  scaler_vals[17]=trgd[67]/deltat;     // l2clear
  scaler_vals[18]=trgd[68]/deltat;     // l2accept
  scaler_vals[19]=trgd[69]/deltat;     // l3accept
E 16
I 16
  // extract data (interval, unless noted)
D 42
  for(i=0; i<12; i++) 
      scaler_vals[i]=(double)trgd[48+i]/deltat;              // ungated l1 bits
  scaler_vals[12]=(double)trgd[60]/deltat;     		     // or level1
  scaler_vals[13]=(double)trgd[61]/deltat;     		     // l1accept
  scaler_vals[14]=(double)trgd[64]/deltat;     		     // l2fail
  scaler_vals[15]=(double)trgd[65]/deltat;     		     // l2pass
  scaler_vals[16]=(double)trgd[66]/deltat;     		     // l2start
  scaler_vals[17]=(double)trgd[67]/deltat;     		     // l2clear
  scaler_vals[18]=(double)trgd[68]/deltat;     		     // l2accept
  scaler_vals[19]=(double)trgd[69]/deltat;     		     // l3accept           
  scaler_vals[20]=(trgd[16]>0)?(double)trgd[32]/trgd[16]:0;  // live_clock
  scaler_vals[21]=(trgd[17]>0)?(double)trgd[33]/trgd[17]:0;  // live_fcup
  scaler_vals[22]=(trgd[60]>0)?(double)trgd[61]/trgd[60]:0;  // live_trig
  scaler_vals[23]=trgs[17];            			     // fcup_int  (from begin of run)
  scaler_vals[24]=trgd[17];            			     // fcup_diff          
E 42
I 42
D 44
  for(i=0; i<12; i++) scaler_vals[i]=(double)trgd[48+i]/deltat;   // ungated l1 bits
  scaler_vals[12]=(double)trgd[60]/deltat;     		     	  // or level1
  scaler_vals[13]=(double)trgd[61]/deltat;     		     	  // l1accept
  scaler_vals[14]=(double)trgd[64]/deltat;     		     	  // l2fail
  scaler_vals[15]=(double)trgd[65]/deltat;     		     	  // l2pass
  scaler_vals[16]=(double)trgd[66]/deltat;     		     	  // l2start
  scaler_vals[17]=(double)trgd[67]/deltat;     		     	  // l2clear
  scaler_vals[18]=(double)trgd[68]/deltat;     		     	  // l2accept
  scaler_vals[19]=(double)trgd[69]/deltat;     		     	  // l3accept           
  scaler_vals[20]=(trgd[16]>0)?(double)trgd[32]/trgd[16]:0;  	  // live_clock
  scaler_vals[21]=(trgd[17]>0)?(double)trgd[33]/trgd[17]:0;  	  // live_fcup
  scaler_vals[22]=(trgd[60]>0)?(double)trgd[61]/trgd[60]:0;  	  // live_trig
  scaler_vals[23]=trgs[17];            			     	  // fcup_int  (from begin of run)
  scaler_vals[24]=trgd[17];            			     	  // fcup_diff          
E 44
I 44
  for(i=0; i<12; i++) 
      scaler_vals[i]=(double)trgd[48+i]/deltat;              // ungated l1 bits
  scaler_vals[12]=(double)trgd[60]/deltat;     		     // or level1
  scaler_vals[13]=(double)trgd[61]/deltat;     		     // l1accept
  scaler_vals[14]=(double)trgd[64]/deltat;     		     // l2fail
  scaler_vals[15]=(double)trgd[65]/deltat;     		     // l2pass
  scaler_vals[16]=(double)trgd[66]/deltat;     		     // l2start
  scaler_vals[17]=(double)trgd[67]/deltat;     		     // l2clear
  scaler_vals[18]=(double)trgd[68]/deltat;     		     // l2accept
  scaler_vals[19]=(double)trgd[69]/deltat;     		     // l3accept           
  scaler_vals[20]=(trgd[16]>0)?(double)trgd[32]/trgd[16]:0;  // live_clock
  scaler_vals[21]=(trgd[17]>0)?(double)trgd[33]/trgd[17]:0;  // live_fcup
  scaler_vals[22]=(trgd[60]>0)?(double)trgd[61]/trgd[60]:0;  // live_trig
  scaler_vals[23]=trgs[17];            			     // fcup_int  (from begin of run)
  scaler_vals[24]=trgd[17];            			     // fcup_diff          
E 44
E 42

I 24

E 24
D 40
  // ec total rates (16 channels per sector)
E 40
I 40
  // ec total rates (6 channels per sector)
E 40
  for(i=0; i<6; i++) {
      scaler_vals[25+i]=0;
D 40
      for(j=0; j<16; j++) scaler_vals[25+i]+=(double)ecs[16*i+j]/deltat;
E 40
I 40
      for(j=0; j<6; j++) scaler_vals[25+i]+=(double)ecs[16*i+j]/deltat;
E 40
  }

I 24

E 24
  // sc total rates (32 channels per sector)
  for(i=0; i<6; i++) {
      scaler_vals[31+i]=0;
      for(j=0; j<32; j++) scaler_vals[31+i]+=(double)scs[32*i+j]/deltat;
  }
E 16
  
I 24

E 24
I 16
D 17
  // errors
E 17
I 17
D 20
  // total l1,l2 errors
E 17
//    scaler_vals[37]=trgs[?]-trgs[?];
//    scaler_vals[38]=trgs[?]-trgs[?];
E 20
I 20
  // trigger problems
  scaler_vals[37]=s1st[13]+s1st[14]+s1st[15];                // latch1 state errors
  scaler_vals[38]=s1st[25]+s1st[26]+s1st[27];                // latch2 state errors
D 24
  scaler_vals[39]=trgs[66]-(trgs[65]+s1st[24]);              // l2 start-(pass+fail)
E 24
I 24
  scaler_vals[39]=trgs[66]-(trgs[65]+trgs[64]);              // l2 start-(pass+fail)
E 24
  scaler_vals[40]=trgs[64]-(trgs[67]+s1st[24]);              // l2 fail-(clear+latefail)
  scaler_vals[41]=trgs[68]-(trgs[65]+s1st[24]);              // l2 accept-(pass+latefail)
  scaler_vals[42]=trgs[68]-trgs[69];                         // l2accept-l3accept

E 20
D 24
  
E 24

D 17

  // ??? don't know why this happens ???
E 17
I 17
D 20
  // bombproof...???
E 20
I 20
D 24
  // bombproof livetimes...???
E 20
E 17
  for(i=20;     i<23; i++) if(scaler_vals[i]>1.)scaler_vals[i]=0.;
E 24
I 24
D 26
  // raw l2 sector rates from trgd
E 26
I 26
  // gated l2 sector rates from trgd
E 26
  for(i=0; i<6; i++) 
D 27
    scaler_vals[43+i]=(double)trgd[72]/deltat;               // sector l2 rates
E 27
I 27
    scaler_vals[43+i]=(double)trgd[72+i]/deltat;             // sector l2 rates
E 27
I 26
  scaler_vals[49]=(double)trgd[78]/deltat;                   // l2_or
  scaler_vals[50]=(double)trgd[79]/deltat;                   // l2_ok
E 26


  // accepted rates from s1st bank
  for(i=0; i<12; i++) 
D 26
      scaler_vals[49+i]=(double)s1sd[i]/deltat;              // bit l1 rates
  scaler_vals[61]=(double)s1sd[12]/deltat;                   // event rate
E 26
I 26
      scaler_vals[51+i]=(double)s1sd[i]/deltat;              // bit l1 rates
  scaler_vals[63]=(double)s1sd[12]/deltat;                   // event rate
E 26
  for(i=0; i<6; i++) 
D 26
      scaler_vals[62+i]=(double)s1sd[17+i]/deltat;           // sector l2 rates
  scaler_vals[68]=(double)s1sd[23]/deltat;                   // l2 pass rate
  scaler_vals[69]=(double)s1sd[24]/deltat;                   // l2 fail rate
E 26
I 26
      scaler_vals[64+i]=(double)s1sd[17+i]/deltat;           // sector l2 rates
  scaler_vals[70]=(double)s1sd[23]/deltat;                   // l2 pass rate
  scaler_vals[71]=(double)s1sd[24]/deltat;                   // l2 fail rate
E 26


I 41
  // or and random live times
  scaler_vals[72]=(trgd[60]>0)?(double)trgd[34]/trgd[60]:0;  // live_or
  scaler_vals[73]=(trgd[19]>0)?(double)trgd[35]/trgd[19]:0;  // live_random


E 41

  // bombproof livetimes...not sure why this is needed...
  for(i=20; i<23; i++) if(scaler_vals[i]>1.)scaler_vals[i]=0.;
I 41
  for(i=72; i<74; i++) if(scaler_vals[i]>1.)scaler_vals[i]=0.;
E 41
E 24

E 16
E 14

E 12
D 10
    char *help =
    "\nTcl commands available in the alarm_handler program:\n\n"
    " help                  print this message\n"
    " stop                  stop program\n"
    " quit                  stop program\n"
    " exit                  stop program\n"
    "\n\n Type command that require args with NO args for more information\n"
    "\n";
E 10
I 10
  // connect
  if(timeline_connect()==0) {
D 48
    time_t now = time(NULL);
E 48
    if(debug!=0)cerr << types[(int)arg] << " unable to connect at " << ctime(&now) << flush;
    return;
  }
E 10

D 10
    Tcl_SetResult(interp,help,TCL_STATIC);
E 10

D 10
  return (TCL_OK);
E 10
I 10
  // make entry
  nentry[(int)arg]++;
E 10
D 12

D 10
}
E 10

I 10
  // l1 bit rates, l1 and l2 start,clear,pass,fail, etc.
E 12
I 12
D 31
D 33
  timeline_put_group(run,0,"scalers",scaler_names,scaler_vals,nscaler);
E 33
I 33
D 48
  timeline_put_group(run,0,(char*)"scalers",(char**)scaler_names,scaler_vals,nscaler);
E 48
I 48
D 49
  //  timeline_put_group(run,0,(char*)"scalers",(char**)scaler_names,scaler_vals,nscaler);
E 49
I 49
  timeline_put_group(run,0,(char*)"scalers",(char**)scaler_names,scaler_vals,nscaler);
E 49
E 48
E 33
E 31
I 31
  timeline_put_group(run,0,(char*)"scalers",(char**)scaler_names,scaler_vals,nscaler);
E 31
E 12
E 10

D 10
//---------------------------------------------------------------------
E 10

I 10
  // disconnect
  timeline_disconnect(); 
I 44


  // record entry time
  last_scaler=now;
E 44
I 16
D 42


  // record entry time
  last_scaler=now;
E 42
E 16
E 10

D 10
int tcl_quit(ClientData clientdata, Tcl_Interp *interp,
	     int argc, char **argv) {
  
  cout << "...received Tcl quit message..." << endl;
  done=1;
  
  return (TCL_OK);
E 10
I 10

  return;
E 10
}

I 10
  
//----------------------------------------------------------------
E 10

D 10
//---------------------------------------------------------------------
E 10
I 10

void systats_callback(T_IPC_CONN conn,
		      T_IPC_CONN_PROCESS_CB_DATA data,
		      T_CB_ARG arg) {
    

I 11
    int i;
E 11
    T_INT4 stime,net_in,net_in_err,net_out,net_out_err,net_collision;
    T_REAL8 temp_free,swap_free,mem_free,cpu_idle_avg;
D 11
    T_REAL8 *cpu_idle;
E 11
I 11
    T_INT4 *cpu_idle;
E 11
    T_INT4 asize;
    T_INT4 run=get_run_number(msql_database,session);
    TipcMsg msg(data->msg);
    
    
    nmsg[(int)arg]++;
    
    
    //  testing?
    if(no_timeline)return;
    
    
    // extract data
    msg >> stime >> temp_free >> swap_free >> net_in >> net_in_err >> net_out >> net_out_err
D 11
	>> net_collision >> mem_free >> cpu_idle_avg >> GetSize(&asize) >> cpu_idle;
E 11
I 11
	>> net_collision >> mem_free >> cpu_idle_avg >> cpu_idle >> GetSize(&asize);
E 11
    systats_vals[0]=temp_free;
    systats_vals[1]=swap_free;
    systats_vals[2]=net_in;
    systats_vals[3]=net_in_err;
    systats_vals[4]=net_out;
    systats_vals[5]=net_out_err;
    systats_vals[6]=net_collision;
    systats_vals[7]=mem_free;
    systats_vals[8]=cpu_idle_avg;
D 11
    for(int i=0; i<asize; i++)systats_vals[8+i]=cpu_idle[i];
E 11
I 11
D 56
    for(i=0; i<max(ncpu00,ncpu10); i++)systats_vals[9+i]=0;
E 56
I 56
    for(i=0; i<MAX(ncpu00,ncpu10); i++)systats_vals[9+i]=0;
E 56
    for(i=0; i<asize; i++)systats_vals[9+i]=cpu_idle[i];
E 11

    
    // connect
    if(timeline_connect()==0) {
	time_t now = time(NULL);
	if(debug!=0)cerr << types[(int)arg] << " unable to connect at " << ctime(&now) << flush;
	return;
    }


    // make entry
    nentry[(int)arg]++;
D 11
    if(strcasecmp(types[(int)arg],"clon00")==0) {
	//	timeline_put_group(run,0,"systats00",systats_names,systats_vals,nsystats+ncpu00);
    } else if(strcasecmp(types[(int)arg],"clon10")==0) {
	//	timeline_put_group(run,0,"systats10",systats_names,systats_vals,nsystats+ncpu10);
E 11
I 11
    if(strcasecmp(types[(int)arg],"systats00")==0) {
D 31
D 33
	timeline_put_group(run,0,"systats00",systats_names,systats_vals,nsystats+ncpu00);
E 33
I 33
	timeline_put_group(run,0,(char*)"systats00",(char**)systats_names,systats_vals,nsystats+ncpu00);
E 33
E 31
I 31
	timeline_put_group(run,0,(char*)"systats00",(char**)systats_names,systats_vals,nsystats+ncpu00);
E 31
    } else if(strcasecmp(types[(int)arg],"systats10")==0) {
D 31
D 33
	timeline_put_group(run,0,"systats10",systats_names,systats_vals,nsystats+ncpu10);
E 33
I 33
	timeline_put_group(run,0,(char*)"systats10",(char**)systats_names,systats_vals,nsystats+ncpu10);
E 33
E 31
I 31
	timeline_put_group(run,0,(char*)"systats10",(char**)systats_names,systats_vals,nsystats+ncpu10);
E 31
    } else {
	cerr << "?illegal systats input arg: " << (int)arg 
	     << ",  type: " << types[(int)arg] << endl;
E 11
    }
    
    
    // disconnect
    timeline_disconnect(); 
    
    
    return;
}

  
//----------------------------------------------------------------
D 34
//----------------------------------------------------------------
E 34
I 22


void alarm_callback(T_IPC_CONN conn,
		    T_IPC_CONN_PROCESS_CB_DATA data,
		    T_CB_ARG arg) {
    

    int i;
    T_INT4 run=get_run_number(msql_database,session);
    T_INT4 alarm_count;
    TipcMsg msg(data->msg);
    
    
    nmsg[(int)arg]++;
    
    
    //  testing?
    if(no_timeline)return;
    
    
    // extract data
    msg >> alarm_count;
    alarm_vals[0]=(float)alarm_count;

    
    // connect
    if(timeline_connect()==0) {
	time_t now = time(NULL);
	if(debug!=0)cerr << types[(int)arg] << " unable to connect at " << ctime(&now) << flush;
	return;
    }


    // make entry
    nentry[(int)arg]++;
D 23
    timeline_put_group(run,0,"alarm_checker",alarm_names,alarm_vals,nalarm);
E 23
I 23
D 31
D 33
    timeline_put_group(run,0,"alarm_system",alarm_names,alarm_vals,nalarm);
E 33
I 33
    timeline_put_group(run,0,(char*)"alarm_system",(char**)alarm_names,alarm_vals,nalarm);
E 33
E 31
I 31
    timeline_put_group(run,0,(char*)"alarm_system",(char**)alarm_names,alarm_vals,nalarm);
E 31
I 25
    
    
    // disconnect
    timeline_disconnect(); 
    
    
    return;
}

  
//----------------------------------------------------------------
D 34
//----------------------------------------------------------------
E 34


void trigmon_callback(T_IPC_CONN conn,
		      T_IPC_CONN_PROCESS_CB_DATA data,
		      T_CB_ARG arg) {
  

    int i;
    T_INT4 run=get_run_number(msql_database,session);
    TipcMsg msg(data->msg);
    T_REAL8 *l2effic;
    
    
    nmsg[(int)arg]++;
    
    
    //  testing?
    if(no_timeline)return;
    
    
    // extract data
    msg >> l2effic;
    for(i=0; i<ntrigmon; i++)trigmon_vals[i]=l2effic[i];

    
    // connect
    if(timeline_connect()==0) {
	time_t now = time(NULL);
	if(debug!=0)cerr << types[(int)arg] << " unable to connect at " << ctime(&now) << flush;
	return;
    }


    // make entry
    nentry[(int)arg]++;
D 31
D 33
    timeline_put_group(run,0,"trigmon",trigmon_names,trigmon_vals,ntrigmon);
E 33
I 33
    timeline_put_group(run,0,(char*)"trigmon",(char**)trigmon_names,trigmon_vals,ntrigmon);
E 33
E 31
I 31
    timeline_put_group(run,0,(char*)"trigmon",(char**)trigmon_names,trigmon_vals,ntrigmon);
E 31
E 25
E 23
    
    
    // disconnect
    timeline_disconnect(); 
    
    
I 34
    return;
}

  
D 37
//----------------------------------------------------------------


void epics_callback(T_IPC_CONN conn,
		    T_IPC_CONN_PROCESS_CB_DATA data,
		    T_CB_ARG arg) {
    

    static long eb = 0;

    TipcMsg msg(data->msg);
    T_STR eb_status;
    T_INT8 csr;
    
    
    nmsg[(int)arg]++;
    
    
    //  testing?
    if(no_timeline)return;
    
    
    // eber or ts message
    if((int)arg==9) {
	msg.Current(2);
	msg >> eb_status;

	if(strcasecmp(eb_status,"booted")==0) {
	    eb=1;
	} else if(strcasecmp(eb_status,"configured")==0) {
	    eb=2;
	} else if(strcasecmp(eb_status,"downloaded")==0) {
	    eb=3;
	} else if(strcasecmp(eb_status,"prestarted")==0) {
	    eb=4;
	} else if(strcasecmp(eb_status,"active")==0) {
	    eb=5;
	} else if(strcasecmp(eb_status,"paused")==0) {
	    eb=6;
	} else if(strcasecmp(eb_status,"ended")==0) {
	    eb=7;
	} else {
	    eb=0;
	}

    } else if ((int)arg==10) {
	msg.Current(5);
	msg >> csr;

	nentry[(int)arg]++;
	put_epics_ca_l("ts_status","VAL",(long)(csr&0x1));
	put_epics_ca_l("eb_status","VAL",eb);
    }

E 34
    return;
}

E 37
  
//----------------------------------------------------------------
//----------------------------------------------------------------


E 22
E 10
E 1
