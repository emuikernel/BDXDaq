# makeSymTbl.tcl - built-in system symbol table creation utility
#
# Copyright 2001-2002 Wind River Systems, Inc.
#
# modification history
# --------------------
# 01d,18nov02,mcm  added support for some of Diab's intrinsic routines.
# 01c,31jan02,fmk  write directly to a file to generate symTbl.c rather than
#                  use redirection
# 01b,13dec01,j_s  prepend '0x' to absolute address
# 01a,30oct01,j_s   created based on TAE 3.1 utility (base version:
#                  makeSymTbl.tcl@@/main/tor3_x/10).
#
# SYNOPSIS:
# .tS
# makeSymTbl.tcl <cpu type> <objMod>
# .tE
#
# DESCRIPTION
# This tool creates the C code for a symbol table structure containing the
# names, addresses, and types of all meaningful global symbols in the specified
# object module; the generated code is written to standard output.
#
# This tool is used only when creating a standalone system (`vxWorks.st').
# Development systems do not need this since the system symbol table is
# constructed by reading and interpreting the symbol table contained in the
# loadable system symbol table module (`vxWorks.sym'), either from the local
# boot disk (floppy, ata/ide, scsi, etc.) or from a host system over the
# network.
#
# The built-in symbol table is an array of type SYMBOL accessible through
# the global variable `standTbl'.  The array contains `standTblSize' elements.
# These are the only external declarations in the generated code. When the
# standalone VxWorks image is built from a BSP the symbols are inserted in
# the system symbol table  by # usrRoot() in usrConfig.c. When the standalone
# VxWorks image is built from a project, the symbols are inserted by the
# usrStandaloneInit() routine in the comps/src/usrStandalone.c configlette.
#
# For an example, see the file $WIND_BASE/target/config/<bspName>/symTbl.c,
# which is generated by this tool for `vxWorks.st' in the same directory.
#
# FILES
# .TS
# tab(|);
# lf3 l.
# symLib.h   |  symbol table header file
# symbol.h   |  VxWorks symbol definitions header file
# .TE
#
# SEE ALSO:
#
# NOROUTINES


# namespace globals

namespace eval makeSymTbl {
    set nmCmd		"nm"
    set nmFlags		"-g"
    set textSymPrefixToIgnore ""
    set dataSymPrefixToIgnore ""
    set cpuType		""
    set fdOut           ""
}

##############################################################################
#
# standTblCreate - create an array of symbol for an object module
#
# This procedure creates an array of symbols (C code) based on a file symbol
# table.
#
# The input of this procedure is a module. The output of this
# procedure is stored in a file named symTbl.c.
#
# SYNOPSIS:
#   standTblCreate { objMod }
#
# PARAMETERS:
#   module name
#
# RETURNS: number of symbols in the module's symbol table
#
# ERRORS: N/A
#

proc makeSymTbl::standTblCreate {modName} {
    variable textSymPrefixToIgnore
    variable dataSymPrefixToIgnore
    variable cpuType

    set symbolInfo ""
    set symList {}
    set nsyms 0

    # get all the global/local symbols from the object module

    set symbolInfo [eval exec $makeSymTbl::nmCmd $makeSymTbl::nmFlags $modName]

    # replace consecutive whitespaces with single whitespace

    regsub -all { +} $symbolInfo " " symbolInfo

    set symbolInfoListRaw [split $symbolInfo \n]
    set symbolTblEntryList {}

    # Reject the symbols that are either meaningless for VxWorks or local
    # symbols (then can not be linked). These symbols are represented by the
    # following letters in nm's output:
    #
    # G: symbol from an initialized data section for small objects (not
    #    supported in VxWorks).
    # I: indirect reference to another symbol (extension of the a.out format
    #    specific to GNU)
    # N: debugging symbol (no point in having them in the system's symbol
    #    table).
    # S: symbol from an uninitialized data section for small objects (not
    #    supported in VxWorks).
    # U: undefined symbols (hence not part of the system's symbol table).
    # -: stabs symbol in an a.out object file (no point in having them in the
    #    system's symbol table).
    # ?: symbol of unknown type.
    #
    # all lower case letters: local symbols (can not be used to link symTbl.c
    #    with the VxWorks library).
    #
    # See gnu/binutils/binutils.texi for a complete explanation of the letters
    # representing the symbol types.

    foreach symbolEntry $symbolInfoListRaw {
        if [regexp {^.* [a-zGINSU\?\-] .*$} $symbolEntry] {
	    continue
	}

	# for 68k and coldfire, all global symbols which don't begin with '_'
	# should be filtered out. Such symbols are from assembly code and can't
	# be referenced in C file. Subsequently, they can't be in symTbl.c.
	# To make global symbols defined in assembly code valid for
	# standalone symbol table, they have to begin with '_'. Note this
	# is true for 68k and coldfire only.

	if [regexp {^.* . [^_].*$} $symbolEntry] {
	    if {($cpuType == "68k") || ($cpuType == "cf")} {
		continue
    	    }
 	}

 	# Symbols with '.' in its name in C file will give parse error
	# so filter out all symbols with '.' in its name

	if [regexp {^.* . .*\.} $symbolEntry] {
	    continue
	}

	# for simpc, all symbols with suffix in form of "@<number>" are
	# filtered out

	if {$cpuType == "simpc"} {
	    if [regexp {^.* . .*@[0-9]*} $symbolEntry] {
		continue
	    }
  	}

	if {![regexp {^(.*) (.*) (.*)} $symbolEntry dummy addr type name]} {
	    continue
	}

        # Convert the filtered nm output to an IMPORT list of symbols;
        # Some symbols that are declared in sllLib.h, which is included in the
        # resulting symTbl.c through symbol.h, must be declared correctly or 
	# they cause multiple definition complaints. Some intrinsic routines
	# for Diab (__ff* functions) also need to be correctly declared.
	#
	# Symbols could be of following types:
	#
	# A: the symbol's value is absolute, and will not be changed by further
	#    linking.
	# B: the symbol is in the uninitialized data section (known as BSS).
	# C: the symbol is common. Common symbols are uninitialized data.
	# D: the symbol is in the initialized data section.
	# R: the symbol is in a read only data section.
	# T: the symbol is in the text (code) section.
	# V: the symbol is a weak object.
	# W: the symbol is a weak symbol that has not been specifically tagged
	#    as a weak object symbol.

	switch -glob $type {
	    [DR] { 
		regsub $dataSymPrefixToIgnore $name "" name
		puts $makeSymTbl::fdOut "IMPORT int ${name};"
		lappend symbolTblEntryList "\{\{NULL\},\
			                   \"$dataSymPrefixToIgnore$name\",\
					  (char*) \&$name, 0, SYM_GLOBAL | SYM_DATA\},"
	    }
	    [BC] { 
		regsub $dataSymPrefixToIgnore $name "" name
		puts $makeSymTbl::fdOut "IMPORT int ${name};"
		lappend symbolTblEntryList "\{\{NULL\},\
					    \"$dataSymPrefixToIgnore$name\",\
				           (char*) \&$name, 0, SYM_GLOBAL | SYM_BSS\},"
	    }
	    [TWV] { 
		regsub $textSymPrefixToIgnore $name "" name
		switch -glob $name {
		    sllCreate   {puts $makeSymTbl::fdOut "IMPORT SL_LIST *sllCreate ();"}
	            sllGet      {puts $makeSymTbl::fdOut "IMPORT SL_NODE *sllGet ();"}
	            sllPrevious {puts $makeSymTbl::fdOut "IMPORT SL_NODE *sllPrevious ();"}
		    sllEach     {puts $makeSymTbl::fdOut "IMPORT SL_NODE *sllEach ();"}
	            sllPutAt*   {puts $makeSymTbl::fdOut "IMPORT void $name ();"}
	            sllRemove   {puts $makeSymTbl::fdOut "IMPORT void sllRemove ();"}
	            __ff1       {puts $makeSymTbl::fdOut "IMPORT unsigned int __ff1 (unsigned int);"}
	            __ff1l       {puts $makeSymTbl::fdOut "IMPORT unsigned int __ff1l (unsigned int);"}
	            __ff1ll       {puts $makeSymTbl::fdOut "IMPORT unsigned int __ff1ll (unsigned long long);"}
		    default     {puts $makeSymTbl::fdOut "IMPORT int $name ();"}
		}
		lappend symbolTblEntryList "\{\{NULL\},\
					   \"$textSymPrefixToIgnore$name\",\
				           (char*) $name, 0, SYM_GLOBAL | SYM_TEXT\},"
	    }
	    [A] {
		lappend symbolTblEntryList "\{\{NULL\},\"$name\",\
				 (char*) 0x$addr, 0, SYM_GLOBAL | SYM_ABS\},"
	    }
	    default {
		puts "Warning: makeSymTbl.tcl - invalid symbol information \
		      ($symbolEntry)"
	    }
        }
    }

    set nsyms [llength $symbolTblEntryList]

    # convert nm output to symbol entries in array

    puts $makeSymTbl::fdOut ""
    puts $makeSymTbl::fdOut "SYMBOL standTbl \[$nsyms\] ="
    puts $makeSymTbl::fdOut "    {"

    foreach symbolTblEntry $symbolTblEntryList {
        puts $makeSymTbl::fdOut "        $symbolTblEntry"
    }

    puts $makeSymTbl::fdOut "    };"
    puts $makeSymTbl::fdOut ""

    return $nsyms
}

##############################################################################
#
# main - entry point of utility
#

# check for correct number of args

if {$argc < 3} {
    puts stderr "Usage: makeSymTbl.tcl <cpu type> <objMod> <file>"
    exit 1
}

set outFile [lindex $argv 2]

# set appropriate version of the nm command for the processor

if [catch {set makeSymTbl::cpuType [lindex $argv 0]}] {
    set makeSymTbl::cpuType ""
}

set makeSymTbl::nmCmd "nm$makeSymTbl::cpuType"

# For sh/68k/cf/simpc, the prefixed '_' are ignored for both text and data
# symbols when declare the symbols in symTbl.c

if {($makeSymTbl::cpuType == "sh") || ($makeSymTbl::cpuType == "68k") || \
    ($makeSymTbl::cpuType == "cf") || ($makeSymTbl::cpuType == "simpc")} {
    set makeSymTbl::textSymPrefixToIgnore "_"
    set makeSymTbl::dataSymPrefixToIgnore "_"
}

# parse the arguments

set modName [lindex $argv 1]

# Create the module's standalone symbol table

set makeSymTbl::fdOut [open $outFile w+]

# The following (C code) goes into the wrapper file symTbl.c

puts $makeSymTbl::fdOut "/* symTbl.c - standalone symbol tables wrapper */"
puts $makeSymTbl::fdOut ""
puts $makeSymTbl::fdOut "/* CREATED BY $argv0"
puts $makeSymTbl::fdOut " *  WITH ARGS $argv"
puts $makeSymTbl::fdOut " *         ON [clock format [clock seconds]]"
puts $makeSymTbl::fdOut " */"
puts $makeSymTbl::fdOut ""
puts $makeSymTbl::fdOut "#include \"vxWorks.h\""
puts $makeSymTbl::fdOut "#include \"symbol.h\""
puts $makeSymTbl::fdOut ""

# Just for VxSim: undef of READ and WRITE defined in vxWorks.h

if {($makeSymTbl::cpuType == "simpc") || ($makeSymTbl::cpuType == "simso")} {
    puts $makeSymTbl::fdOut "/* VxSim: undefine READ and WRITE which are macros from VxWorks.h */"
    puts $makeSymTbl::fdOut ""
    puts $makeSymTbl::fdOut "#undef READ"
    puts $makeSymTbl::fdOut "#undef WRITE"
    puts $makeSymTbl::fdOut ""
}   

set nsyms [makeSymTbl::standTblCreate $modName]

puts $makeSymTbl::fdOut ""
puts $makeSymTbl::fdOut "ULONG standTblSize = ${nsyms};"

close $makeSymTbl::fdOut
