# wtxOpenTest.tcl - Tcl script, test WTX_OPEN
#
# Copyright 1995 Wind River Systems, Inc.
#
#
# modification history
# --------------------
# 01y,18jan99,p_b  rename wtxCommonProc.tcl in wtxtestlib.tcl
# 01x,28jan98,p_b  Adapted for WTX 2.0
# 01w,05dec96,jmp  replaced /tmp/foo by /tmp/viotest<pid>.
# 01v,13sep96,jmp  added a test in wtxOpenTest1{} to cover SPR# 5949.
# 01u,11jul96,jmp  replaced host specific flags by WTX_OPEN_FLAG flags.
# 01t,20oct95,jmp  added invalidAddr argument to wtxOpenTest.
# 01s,11sep95,jmp  removed a bug in call of cleanUp procedure.
# 01r,18aug95,jmp  changed call of readContextCreate
#		   added timeout to wtxToolAttachCall in wtxOpenTest.
#                  changed openVio to vioOpen, closeVio to vioClose,
#                  emptyVio to vioEmpty.
#                  changed tests control method, now uses wtxErrorHandler.
# 01q,23jun95,f_v  added wtxTestRun call
# 01p,21jun95,f_v  clean up main procedure
# 01o,30may95,f_v  managed new Vio implementation
# 01n,22may95,jcf  name revision.
# 01m,28apr95,c_s  now uses wtxErrorMatch.
# 01l,27apr95,f_v  replace call to funcCall1 by funcCall
# 01k,13apr95,f_v  moved openVio,emptyVio,readContextCreate
#		   to wtxtestlib.tcl
# 01j,07apr95,f_v  change few error messages
# 01i,30mar95,f_v  replace S_wdb_xx by agentErr
# 01h,28mar95,f_v  added wtxRegisterForEvent
# 01g,03mar95,f_v  change S_tgtMemLib_XXX by tgtMemErr(XXX)
# 01f,20feb95,kpn  changed wtxMemZero -> wtxMemSet
#                  replaced wtxFuncCall() and wtxEventPoll by funcCall() or
#                  funcCall3().
#		   added tgtSvrErr and vxWorksErr. 
#		   added readContextCreate{}
# 01e,14feb95,kpn  added openVio{}, emptyVio{}, wtxOpenTest6{}
#		   wtxOpenTest7{}
# 01d,27jan95,kpn  deplaced testcase units description in wtxTestMsg and 
#		   testcase units errors in wtxTestErr.tcl,
#                  added global openMsg in the main,
#		   added global errVioMsg in each testcase units,
#		   used openMsg & errVioMsg to manage messages.
# 01b,26Jan95,kpn  removed the calls to wtxToolAttachCall and wtxToolDetach
#                  made in each testcase.
#                  Added wtxToolAttachCall and wtxToolDetachCall in the main
#                  procedure.
#		   removed error codes initialization, added global variables.
# 01a,17Jan95,kpn  written.
#
#

#
# DESCRIPTION
#
# WTX_OPEN - open a file for virtual I/O
#
# TESTS of calls to wtxOpen with valid parameters :
#
# (1) wtxOpenTest1 - verify that the opening of an existing file for reading, 
#	with no virtual I/O redirection, returns a valid file descriptor and
#	that nothing is written in the VIO.
# (2) wtxOpenTest3 - verify that the opening of a pipe for reading, with no 
#       virtual I/O redirection, returns a valid file descriptor and that
#	nothing is written in the VIO.
# (3) wtxOpenTest4 - verify that when an existing file is opened for 
#	reading with virtual I/O redirection, the redirection is performed 
#	into the right channel and the file has been passed on entirely. 
# (4) wtxOpenTest5 - verify that when a pipe is opened for reading with 
#	virtual I/O redirection, the redirection is performed into the right
#	channel and that the pipe command result has been passed on entirely.
#		     
#
# TESTS of calls to wtxOpen with invalid parameters :
#
# (5) wtxOpenTest2 - verify the opening of an non-existent file for reading 
#	with no virtual I/O redirection / with virtual I/O redirection,
#	generates the error code ENOENT and that nothing is written in 
#	the VIO. 
# (6) wtxOpenTest6 - verify that the opening of a pipe with an 
#	invalid <flag>, with no virtual I/O redirection / with virtual I/O 
#	redirection, generates the error code WTX_ERR_SVR_INVALID_FLAGS 
#	and that nothing is written in the VIO.
#
# (7) wtxOpenTest7 - verify that the opening of an existing file for 
#	reading with an invalid <channel> generates an error code
#
#       >>>> This test must not be executed. It generates a Bus Error
#	     on the target.
#       >>>> The agent and the target server don't manage this error 
#            (invalid channel).
#


#*************************************************************************
#
# wtxOpenTest1 - verify that the opening of an existing file for reading, with  
#		 no virtual I/O redirection, returns a valid file descriptor
#		 and that nothing has been written in the VIO.
#
# This test verifies wtxOpen routine result when it's called with these 
# valid parameters :
# <filename> : the name of an existing file 
# <flags>    : WTX_O_RDONLY (open for reading only)
# <mode >    : 0
# <channel>  : -1 (no  virtual  I/O  redirection)
#

proc wtxOpenTest1 {Msg} {


 # GLOBAL VARIABLES

    # array that contains the testcase error codes
    global errVioMsg
    # array that contains the environment variables
    global env

    puts stdout "$Msg" nonewline

 # LOCAL VARIABLES

    # channel id for redirection
    set chanId -1
    set channel 0
    # mode value for wtxOpen
    set mode 0
    # max size for buffer that receives read bytes on a virtual I/O
    set readBytesMaxNum 512
    # maximum number of bytes that can be read in one time on a virtual I/O
    set maxBytesRead 512



 # PATH and length of the file that will be passed as argument to wtxOpen 
 # routine

    # check the WIND_BASE environment variables exists
    set findWindBaseVar [info exists env(WIND_BASE)]
    # WIND_BASE environment variable doesn't exist : display a message
    if {$findWindBaseVar == 0} {
        testFail $errVioMsg(1)
        return
    }

    # get the value of the WIND_BASE environment variable
    set windBasePath [set env(WIND_BASE)]
    # path of the file that will be opened 
    set OpenTestFile "$windBasePath/host/resource/test/vioTestFile"
    # verify the file exists
    if {[file exists $OpenTestFile] == 0} {
	testFail "\ncannot find file: $OpenTestFile"
        return
    }

    # open the file "vioTestFile" for reading, return a file identifier
    set fileIdent [open $OpenTestFile r]
    # read and return all of the bytes remaining in the previously opened file
    set bytesRead [read $fileIdent]
    # get the length of read bytes block
    set bytesReadBlockLength [expr [string length $bytesRead] + 1]


 # OPEN VIO

    set resVioOpen [vioOpen]

    if {[lindex $resVioOpen 0] == 0} {
	puts stdout $errVioMsg(20)
	cleanUp f $fileIdent
	return
    }

    # get the file descriptor of the file associated with VIO,
    # necessary to can close the file at the end of the test
    set fileDescriptor [lindex $resVioOpen 0]
    set channelNb  [lindex $resVioOpen 1]


 # EMPTY THE VIO

    set resVioEmpty [vioEmpty $fileDescriptor $readBytesMaxNum $maxBytesRead]
    if {[lindex $resVioEmpty 0] == 0} {
        puts stdout $errVioMsg(19)
	cleanUp f $fileIdent
	vioClose $fileDescriptor $channelNb
        return
	}

    set roomDataRead [lindex $resVioEmpty 0]


 # READ DATA FROM VIO

    set targetSystemAssignedId [readContextCreate $fileDescriptor $roomDataRead]
    if {$targetSystemAssignedId == 0} {
        puts stdout $errVioMsg(24)
	cleanUp f $fileIdent ms $roomDataRead
	vioClose $fileDescriptor $channelNb
        return
    }


 # WTXOPEN with  NO VIO redirection

    # channel is set to -1 so no  virtual  I/O  redirection are performed,
    # wtxOpen opens the file $OpenTestFile for reading
    # wtxOpen returns a descriptor for that file 
    set fileDesc [wtxOpen -channel $chanId $OpenTestFile WTX_O_RDONLY $mode]

    if {$fileDesc == ""} {
	cleanUp f $fileIdent ms $roomDataRead c $targetSystemAssignedId
	vioClose $fileDescriptor $channelNb
        return
    }

    after 1000


 # READ the content of the VIO

    # read the bytes at the address $roomDataRead on the target
    set blockRead [wtxMemRead $roomDataRead $bytesReadBlockLength]
    if {$blockRead == ""} {
	cleanUp f $fileIdent vs $fileDesc ms $roomDataRead\
		 c $targetSystemAssignedId
	vioClose $fileDescriptor $channelNb
        return
    }

    # get the contents of this block
    set blockReadContent [memBlockGet $blockRead]


 # VERIFY that nothing has been written in the VIO.

    # clear a memory block of bytes, the content of the VIO must be equal
    # to this block.
    set clearBlock [memBlockCreate -B $bytesReadBlockLength 0x00]
    set clearBlockGet [memBlockGet $clearBlock]

    # free memBlock
    cleanUp mb $clearBlock

    if {$blockReadContent != $clearBlockGet} {
	cleanUp f $fileIdent vs $fileDesc ms $roomDataRead \
		c $targetSystemAssignedId
	vioClose $fileDescriptor $channelNb
        testFail $errVioMsg(18)
        return
    }
    # kill read() function that waits data
    set killSt [wtxContextKill CONTEXT_TASK $targetSystemAssignedId]


 # VERIFY the file descriptor returned by wtxOpen is valid

    # close the file specified by the descriptor returned by wtxOpen
    set resCloseVio [wtxClose $fileDesc]
    if {$resCloseVio == ""} {
	cleanUp f $fileIdent ms $roomDataRead
	vioClose $fileDescriptor $channelNb
        testFail $errVioMsg(4)
        return
    }


 #
 # Small test to cover SPR# 5949:
 #	Target server dies if file opened for VIO redirect is deleted
 #
 # Open a file for read and delete this file, this test is very special
 # since we can't determine if it is Ok or not.
 #
 # If this test fails the Target Server will eventually display:
 #	Error: tgtRpcLoop: - Select failed
 # and then terminate.
 # 
 set tmpFile "/tmp/viotest[pid]"
 wtxOpen -channel 4 $tmpFile WTX_O_CREAT 0666
 file delete $tmpFile


 # clean up

    cleanUp f $fileIdent ms $roomDataRead
    vioClose $fileDescriptor $channelNb

    wtxTestPass
}

#*************************************************************************
#
# wtxOpenTest2 - verify that the opening of an non-existent file for reading,
#                with no virtual I/O redirection / with VIO redirection,
#		 generates the error code ENOENT and that nothing is written
#		 in the VIO.
#
# This test verifies wtxOpen routine result when it's called with these
# parameters :
# <filename> : invalid (doesn't exist)
# <flags>    : WTX_O_RDONLY (open for reading only)
# <mode >    : 0
# <channel>  : -1 (no virtual I/O redirection) /
#		0 (virtual I/O redirection) 
#

proc wtxOpenTest2 {Msg} {


 # GLOBAL VARIABLES

    # array that contains the testcase error codes
    global errVioMsg
    global errMemMsg
    global agentErrMsg

    puts stdout "$Msg" nonewline

 # LOCAL VARIABLES

    # channel id for redirection
    set chanId  -1 
    set channel 0
    # mode value for wtxOpen
    set mode 0
    # max size for buffer that receives read bytes on a virtual I/O
    set readBytesMaxNum 512
    # maximum number of bytes that can be read in one time on a virtual I/O
    set maxBytesRead 512


 # OPEN Virtual I/O

    set resVioOpen [vioOpen]

    if {[lindex $resVioOpen 0] == 0} {
        puts stdout $errVioMsg(20)
        return
        }

    # get the file descriptor of the file associated with VIO channel chanNb,
    # necessary to can close the file at the end of the test
    set fileDescriptor  [lindex $resVioOpen 0]
    set chanNb [lindex $resVioOpen 1]


 # EMPTY THE VIO

    set resVioEmpty [vioEmpty $fileDescriptor $readBytesMaxNum $maxBytesRead]
    if {[lindex $resVioEmpty 0] == 0} {
        puts stdout $errVioMsg(19)
	vioClose $fileDescriptor $chanNb
        return
    }

    set roomDataRead [lindex $resVioEmpty 0]


 # READ DATA FROM VIO

    set targetSystemAssignedId [readContextCreate $fileDescriptor $roomDataRead]
    if {$targetSystemAssignedId == 0} {
        puts stdout $errVioMsg(24)
        vioClose $fileDescriptor $chanNb
	cleanUp ms $roomDataRead
        return
    }


 # WTXOPEN with NO VIO redirection

    # <channel> is set to -1 so no  virtual  I/O  redirection are performed,
    # <filename> doesn't exist

    # if no exception occurred 
    if {![catch "wtxOpen -channel $chanId invalidFileName\
	WTX_O_RDONLY $mode" errCode]} {
	testFail $errVioMsg(5)
	cleanUp ms $roomDataRead c $targetSystemAssignedId
	vioClose $fileDescriptor $chanNb
	return
	}

    # if the caught exception is different than the expected error code
    if {![wtxErrorMatch $errCode "No such file or directory"]} {
        testFail $errCode
	cleanUp ms $roomDataRead c $targetSystemAssignedId
	vioClose $fileDescriptor $chanNb
        return
    }

    after 1000


 # READ the content of the VIO

    # read the bytes at the address $roomDataRead on the target
    if {[catch "wtxMemRead $roomDataRead 100" blockRead]} {
        testFail $blockRead
	cleanUp ms $roomDataRead c $targetSystemAssignedId
        vioClose $fileDescriptor $chanNb
        return
    }

    # get the contents of this block
    catch "memBlockGet $blockRead" blockReadContent


 # VERIFY that nothing has been written in the VIO.

    # clear a memory block of  bytes, the content of the VIO must be equal
    # to this block.
    set clearBlock [memBlockCreate -B 100 0x00]
    catch "memBlockGet $clearBlock" clearBlockGet

    # free memBlock
    cleanUp mb $clearBlock

    if {$blockReadContent != $clearBlockGet} {
        testFail $errVioMsg(18)
	cleanUp ms $roomDataRead c $targetSystemAssignedId
        vioClose $fileDescriptor $chanNb
        return
    }


 # WTXOPEN with VIO redirection

    # <channel> is set to 0 so virtual I/O redirection are performed,
    # <filename> doesn't exist

    # if no exception occurred
    if {![catch "wtxOpen -channel $chanNb invalidFileName\
	WTX_O_RDONLY $mode" errCode]} {
	testFail $errVioMsg(5)
	cleanUp ms $roomDataRead c $targetSystemAssignedId
	vioClose $fileDescriptor $chanNb
	return
	}

    # if the caught exception is different than the expected error code
    if {![wtxErrorMatch $errCode "No such file or directory"]} {
        testFail $errCode
	cleanUp ms $roomDataRead c $targetSystemAssignedId
        vioClose $fileDescriptor $chanNb
        return
    }

    after 1000


 # READ the content of the VIO

    # read the bytes at the address $roomDataRead on the target
    if {[catch "wtxMemRead $roomDataRead 100" blockRead]} {
        testFail $blockRead
	cleanUp ms $roomDataRead c $targetSystemAssignedId
        vioClose $fileDescriptor $chanNb
        return
    }

    # get the contents of this block
    catch "memBlockGet $blockRead" blockReadContent


 # VERIFY that nothing has been written in the VIO.

    # clear a memory block of  bytes, the content of the VIO must be equal
    # to this block.
    set clearBlock [memBlockCreate -B 100 0x00]
    catch "memBlockGet $clearBlock" clearBlockGet

    # free memBlock
    cleanUp mb $clearBlock

    if {$blockReadContent != $clearBlockGet} {
        testFail $errVioMsg(18)
	cleanUp ms $roomDataRead c $targetSystemAssignedId
        vioClose $fileDescriptor $chanNb
        return
    }

    # clean up
    cleanUp ms $roomDataRead c $targetSystemAssignedId
    vioClose $fileDescriptor $chanNb

    wtxTestPass
}

#*************************************************************************
#
# wtxOpenTest3 - verify that the opening of a pipe for reading, with no
#		 virtual I/O redirection, returns a valid file descriptor
#		 and that nothing is written in the VIO
#
# This test verifies wtxOpen routine result when it's called with these
# valid parameters :
# <filename> : result of the `date` unix command  
# <flags>    : WTX_O_RDONLY (open for reading only)
# <mode >    : 0
# <channel>  : -1 (no  virtual  I/O  redirection)
#

proc wtxOpenTest3 {Msg} {


 # GLOBAL VARIABLES

    # array that contains the testcase error codes
    global errVioMsg

    puts stdout "$Msg" nonewline

 # LOCAL VARIABLES

    # channel id for redirection
    set chanId -1 
    # mode value for wtxOpen
    set mode 0
    # max size for buffer that receives read bytes on a virtual I/O
    set readBytesMaxNum 512
    # maximum number of bytes that can be read in one time on a virtual I/O
    set maxBytesRead 512



 # BYTES NUMBER of the `date` unix command result 

    set date [exec date]
    set dateBlockLength [expr [string length $date] + 1]

 
 # OPEN VIO
    set resVioOpen [vioOpen]

    if {[lindex $resVioOpen 0] == 0} {
        puts stdout $errVioMsg(20)
        return
        }

    # get the file descriptor of the file associated with VIO channel chanNb,
    # necessary to can close the file at the end of the test
    set fileDescriptor  [lindex $resVioOpen 0]
    set chanNb  [lindex $resVioOpen 1]


 # EMPTY THE VIO

    set resVioEmpty [vioEmpty $fileDescriptor $readBytesMaxNum $maxBytesRead]
    if {[lindex $resVioEmpty 0] == 0} {
        puts stdout $errVioMsg(19)
	vioClose $fileDescriptor $chanNb
        return
    }

    set roomDataRead [lindex $resVioEmpty 0]


 # READ DATA FROM VIO

    set targetSystemAssignedId [readContextCreate $fileDescriptor $roomDataRead]
    if {$targetSystemAssignedId == 0} {
        puts stdout $errVioMsg(24)
	vioClose $fileDescriptor $chanNb
	cleanUp ms $roomDataRead 
        return
    }


 # WTXOPEN with NO VIO redirection

    # channel is set to -1 so no  virtual  I/O  redirection are performed,
    # wtxOpen opens pipe for reading
    # wtxOpen return a descriptor 
    set descriptor [wtxOpen -channel $chanId |date WTX_O_RDONLY $mode]
    if {$descriptor == ""} {
	cleanUp ms $roomDataRead c $targetSystemAssignedId
	vioClose $fileDescriptor $chanNb
        return
	}

    after 1000


 # READ the content of the VIO

    # read the bytes at the address $roomDataRead on the target
    set blockRead [wtxMemRead $roomDataRead $dateBlockLength]
    if {$blockRead == ""} {
	cleanUp ms $roomDataRead c $targetSystemAssignedId vs $descriptor
	vioClose $fileDescriptor $chanNb
        return
    }

    # get the contents of this block
    set blockReadContent [memBlockGet $blockRead]


 # VERIFY that nothing has been written in the VIO.

    # clear a memory block of  bytes, the content of the VIO must be equal
    # to this block.
    set clearBlock [memBlockCreate -B $dateBlockLength 0x00]
    set clearBlockGet [memBlockGet $clearBlock]

    # free all memBlocks
    cleanUp mb $clearBlock


    if {$blockReadContent != $clearBlockGet} {
        testFail $errVioMsg(18)
	cleanUp c $targetSystemAssignedId vs $descriptor ms $roomDataRead
	vioClose $fileDescriptor $chanNb
        return
    }

    # kill read() function that waits data
    cleanUp c $targetSystemAssignedId

 # VERIFY the file descriptor returned by wtxOpen is valid

    # close the pipe specified by the descriptor returned by wtxOpen
    set resClose [wtxClose $descriptor]
    if {$resClose == ""} {
        vioClose $fileDescriptor $chanNb
	cleanUp ms $roomDataRead
        testFail $errVioMsg(4)
        return
    }


 # clean up
    vioClose $fileDescriptor $chanNb
    cleanUp ms $roomDataRead

    wtxTestPass
}

#*************************************************************************
#
# wtxOpenTest4 - verify that when an existing file is opened for
#		 reading with virtual I/O redirection, the redirection is
#		 performed into the right channel and the file has been 
#		 passed on entirely.
#
# The content of the file is sent to the virtual I/O.
# This test verifies that the read command executed on the target has
# received the right data from the virtual I/O.
# So it's the reason why we read the wtxOpenTestFile file and put its content
# in a buffer : the result of the read command will be able to be compared
# to the buffer content. The comparison must prove that, when an existing
# file is opened for reading with virtual I/O redirection, the file has been
# passed on entirely.
#
# This test verifies wtxOpen routine result when it's called with these
# valid parameters :
# <filename> : the name of an existing file
# <flags>    : WTX_O_RDONLY (open for reading only)
# <mode >    : 0
# <channel>  : 0 (virtual I/O redirection)
#

proc wtxOpenTest4 {Msg} {


 # GLOBAL VARIABLES

    # array that contains the testcase error codes
    global errVioMsg
    # array that contains the environment variables
    global env

    puts stdout "$Msg" nonewline

 # LOCAL VARIABLES

    # channel id for redirection
    set chanId 0
    # mode value for wtxOpen
    set mode 0
    # max size for buffer that receives read bytes on a virtual I/O
    set readBytesMaxNum 512
    # maximum number of bytes that can be read in one time on a virtual I/O
    set maxBytesRead 512



 # The content of the wtxOpenTestFile file will be send to the virtual I/O.
 # When this is will be done, it will has to verify that the read command
 # on the target has received the right datas from the virtual I/O.
 # So it's the reason why we read the wtxOpenTestFile file and put its content
 # in a buffer : the result of the read command will be able to be compared
 # to the buffer content.

    # check the WIND_BASE environment variables exists
    set findWindBaseVar [info exists env(WIND_BASE)]
    # WIND_BASE environment variable doesn't exist : display a message
    if {$findWindBaseVar == 0} {
        testFail $errVioMsg(1)
        return
    }
    # get the value of the WIND_BASE environment variable
    set windBasePath [set env(WIND_BASE)]

    # path of the file that will be opened
    set OpenTestFile "$windBasePath/host/resource/test/wtxOpenTestFile"
    # verify the file exists
    if {[file exists $OpenTestFile] == 0} {
        testFail "cannot find file: $OpenTestFile"
        return
    }

    # open the file "wtxOpenTestFile" for reading, return a file identifier
    set fileIdent [open $OpenTestFile r]
     
    # read and return all of the bytes remaining in the previously opened file
    set bytesRead [read $fileIdent]

    # create a memory block, filled with the content of the previously 
    # opened file
    set bytesReadBlock [memBlockCreate -string $bytesRead]
    # get the length of read bytes block
    set bytesReadBlockLength [expr [string length $bytesRead] + 1]
    # get the value of this block to can compare it with data read from
    # virtual I/O 
    set blockReadValue [memBlockGet $bytesReadBlock]

    # free memBlock
    cleanUp mb $bytesReadBlock


 # OPEN Virtual I/O
    set resVioOpen [vioOpen]

    if {[lindex $resVioOpen 0] == 0} {
        puts stdout $errVioMsg(20)
	cleanUp f $fileIdent
        return
        }

    # get the file descriptor of the file associated with VIO channel chanNb,
    # necessary to can close the file at the end of the test
    set fileDescriptor  [lindex $resVioOpen 0]
    set chanNb  [lindex $resVioOpen 1]


 # EMPTY THE VIO

    set resVioEmpty [vioEmpty $fileDescriptor $readBytesMaxNum $maxBytesRead]
    if {[lindex $resVioEmpty 0] == 0} {
        puts stdout $errVioMsg(19)
        cleanUp f $fileIdent
        vioClose $fileDescriptor $chanNb
        return
    }

    set roomDataRead [lindex $resVioEmpty 0]


 # READ DATA FROM VIO

    set targetSystemAssignedId [readContextCreate $fileDescriptor $roomDataRead]
    if {$targetSystemAssignedId == 0} {
        puts stdout $errVioMsg(24)
        vioClose $fileDescriptor $chanNb
	cleanUp ms $roomDataRead f $fileIdent
        return
    }


 # SEND DATA TO VIO

    # channel parameter is set to 0 so virtual  I/O  redirection are performed
    # wtxOpen opens the file $OpenTestFile for reading
    # wtxOpen return a descriptor for that file

    set fileDesc [wtxOpen -channel $chanNb $OpenTestFile WTX_O_RDONLY $mode]
    if {$fileDesc == ""} {
	cleanUp ms $roomDataRead f $fileIdent c $targetSystemAssignedId
        vioClose $fileDescriptor $chanNb
        return
    }

    after 1000

 # READ the data received from the VIO
 
    # read the bytes written at the address $roomDataRead on the target
    set blockRead [wtxMemRead $roomDataRead $bytesReadBlockLength]
    if {$blockRead == ""} {
	cleanUp ms $roomDataRead f $fileIdent c $targetSystemAssignedId\
		vs $fileDesc
        vioClose $fileDescriptor $chanNb
        return
    }

    # get the contents of this block
    set blockReadContent [memBlockGet $blockRead]

 # VERIFY the validity of the data received from VIO
    # compare the content of the block read from the virtual I/O with
    # the initial bytes contained in the file "wtxOpenTestFile"
    if {$blockReadValue != $blockReadContent} {
        testFail $errVioMsg(7)
	cleanUp ms $roomDataRead f $fileIdent c $targetSystemAssignedId\
		vs $fileDesc
        vioClose $fileDescriptor $chanNb
        return
    } 


 # CLOSE 

    # close the file specified by the descriptor returned by wtxOpen
    set resCloseVio [wtxClose $fileDesc]
    if {$resCloseVio == ""} {
        testFail $errVioMsg(16)
        cleanUp ms $roomDataRead f $fileIdent
        vioClose $fileDescriptor $chanNb
        return
    }

    # clean up
    vioClose $fileDescriptor $chanNb
    cleanUp ms $roomDataRead f $fileIdent

    wtxTestPass
}

#*************************************************************************
#
# wtxOpenTest5 - verify that when a pipe is opened for reading with
#       	 virtual I/O redirection, the redirection is performed 
#		 into the right channel and that the pipe command result has 
#		 been passed on entirely.
#
# The result of the "cat vioTestFile" command is sent to the virtual I/O.
# This test verifies that the read command executed on the target has
# received the right data from the virtual I/O.
# So it's the reason why we execute the "cat vioTestFile" command on the
# the host and put its result in a buffer : the result of the read command
# will be able to be compared to the buffer content. The comparison must prove
# that, when a pipe is opened for reading with virtual I/O redirection, the
# result of the pipe command has been passed on entirely. 
#
# This test verifies wtxOpen routine result when it's called with these
# valid parameters :
# <filename> : result of the `cat` unix command 
# <flags>    : WTX_O_RDONLY (open for reading only)
# <mode >    : 0
# <channel>  : 0 (virtual I/O redirection)
#

proc wtxOpenTest5 {Msg} {


 # GLOBAL VARIABLES

    # array that contains the testcase error codes
    global errVioMsg
    # array that contains the environment variables 
    global env

    puts stdout "$Msg" nonewline

 # LOCAL VARIABLES

    # channel id for redirection
    set chanId 0
    # mode value for wtxOpen
    set mode 0
    # max size for buffer that receives read bytes on a virtual I/O
    set readBytesMaxNum 512
    # maximum number of bytes that can be read in one time on a virtual I/O 
    set maxBytesRead 512
    # Get close() function address
    set closeAdd [lindex [wtxSymFind -name "close"] 1]



 # The "cat vioTestFile" command result will be send to the virtual I/O. 
 # When this is will be done, it will has to verify that the read command 
 # on the target has received the right datas from the virtual I/O.
 # So it's the reason why we execute the "cat vioTestFile" command on the 
 # the host and put its result in a buffer : the result of the read command 
 # will be able to be compared to the buffer content. 

    # check that the WIND_BASE environment variables exists
    set findWindBaseVar [info exists env(WIND_BASE)]
    # WIND_BASE environment variable doesn't exist : display a message
    if {$findWindBaseVar == 0} {
        testFail $errVioMsg(1)
        return
    }
    # get the value of the WIND_BASE environment variable
    set windBasePath [set env(WIND_BASE)]


    # path of the file we want to print on the standard output 
    set OpenTestFile "$windBasePath/host/resource/test/vioTestFile"
    # verify that the file exists
    if { [file exists $OpenTestFile] == 0} {
	testFail "cannot find file : $OpenTestFile\n"
	return
    }

    # execute the cat command 
    set catResult [exec cat $OpenTestFile]

    # create a memory block, filled with the content of the previously
    # command
    set bytesReadBlock [memBlockCreate -string $catResult]
    # get the length of read bytes block
    set bytesReadBlockLength [string length $catResult] 
    # get the value of this block to can compare it with data read from 
    # virtual I/O
    set blockReadValue [memBlockGet $bytesReadBlock 0 $bytesReadBlockLength]

    # free memBlock 
    cleanUp mb $bytesReadBlock

 # OPEN Virtual I/O
    set resVioOpen [vioOpen]

    if {[lindex $resVioOpen 0] == 0} {
        puts stdout $errVioMsg(20)
        return
        }

    # get the file descriptor of the file associated with VIO channel chanNb,
    # necessary to can close the file at the end of the test
    set fileDescriptor  [lindex $resVioOpen 0]
    set chanNb  [lindex $resVioOpen 1]


 # EMPTY THE VIO

    set resVioEmpty [vioEmpty $fileDescriptor $readBytesMaxNum $maxBytesRead]
    if {[lindex $resVioEmpty 0] == 0} {
        puts stdout $errVioMsg(19)
        vioClose $fileDescriptor $chanNb
        return
    }

    set roomDataRead [lindex $resVioEmpty 0]


 # READ DATA FROM VIO

    set targetSystemAssignedId [readContextCreate $fileDescriptor $roomDataRead]
    if {$targetSystemAssignedId == 0} {
        puts stdout $errVioMsg(24)
	cleanUp ms $roomDataRead
        vioClose $fileDescriptor $chanNb
        return
    }

 # SEND DATA TO VIO

    # channel parameter is set to 0 so virtual  I/O  redirection are performed
    # wtxOpen opens a pipe for reading
    # wtxOpen return a descriptor for that pipe 

    set fileDesc [wtxOpen -channel $chanNb \"|cat $OpenTestFile\"\
	WTX_O_RDONLY $mode]
    if {$fileDesc == ""} {
        vioClose $fileDescriptor $chanNb
	cleanUp ms $roomDataRead c $targetSystemAssignedId
        return
    }

    after 1000

 # READ the data received from the VIO

    # read the bytes written at the address $roomDataRead on the target
    set blockRead [wtxMemRead $roomDataRead $bytesReadBlockLength]
    if {$blockRead == ""} {
	cleanUp ms $roomDataRead vs $fileDesc
        vioClose $fileDescriptor $chanNb
        return
    }

    # get the contents of this block
    set blockReadContent [memBlockGet $blockRead]


 # VERIFY the validity of the data received from VIO

    # compare the content of the block read from the virtual I/O with
    # the buffer that contains the result of the "cat" command

    if {$blockReadValue != $blockReadContent} {
        testFail $errVioMsg(7)
	cleanUp ms $roomDataRead vs $fileDesc
        vioClose $fileDescriptor $chanNb
        return
    }


    # clean up
    cleanUp ms $roomDataRead vs $fileDesc
    vioClose $fileDescriptor $chanNb

    wtxTestPass
}

#*************************************************************************
#
# wtxOpenTest6 - verify that the opening of a pipe with an
#		 invalid flag, with no VIO redirection / with VIO 
#		 redirection, generates the error code 
#		 WTX_ERR_SVR_INVALID_FLAGS and that nothing is written 
#		 in the VIO
#
# This test verifies wtxOpen routine result when it's called with these
# parameters :
# <filename> : pipe 
# <flags>    : invalid 
# <mode >    : 0
# <channel>  : 0  (virtual  I/O  redirection) /
#	       -1 (no  virtual  I/O  redirection)
#

proc wtxOpenTest6 {Msg} {

 # GLOBAL VARIABLES

    # array that contains the testcase error codes
    global errVioMsg
    # array that contains the environment variables
    global env

    puts stdout "$Msg" nonewline

 # LOCAL VARIABLES

    # channel id for redirection
    set channel 0
    set chanId  -1
    # mode value for wtxOpen
    set mode 0
    # max size for buffer that receives read bytes on a virtual I/O
    set readBytesMaxNum 512
    # maximum number of bytes that can be read in one time on a virtual I/O
    set maxBytesRead 512
    # invalid flag value for wtxOpen
    set invalidFlag 355


 # verify <filename> exists

    # check that the WIND_BASE environment variables exists
    set findWindBaseVar [info exists env(WIND_BASE)]
    # WIND_BASE environment variable doesn't exist : display a message
    if {$findWindBaseVar == 0} {
        testFail $errVioMsg(1)
        return
    }
    # get the value of the WIND_BASE environment variable
    set windBasePath [set env(WIND_BASE)]

    # path of file 
    set OpenTestFile "$windBasePath/host/resource/test/wtxOpenTestFile"
    # verify that the file exists
    if {[file exists $OpenTestFile] == 0} {
        testFail "cannot find file : $OpenTestFile\n"
        return
    }

    # execute the cat command
    catch "exec cat $OpenTestFile" catResult

    # create a memory block, filled with the content of the previously
    # command
    set bytesReadBlock [memBlockCreate -string $catResult]
    # get the length of read bytes block
    set bytesReadBlockLength [string length $catResult]
    # free memBlock
    cleanUp mb $bytesReadBlock


 # OPEN Virtual I/O
    set resVioOpen [vioOpen]

    if {[lindex $resVioOpen 0] == 0} {
        puts stdout $errVioMsg(20)
        return
        }

    # get the file descriptor of the file associated with VIO channel chanNb,
    # necessary to can close the file at the end of the test
    set fileDescriptor  [lindex $resVioOpen 0]
    set chanNb  [lindex $resVioOpen 1]


 # EMPTY THE VIO

    set resVioEmpty [vioEmpty $fileDescriptor $readBytesMaxNum $maxBytesRead]
    if {[lindex $resVioEmpty 0] == 0} {
        puts stdout $errVioMsg(19)
        vioClose $fileDescriptor $chanNb
        return
    }

    set roomDataRead [lindex $resVioEmpty 0]


 # READ DATA FROM VIO

    set targetSystemAssignedId [readContextCreate $fileDescriptor $roomDataRead]
    if {$targetSystemAssignedId == 0} {
        puts stdout $errVioMsg(24)
        vioClose $fileDescriptor $chanNb
	cleanUp ms $roomDataRead
        return
    }


 # WTXOPEN with NO VIO redirection

    # <channel> is set to -1 so no  virtual  I/O  redirection are performed,
    # wtxOpen result must be the error code WTX_ERR_SVR_INVALID_FLAGS

    # if no exception occurred
    if {![catch "wtxOpen -channel $chanId \"|cat $OpenTestFile\" $invalidFlag\
	$mode" errCode]} {
	testFail $errVioMsg(5)
	cleanUp ms $roomDataRead c $targetSystemAssignedId
	vioClose $fileDescriptor $chanNb
	return
	}

    # if the caught exception is different than the expected error code
    if {![wtxErrorMatch $errCode SVR_INVALID_FLAGS]} {
        testFail $errCode
	cleanUp ms $roomDataRead c $targetSystemAssignedId
        vioClose $fileDescriptor $chanNb
        return
    }

    after 1000


 # READ the content of the VIO

    # read the bytes at the address $roomDataRead on the target
    if {[catch "wtxMemRead $roomDataRead $bytesReadBlockLength" blockRead]} {
        testFail $blockRead
	cleanUp ms $roomDataRead c $targetSystemAssignedId
        vioClose $fileDescriptor $chanNb
        return
    }

    # get the contents of this block
    catch "memBlockGet $blockRead" blockReadContent


 # VERIFY that nothing has been written in the VIO.

    # clear a memory block of  bytes, the content of the VIO must be equal
    # to this block.
    set clearBlock [memBlockCreate -B $bytesReadBlockLength 0x00]
    catch "memBlockGet $clearBlock" clearBlockGet

    # free memBlock
    cleanUp mb $clearBlock

    if {$blockReadContent != $clearBlockGet} {
        testFail $errVioMsg(18)
	cleanUp ms $roomDataRead c $targetSystemAssignedId
	vioClose $fileDescriptor $chanNb
        return
    }


 # WTXOPEN with VIO redirection

    # <channel> is set to 0 so virtual I/O redirection are performed,
    # <flags> is invalid
    # wtxOpen result must be the error code WTX_ERR_SVR_INVALID_FLAGS 

    # if no exception occurred
    if {![catch "wtxOpen -channel $channel \"|cat $OpenTestFile\" $invalidFlag\
	$mode" errCode]} {
	testFail $errVioMsg(5)
	cleanUp ms $roomDataRead c $targetSystemAssignedId
	vioClose $fileDescriptor $chanNb
	return
	}

    # if the caught exception is different than the expected error code
    if {![wtxErrorMatch $errCode SVR_INVALID_FLAGS]} {
        testFail $errCode
	cleanUp ms $roomDataRead c $targetSystemAssignedId
        vioClose $fileDescriptor $chanNb
        return
    }

    after 1000


 # READ the content of the VIO

    # read the bytes at the address $roomDataRead on the target
    if {[catch "wtxMemRead $roomDataRead $bytesReadBlockLength" blockRead]} {
        testFail $blockRead
	cleanUp ms $roomDataRead c $targetSystemAssignedId
        vioClose $fileDescriptor $chanNb
        return
    }

    # get the contents of this block
    catch "memBlockGet $blockRead" blockReadContent


 # VERIFY that nothing has been written in the VIO.

    # clear a memory block of  bytes, the content of the VIO must be equal
    # to this block.
    set clearBlock [memBlockCreate -B $bytesReadBlockLength 0x00]
    catch "memBlockGet $clearBlock" clearBlockGet

    # free memBlock
    cleanUp mb $clearBlock

    if {$blockReadContent != $clearBlockGet} {
        testFail $errVioMsg(18)
	cleanUp ms $roomDataRead c $targetSystemAssignedId
        vioClose $fileDescriptor $chanNb
        return
    }

    # clean up
    cleanUp ms $roomDataRead c $targetSystemAssignedId
    vioClose $fileDescriptor $chanNb

    wtxTestPass
}

#*************************************************************************
#
# wtxOpenTest7 - verify that the opening of an existing file for reading
#		 with an invalid <channel> generates an error code.
#
# This test verifies wtxOpen routine result when it's called with these
# parameters :
# <filename> : the name of an existing file
# <flags>    : WTX_O_RDONLY (open for reading only) 
# <mode >    : 0
# <channel>  : invalid
#
# >> REMARKS :  This test must not be executed. It generates a Bus Error
#		on the target.
#		The agent and the target server don't manage this error 
#		(invalid channel). 
#		

proc wtxOpenTest7 {Msg} {

 # GLOBAL VARIABLES

    # array that contains the testcase error codes
    global errVioMsg
    # array that contains the environment variables
    global env

    puts stdout "$Msg" nonewline

 # LOCAL VARIABLES

    # mode value for wtxOpen
    set mode 0
    # max size for buffer that receives read bytes on a virtual I/O
    set readBytesMaxNum 512
    # maximum number of bytes that can be read in one time on a virtual I/O
    set maxBytesRead 512
    # invalid <channel> value for wtxOpen
    set invalidChan 400 

 
 # VERIFY <filename> exists

    # check the WIND_BASE environment variables exists
    set findWindBaseVar [info exists env(WIND_BASE)]
    # WIND_BASE environment variable doesn't exist : display a message
    if {$findWindBaseVar == 0} {
        testFail $errVioMsg(1)
        return
    }
    # get the value of the WIND_BASE environment variable
    set windBasePath [set env(WIND_BASE)]

    # path of the file that will be opened
    set OpenTestFile "$windBasePath/host/resource/test/wtxOpenTestFile"
    # verify the file exists
    if {[file exists $OpenTestFile] == 0} {
        testFail "cannot find file: $OpenTestFile"
        return
    }

    # open the file "wtxOpenTestFile" for reading, return a file identifier
    catch "open $OpenTestFile r" fileIdent
    # read and return all of the bytes remaining in the previously opened file
    catch "read $fileIdent" bytesRead

    # get the length of read bytes block
    set bytesReadBlockLength [expr [string length $bytesRead] + 1]


 # OPEN Virtual I/O
    set resVioOpen [vioOpen]

    if {[lindex $resVioOpen 0] == 0} {
        puts stdout $errVioMsg(20)
	cleanUp f $fileIdent
        return
        }

    # get the file descriptor of the file associated with VIO channel chanNb,
    # necessary to can close the file at the end of the test
    set fileDescriptor  [lindex $resVioOpen 0]
    set chanNb  [lindex $resVioOpen 1]


 # EMPTY THE VIO

    set resVioEmpty [vioEmpty $fileDescriptor $readBytesMaxNum $maxBytesRead]
    if {[lindex $resVioEmpty 0] == 0} {
        puts stdout $errVioMsg(19) 
	cleanUp f $fileIdent
	vioClose $fileDescriptor $chanNb	
	return
    } 

    set roomDataRead [lindex $resVioEmpty 0]


 # READ DATA FROM VIO

    catch "readContextCreate $fileDescriptor $roomDataRead" \
    targetSystemAssignedId 
    if {$targetSystemAssignedId == 0} {
        puts stdout $errVioMsg(24)
        vioClose $fileDescriptor $chanNb
	cleanUp f $fileIdent ms $roomDataRead 
        return
    }


#
#  ERROR CODE "XXXXXX" to replace !!!!
#
# As the error "invalid <channel>" is not managed, the error code that 
# the wtxOpen routine should return when its <channel> argument is 
# invalid, doesn't exist.
#


 # WTXOPEN with INVALID CHANNEL

    catch "wtxOpen -channel $invalidChan $OpenTestFile WTX_O_RDONLY\
    $mode" errCode

    # VERIFY that wtxOpen result is XXXXXX 

#   if {$errCode != $XXXXXX} {
#        testFail $errVioMsg(5)
#	 cleanUp c $targetSystemAssignedId f $fileIdent ms roomDataRead
#        vioClose $fileDescriptor $chanNb   
#        return
#    }


    # clean up 
    cleanUp c $targetSystemAssignedId f $fileIdent ms roomDataRead
    vioClose $fileDescriptor $chanNb

    wtxTestPass
}

#*************************************************************************
#
# wtxOpenTest - main procedure
#
# The main procedure initializes variables that will be used by the test's
# testcase units, it makes accessible the array with the description of the
# testcase units and calls each testcase procedure contained in the test script.
# Furthermore it attaches itself to the target server (thru a wtxToolAttachCall
# command) and, when testcase units have been run, detaches itself from the
# target server.
#

proc wtxOpenTest {tgtsvrName timeout invalidAddr} {

    if { [llength $tgtsvrName] == 0 } {
        puts stdout "usage : wtxOpenTest targetServerName\
				timeout invalidAddr"
        return
    }

    global openMsg


    # call the testcase units
    # valid arg
    wtxToolAttachCall $tgtsvrName 2 $timeout
    catch {wtxRegisterForEvent .*} st

    wtxErrorHandler [lindex [wtxHandle] 0] errorHandler

    wtxOpenTest1 $openMsg(1)
    wtxOpenTest3 $openMsg(3)
    wtxOpenTest4 $openMsg(4)
    # wtxOpenTest5 $openMsg(5)

    wtxErrorHandler [lindex [wtxHandle] 0] ""

    # invalid arg

    wtxOpenTest2 $openMsg(2)
    wtxOpenTest6 $openMsg(6)
    # wtxOpenTest7 $openMsg(7)


    # detach from the target server
    wtxToolDetachCall "\nwtxOpenTest : "
}
