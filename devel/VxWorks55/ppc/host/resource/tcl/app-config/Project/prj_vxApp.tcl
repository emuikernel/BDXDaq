# prj_vxApp.tcl - vxWorks application project library
#
# modification history
# --------------------
# 01z,09may02,cjs  Fix spr 75811 -- downloadable project makefiles contain
#                  absolute, not relative, paths
# 01y,19feb02,rbl  fix bug where compile flags can get  -DTOOL=gnu AND
#                  -DTOOL=diab - change made to prj_vxWorks.tcl that didn't
#                  get migrated to here. 
# 01x,13nov01,rbl  add .pl partial link target - to better support
#                  sub-projects
# 01w,16oct01,rbl  support typing "make" in project directory for backwards
#                  compatibility
# 01v,20sep01,rbl  rename "vendor" to "tool" for consistency
#                  with the makefile TOOL variable
#                  remove absolute paths from Makefile
# 01v,20sep01,dat  Adding TOOL_FAMILY 
# 01u,13sep01,dat  Gnu-diab infrastructure
# 01t,11mar99,rbl  adding description argument to projCreate
# 01s,10mar99,ren  Fixing SPR 25424 by naming the link output file to be the
#                  project name.
# 01r,16feb99,rbl  Changes to handle missing or read-only projects
# 01q,11feb99,cjs  Changed buildRuleListGet, buildRuleDefault to operate on a
#                  project handle
# 01p,19jan99,cjs  make prjBuildRuleListGet() sensitive to bsp
# 01o,17nov98,cjs  changed some references to 'vxWorks' to 'VxWorks' 
# 01n,10nov98,ms   ARCHIVE macro now set for all new buildSpecs
# 01m,26oct98,ms   reworked for new build interface.
# 01m,27aug98,ms   rule linkedObjs.o replaces downloadable_objects.
#		   respect read-only dependency path to speed up builds.
# 01l,12aug98,ms   changed merged_object to loadable_object, and made default.
# 01k,29jul98,ms   update calls to prj[Rel|Full]Path
# 01j,01jul98,cjs  changed project name to reflect usage scenario 
# 01i,29jun98,jmp  moved build-configuration macros after defs.project
#                  include.
# 01h,25jun98,ms   each buildSpec is built in a separate subdir
#                  combined C and C++ compiler to one tool.
#                  reworked derivedObjsGet to return all objects.
# 01b,18jun98,jmp  added rules support to makeGen{}.
# 01a,21may98,ms   added derivedObjectsGet, buildRule[GS]et
# 01a,18may98,ms   written.
#
# DESCRIPTION
# This library manages vxWorks application project types.
# It builds application source code. After the build it
# can optionally perform post-processing on the .o's:
# 	put them into an archive
#	partially link them together for download to vxWorks
#


source  [wtxPath]/host/resource/tcl/app-config/Project/wccLib.tcl

proc constructProjectOutFileName { hProj } {
	set ProjectOutFileName \
		[file rootname [file tail [prjInfoGet $hProj fileName]]].out
}

proc constructProjectPlFileName { hProj } {
	set ProjectPlFileName \
		[file rootname [file tail [prjInfoGet $hProj fileName]]].pl
}

proc constructProjectArchiveFileName { hProj } {
	set ProjectArchiveFileName \
		[file rootname [file tail [prjInfoGet $hProj fileName]]].a
}

namespace eval ::prj_vxApp_hidden {

###############################################################################
#
# projCreate - create a "vxWorks application" project
# 

proc projCreate {prjFile tc {description ""}} {
    if {![prjCreateable $prjFile ::prj_vxApp]} {
        error "can't create project $prjFile"
    }

    # create an empty project
    set hProj [prjCoreCreate $prjFile ::prj_vxApp]

    # create a default build spec
    set hSpec [prjBuildCreate $hProj [${tc}::name] $tc]

	# set the description
	::prjTagDataSet $hProj userComments $description

    # close the project to save all the info
    prjClose $hProj SAVE
}

###############################################################################
#
# makeGen - generate a Makefile for a vxWorks project
#

proc makeGen {hProj Makefile} {
    set hSpec [prjBuildCurrentGet $hProj]
    set builds [prjBuildListGet $hProj]
    set fd [open $Makefile w+]
    fconfigure $fd -translation lf
    set prjFiles [prjFileListGet $hProj]
    set prjObjs ""
    set bootObjs ""
    foreach file $prjFiles {
	set objs [prjFileInfoGet $hProj $file objects]
        foreach obj $objs {
            if {"[string range [file extension $obj] 0 1]" == ".o"} {
                lappend prjObjs $obj
            }
	}
    }

    puts $fd "# Makefile generated by the project manager\n#\n"
    puts $fd "\n## core information\n"
    puts $fd "PRJ_FILE       = [prjRelPath $hProj [file tail [prjInfoGet $hProj fileName]]]"
    puts $fd "ifeq ($(wildcard Makefile),)"
    puts $fd "PRJ_DIR        = .."
    puts $fd "else"
    puts $fd "PRJ_DIR        = ."
    puts $fd "endif"
    puts $fd "PRJ_TYPE       = vxApp"
    puts $fd "PRJ_OBJS       = $prjObjs"
    puts $fd "BUILD_SPEC     = $hSpec"
    puts $fd "TGT_DIR        = $(WIND_BASE)/target"
    puts $fd "\n\n"

    puts $fd "\n## build-configuration info\n"
    foreach build $builds {
	set tc [prjBuildTcGet $hProj $build]
	puts $fd "ifeq ($(BUILD_SPEC),$build)"
	puts $fd "CPU              = [${tc}::cpu]"
	puts $fd "TOOL             = [${tc}::tool]"
	puts $fd "TOOL_FAMILY      = [${tc}::family]"
	puts $fd "DEFAULT_RULE     = [prjBuildRuleCurrentGet $hProj $build]"
	puts $fd "endif\n"
    }

    puts $fd "include $(TGT_DIR)/h/make/defs.project"

    puts $fd "\n## build-configuration info\n"
    foreach build $builds {
	set tc [prjBuildTcGet $hProj $build]
	puts $fd "ifeq ($(BUILD_SPEC),$build)"
	foreach macro [prjBuildMacroListGet $hProj $build "" 1]  {
	    puts $fd [format "%-16s = %s" $macro \
		[prjRelPath $hProj [prjBuildMacroGet $hProj $build $macro]]]
	}
	puts $fd "endif\n"
    }

    puts $fd "# override make definitions only below this line\n\n"
    puts $fd "# override make definitions only above this line"
    puts $fd "include $(TGT_DIR)/h/make/rules.project\n\n"

    puts $fd "\n## build-configuration info\n"
    foreach build $builds {
	puts $fd "ifeq ($(BUILD_SPEC),$build)"
	foreach file $prjFiles {
            # skip files with custom rules - custom rules generated later
            if {"[prjFileInfoGet $hProj $file customRule]" != ""} {
                continue
            }
	    foreach object [prjFileInfoGet $hProj $file objects] {
		puts $fd "${object}:"
		foreach cmd [prjBuildCmdsGet $hProj $build $file] {
		    puts $fd "\t[prjRelPath $hProj $cmd]"
		}
	    }
	}
	puts $fd "endif\n"
    }

    puts $fd "\n## dependencies\n"
    set roDependPath [prjDepPathGet $hProj $build]
    foreach file $prjFiles {
	set dependencies [prjFileInfoGet $hProj $file dependencies]
	foreach depDir $roDependPath {
	    regsub -all "${depDir}(\[^ \])* " $dependencies "" dependencies
	}

	foreach object [prjFileInfoGet $hProj $file objects] {
	    puts $fd "${object}: [prjDataSplit \
		[prjRelPath $hProj [concat $file $dependencies]]]\n"
	}
    }

    # add user defined rules
    set targetList [prjBuildRuleListGet $hProj $hSpec]

    if {"$targetList" != ""} {
    	puts $fd "\n## user defined rules\n"
	foreach target $targetList {
	    set i 1
	    set rule [prjBuildRuleGet $hProj $hSpec $target]
	    if {$rule == ""} {
	    	continue
	    }

	    foreach line $rule {
	    	if {$i} {
		    # print the target line (no tabulation)
		    puts $fd [prjRelPath $hProj $line]
		    set i 0
		} else {
		    # print the command lines (with tabulation)
		    puts $fd "\t[prjRelPath $hProj $line]"
		}
	    }

	    puts $fd ""
	}
    }

    close $fd
}
}

namespace eval ::prj_vxApp {

###############################################################################
#
# create - create a vxWorks project
#

proc create {prjFile toolchain} {
    ::prj_vxApp_hidden::projCreate $prjFile $toolchain
}

###############################################################################
#
# name - return the name of this project type
#

proc name {} {
    return "Create downloadable application modules for VxWorks"
}

###############################################################################
#
# toolChainListGet - get the list of compatible toolChains
#

proc toolChainListGet {} {
    return [prjTcListGet {} {} C++]
}

###############################################################################
#
# coreFilesGet - returns list of files (apart from the project file itself)
#                that define the "core" of the project. In a 
#                "save as", these are the files that get copied. 
#

proc coreFilesGet {} {
    return ""
    }


###############################################################################
#
# buildRuleListGet - return the list of build rules for vxWorks
#

proc buildRuleListGet {hProj} {
	return [list [constructProjectOutFileName $hProj] [constructProjectPlFileName $hProj] objects archive]
}

###############################################################################
#
# buildRuleDefault - return the default build rule
#

proc buildRuleDefault {hProj} {
    constructProjectOutFileName $hProj
}

###############################################################################
#
# buildModify - modify a build spec
#
# After a buildSpec is created from toolchain defaults, this
# routine is called to make whatever modifications are needed
# for vxWorks projects.
# This routine:
# * adds appropriate -IXX flags for the vxWorks headers
# * adds -DCPU=$(CPU) -DTOOL_FAMILY=$(TOOL_FAMILY) -DTOOL=$(TOOL)
# * if another build-spec exists, it
#   copies any defines and includes from that spec
#   that were not defaults. That way if the user adds custom -D and -I 
#   options to a build, those will be preserved when a new spec is
#   created.
#

proc buildModify {hProj build} {
    set tc [prjBuildTcGet $hProj $build]
    set cc [${tc}::toolFindByFile foo.c]
    set as [${tc}::toolFindByFile foo.s]
    set tool [${tc}::tool]
    set prjDir [file dir [prjInfoGet $hProj fileName]]

    # default macro value

    prjBuildMacroSet $hProj $build ARCHIVE \
		$prjDir/$build/[constructProjectArchiveFileName $hProj]

    set prjDir .
    set inc [prjBuildMacroGet $hProj $build OPTION_INCLUDE_DIR]
    set def [prjBuildMacroGet $hProj $build OPTION_DEFINE_MACRO]
    set extraCppFlags \
	"${inc}$prjDir ${inc}[wtxPath target h] \
	${def}CPU=[${tc}::cpu] ${def}TOOL_FAMILY=[${tc}::family] \
	${def}TOOL=${tool}"

    set cflags   [prjBuildFlagsGet $hProj $build $cc]
    set asflags  [prjBuildFlagsGet $hProj $build $as]
    prjBuildFlagsSet $hProj $build $cc  "$cflags $extraCppFlags"
    prjBuildFlagsSet $hProj $build $as  "$asflags $extraCppFlags"

    prjDepPathAdd $hProj $build [prjDepPathDefaults]

    # try to copy user-specific includes and defines from existing specs

    set buildList [prjBuildListGet $hProj]
    if {[llength $buildList] > 1} {
        set oldBuild [lindex $buildList 0]
        set oldTc [prjBuildTcGet $hProj $oldBuild]
        foreach buildFlag "CFLAGS CFLAGS_AS" {
            set tcFlags [${oldTc}::macroDefaultValGet $buildFlag]
            foreach flag [prjBuildMacroGet $hProj $oldBuild $buildFlag] {
                set searchFlag $flag

                # if old flag is e.g. -DTOOL=diab, match
                # -DTOOL=* in new flag. If we match, skip this
                # flag. Otherwise we end up with e.g. 
                # -DTOOL=diab -DTOOL=gnu

                if {[string match -D* $searchFlag]} {
	            regsub {=[^=]*} $searchFlag {=} searchFlag
                    append searchFlag *
                }

		if {[lsearch $tcFlags $searchFlag] != -1} {
		    continue
		}
		if {[lsearch $extraCppFlags $searchFlag] != -1} {
		    continue
		}
                prjBuildMacroSet $hProj $build $buildFlag \
                        "[prjBuildMacroGet $hProj $build $buildFlag] $flag"
            }
        }
    }
}

###############################################################################
#
# buildCmdGet - get the command needed to build an image
#
# RETURNS: a pair "command directory", so that invoking
# command in directory will build the desired image
#

proc buildCmdGet {hProj {rule ""} {spec ""}} {


    # mTime - return the time of last modification of a file

    proc mTime file {
        if {![file exists $file]} {
            return 0
        }
        file stat $file statInfo
        return $statInfo(mtime)
    }

    set prjDir [file dir [prjInfoGet $hProj fileName]]

    # regenerate the Makefile if it is older than the project file

    set makeModTime [mTime $prjDir/Makefile]
    set prjModTime  [prjInfoGet $hProj changed]
    if {"$prjModTime" == ""} {
        set prjModTime  [mTime [prjInfoGet $hProj fileName]]
    }
    if {$makeModTime < $prjModTime} {
        ::prj_vxApp_hidden::makeGen $hProj $prjDir/Makefile
    }

    # return the info

    if {"$spec" == ""} {
        set spec [prjBuildCurrentGet $hProj]
    }
    catch "file mkdir $prjDir/$spec"
    return [list "make -f ../Makefile BUILD_SPEC=$spec $rule" "$prjDir/$spec"]
}

###############################################################################
#
# derivedObjsGet - get the derived objects produced the project build
# 

proc derivedObjsGet {hProj image} {
    set prjDir [file dirname [prjInfoGet $hProj fileName]]
    set build  [prjBuildCurrentGet $hProj]
    set tc     [prjBuildTcGet $hProj $build]
    set buildObjs ""

    foreach file [prjFileListGet $hProj] {
        if {"[set tool [::${tc}::toolFindByFile $file]]" == ""} {
            continue
        }
        foreach obj [::${tool}::outputFiles $file] {
            lappend buildObjs $prjDir/$build/$obj
        }
    }
    if {"$image" == "[constructProjectOutFileName $hProj]"} {
		lappend buildObjs $prjDir/$build/[constructProjectOutFileName $hProj]
    }
    if {"$image" == "[constructProjectPlFileName $hProj]"} {
		lappend buildObjs $prjDir/$build/[constructProjectPlFileName $hProj]
    }
    if {"$image" == "archive"} {
	lappend buildObjs [prjBuildMacroGet $hProj $build ARCHIVE]
    }

    return $buildObjs
}

prjTypeAdd ::prj_vxApp
}

