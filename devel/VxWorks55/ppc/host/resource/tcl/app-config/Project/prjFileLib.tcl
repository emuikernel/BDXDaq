# prjFileLib.tcl - project file manager library
#
# modification history
# --------------------
# 01k,02may02,cjs  Fix spr 76532: dependency generation doesn't respect
#                  standard variables
# 01j,04oct01,cjs  Fixing spr 25520 -- dependencies generation error should
#                  propagate to the user
# 01i,18feb99,ren  fixed SPR 24963 -- problems with file remove
# 01h,03dec98,cjs  fixing problemmatic behavior for 'objects' in
#                  prjFileInfoGet()
# 01g,26oct98,ms   prjFileInfo of objects now checks for custom rules.
# 01f,03sep98,ms   keep track of files that need dependency generation
# 01e,12aug98,ms   fixed bug caused by 01d (replacement was incomplete).
# 01d,03aug98,jmp  replaced dependancies by dependencies.
# 01c,05jun98,cjs  fixed minor bug in prjFileAdd 
# 01b,03apr98,ms   compute file dependancies when info is requested
# 01a,18mar98,ms   written.
#
# DESCRIPTION
# This library provides file management within a project.
# It works in tandem with prjLib.tcl.
# It allows files to be added and removed from a project, and also
# allows other facilities to associate information with a file.
# The following information is associated with a file:
#	tool		- tool used to compile this file
#	objects		- derived files produced by the tool
#	dependencies	- make-dependencies (e.g., #include's)
#	dependDone	- TRUE if file dependecies have been calculated
#	customRule	- set to a custom rule name if the file is to use
#			  a custom rule created by prjBuildRuleSet.
# Other information may be added, for example:
#	readonly	- generated by the project-type manager (e.g.,
#			  for vxWorks project, things under WIND_BASE can
#			  optionally be designated as readonly).


###############################################################################
#
# prjFileAdd - add a file to a project
#
# RETURNS: N/A
# ERRORS: no such file
#

proc prjFileAdd {hProj file} {
    prjHandleValidCheck $hProj

    if {![file exists $file]} {
        error "$file: no such file"
        }

    set files [prjTagDataGet $hProj PROJECT_FILES]
    if {[lsearch $files $file] != -1} {		;# file already in project?
	return
    }
    prjFileBuildInfoGen $hProj $file FALSE

    prjTagDataSet $hProj PROJECT_FILES [lappend files $file] 
}

###############################################################################
#
# prjFileRemove - remove a file from a project
#
# RETURNS: N/A
# ERRORS: no such file
#

proc prjFileRemove {hProj file} {
    prjHandleValidCheck $hProj

    set files [prjTagDataGet $hProj PROJECT_FILES]
    set ix [lsearch $files $file]
    if {$ix == -1} {
        error "$file: no such file"
    }
    prjTagDataSet $hProj PROJECT_FILES [lreplace $files $ix $ix]

    foreach info [prjFileInfoListGet $hProj $file] {
	prjFileInfoDelete $hProj $file $info
    }
}

###############################################################################
#
# prjFileListGet - return a list of project files
#

proc prjFileListGet hProj {
    prjHandleValidCheck $hProj

    return [prjTagDataGet $hProj PROJECT_FILES]
}

###############################################################################
#
# prjFileInfoSet - associate some information with a file
#

proc prjFileInfoSet {hProj file infoType infoValue} {
    prjTagDataSet $hProj FILE_${file}_${infoType} $infoValue
}

###############################################################################
#
# prjFileInfoGet - get any information associated with a file
#

proc prjFileInfoGet {hProj file infoType} {
    return [prjTagDataGet $hProj FILE_${file}_${infoType}]
}

###############################################################################
#
# prjFileInfoDelete - get info associated with a file
#

proc prjFileInfoDelete {hProj file infoType} {
    prjTagRemove $hProj FILE_${file}_${infoType}
}

###############################################################################
#
# prjFileInfoListGet - get a list of info associated with a file
#

proc prjFileInfoListGet {hProj file} {
    set tags [prjTagListGet $hProj]

    set infoTypeList ""
    foreach tag $tags {
		if {[regsub FILE_[EscapeRegexpCharacters $file]_ $tag "" infoType] != 0} {
			lappend infoTypeList $infoType
		}
    }

    return $infoTypeList
}

###########################################################################
#
# prjRemoveReadOnlyDependencies - remove the dependent files which live
#    in one of the read only paths
# Args:
#   listDependencies: a list of fully qualified header file names
#   listReadOnlyDirs: a list of fully qualified directories which are
#      considered to be read only
# Returns:
#   Any files in listDependencies which live in one of the read only
#   directories are removed.  The rest are returned.
# Notes:
#   This function is a work of art.  I originally wrote it the obvious way
#   with two nested foreach statements, but that ran in O(n*m) time, and
#   in some cases took more time than calling the c preprocessor, effectively
#   more than doubling the time to do a dependencey analysis.
#      So, I re-wrote it using the highly optimized regular expression
#   procedures.  Notice there is not a single loop in this function.

proc prjRemoveReadOnlyDependencies { listDependencies listReadOnlyDirs} {
	if { [llength $listReadOnlyDirs] == 0 } {
		return $listDependencies
	}

	# join the read only directories into one string, separated by \x82
	# and escape any characters that might screw up a regular expression
	set expReadOnlyDirs [EscapeRegexpCharacters \
							 [join $listReadOnlyDirs \x82] ]
	# Now take the \x82s, and change them into a big regexp |, which match
	# files (separated by \x81) in those paths 
	regsub -all \x82 \
		"\x81[set expReadOnlyDirs]\[^\x81]*" "\[^\x81]*|\x81" expReadOnlyDirs
	# Now use this generated regexp to match and remove files in those read
	# only paths
	global tcl_platform
	if { $tcl_platform(platform) == "windows" } {
		regsub -all -nocase [string tolower $expReadOnlyDirs]\
			"\x81[join $listDependencies \x81]" {} strResult
	} else {
		regsub -all $expReadOnlyDirs "\x81[join $listDependencies \x81]" {} strResult
	}
	# finally, remove the \x81 separators in the file list and return
	return [split [string range $strResult 1 end] \x81]
}

###############################################################################
#
# prjFileBuildInfoGen - generate build information for a file
#

proc prjFileBuildInfoGen {hProj {file ""} {doDepends TRUE}} {

    if {"$file" == ""} {
	    set files [prjFileListGet $hProj]
	    set nFiles [llength $files]
	    set doneFiles 0
	    foreach file $files {
	        set fileTail [file tail $file]
	        prjStatusLog "generating dependencies ($fileTail)" \
			    $doneFiles $nFiles
	        prjFileBuildInfoGen $hProj $file
	        incr doneFiles
	    }
	    prjStatusLog "done"
	    return
    }
    set build [prjBuildCurrentGet $hProj]
    set tc [prjBuildTcGet $hProj $build]
    set toolType [prjTagDataGet $hProj FILE_${file}_tool]
    if {"$toolType" != ""} {
	    set tool [${tc}::toolFindByType $toolType]
    } else {
	    set tool [${tc}::toolFindByFile $file]
    }

    if {"$tool" == ""} {
	    prjFileInfoSet $hProj $file dependDone TRUE
	    return
    }
    set flags [prjBuildFlagsGet $hProj $build $tool $file]

    prjFileInfoSet $hProj $file tool [${tool}::type]
    prjFileInfoSet $hProj $file objects [${tool}::outputFiles $file]

    if {"$doDepends" == "TRUE"} {
        set flags [prjFullPathRelativeTo $hProj $flags]
        set absFile [prjFullPathRelativeTo $hProj $file]
        set unfilteredDepends [${tc}::dependFiles $tool $flags $absFile]
        prjFileInfoSet $hProj $file dependencies \
            [prjRemoveReadOnlyDependencies $unfilteredDepends \
            [prjDepPathGet $hProj $build]]
        prjFileInfoSet $hProj $file dependDone TRUE
    }
}

