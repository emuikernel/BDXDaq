# tc_cplus.tcl - project manager library
#
# modification history
# --------------------
# 02c,28jan03,rbl  fix SPR 85176, tc_cplus.tcl contains logic error in error
#                  processing
# 02b,11jul02,rbl  fixing SPR 79510 - IDE can fail to build toolchain info
#                  (hence dead project facility) for no apparent reason...
# 02a,18jun02,rbl  fix problem where saved toolchain and bsp have wrong arch
#                  for current installation
# 01z,23may02,cjs  Fix spr 77715: put make diab toolchain default if
#                  installed, and remember last choice
# 01y,22may02,cjs  Moved filenameQuoteIfNecessary() to Utils.tcl
# 01x,22may02,cjs  add call to filenameQuoteIfNecessary() to protect
#                  temporary file containing spaces from eval()
# 01w,07may02,cjs  Continued support for spr 76601 -- expose -U (undefine)
#                  compiler option to mirror OPTION_DEFINE_MACRO
# 01v,14mar02,j_s  update cPrependChar for ARM,PENTIUM,STRONGARM and XSCALE
# 01u,17dec01,rbl  make tcInfo_* production robust against diab not being
#                  installed
# 01t,10dec01,rbl  dependency generation did not cope well with warnings
#                  commSymLink should only return symbol for the 68k arch.
# 01s,06nov01,rbl  diab now uses driver to invoke assembler, so it has
#                  preprocessor.
# 01r,15oct01,rbl  add functionality to map toolchains to arch's
#                  move archDirFind here from prj_vxWorks.tcl
#                  changes to deal with new "common" directory
#                  in target/h/tool
#                  get dependency generation working for diab
#                  ensure we are referring to env() array in root
#                  namespace ::
# 01q,17sep01,rbl  merge changes from T3: auto-generate tcInfo_<family>
#                  files whenever target/h/tool/<family> files change.
#                  in toolchains, rename "vendor" to "tool" for consistency
#                  with the makefile TOOL variable
#                  added .C to inputSuffixes for compiler
# 01r,09oct01,cjs  Fixing dependFiles() to propagate an error to the user
#                  also nuked -MG, which suppressed any errors about missing
#                  headers
# 01q,25sep01,dat  moved makefiles to h/tool/
# 01p,13jun01,agf  add logic to check host type on stdout/stderr syntax
# 01o,09may01,agf  undoing last change, @ breaks Win hosts
# 01n,16apr01,agf  fix syntax for redirecting output to stdout/stderr
# 01n,12mar01,sn   Ensure assembly files are correctly preprocessed
# 01m,10jan01,sn   Add support for OPTION_LANG_C
# 01m,12may00,zl   added Hitachi SuperH (SH) support
# 01l,16apr99,j_k  back-off from previous fix and make it right.
# 01k,13apr99,j_k  part of fix for SPR #26620.
# 01j,31mar99,cjs  Fixed bug in cppFlagsGet() that prevented proper -U undefs
#                  from being passed to CPP
# 01i,25jan99,ren  Fixing SPR 24302
# 01h,21jan99,cjs  Adding .cc to input suffixes for the C++ compiler
# 01g,26Oct98,ms  modified for DIAB toolchain, simplified interface.
# 01f,26aug98,ms  reworked so not GNU specific. Simpler interface to toolchain
#		  spec so people can change toolchains without writing TCL.
# 01e,12aug98,ren redefine simsparcsolaris and ppc as module level linking type.
# 01d,27jul98,ms  added nm, size, and ar utilities.
# 01d,22jul98,ms  added proc cpp.
# 01c,20jul98,ms  added cPrependChar and commSymLink methods to C++ toolchains.
# 01c,25jun98,ms  just include gnuInfoGen.tcl, rather than copy it in.
# 01b,08apr98,ms  imported gnuInfo for all CPUTOOLs (from gnuInfoGen.tcl).
# 01a,26mar98,ms  written.
#
# DESCRIPTION
# This is the toolChain library C/C++ toolchains.
# It provides a TCL interface between the config tool
# and the specifics of each compiler.
#
# The file reads toolchain info is from any file named tcInfo_*.
# We provide a tcInfo_gnu file as an example. Our file is
# generated by gnuInfoGen.tcl (see that file for details).
# Customers and 3rd party vendors can create their own
# toolchain interfaces as needed.
#
# Each toolchain (CPU-TOOL combo) is associated with a TOOL_FAMILY.
# The default TOOL_FAMILYs are 'gnu' and 'diab'.  A new TOOL_FAMILY
# is defined by creating a new directory in $TGT_DIR/h/tool/ with the
# name of the TOOL_FAMILY.
#
# Toolchains are defined by creating a makefile named make.$(CPU)$(TOOL)
# for each CPU and TOOL to be supported.
# The easiest way to start is by copying an existing file.
# Then one must create or update a tcInfo_${TOOL_FAMILY} file in this
# directory the info on all the toolchains supported by that tool family.
# That can be done either by running
# gnuInfoGen, or by writing it by hand using an existing file
# as a template.
#
# There is a hard-coded assumption that the compiler flag "-c"
# produces a .o from a .c.
#

# This processes the tcInfo file for each tool family installed.
# It generates the tc database for all known toolchains.

#
# regenerate tcInfo_<family> (if they are writable)
# when any makefiles in target\h\tool\<family> have been changed
#

source [wtxPath host resource tcl app-config Project]Utils.tcl

# get family list from dirs in target/h/tool

set tool_families ""


#
# tool families are all directories under target/h/tool (except for
# "common" that have make stubs in them
#

foreach file [glob -nocomplain [wtxPath target h tool]*] {
    if {[file tail $file] == "common"} {
        continue
    }
    if [file isdirectory $file] {
        set makeStubs [glob -nocomplain $file/make.*]
	  if {$makeStubs != ""} {
            lappend tool_families [file tail $file]
        }
    }
}

foreach family $tool_families {
    set tcInfoFile [wtxPath host resource tcl app-config Project]tcInfo_${family}

    set dependencies "[wtxPath target h tool $family]* \
        [wtxPath target h tool common]* \
        [wtxPath target h make]*"

    if {(![file exists $tcInfoFile] || [file writable $tcInfoFile]) \
        && [outOfDate $tcInfoFile $dependencies] } {
        set startDir [pwd]
        cd [wtxPath host resource tcl app-config Project]
        puts "Generating $family toolchain info file from makefiles in \
              [file nativename [wtxPath target h tool $family]]..."

        # gnuInfoGen.tcl uses argv for family...

        if [info exists argv] { set oldArgV $argv }
        if [info exists argc] { set oldArgC $argc }
        set argv $family
        set argc 1

        if [catch {
            source [wtxPath host resource tcl app-config Project]gnuInfoGen.tcl
        } sourceError] {
            set errorMessage \
                "Error creating $family toolchain information files.\
                You will not be able to open or create projects until\
                this error is resolved:\n\n\
                $sourceError"
            # are we running from the gui?
            # if so, show a message box reporting the error
            if {[info commands dialogCreate] == "dialogCreate"} {
                messageBox $errorMessage
                catch {::toolInfoGenProgress::progressFinish}
            }
            error $errorMessage
        }

        # restore argv and argc

        if [info exists oldArgV] { set argv $oldArgV }
        if [info exists oldArgC] { set argc $oldArgC }
        cd $startDir
    }       
}

#
# read the toolchain information from the tcInfo_* files
#

foreach family $tool_families {
    set tcInfoFile [wtxPath host resource tcl app-config Project]tcInfo_${family}
    if {![file exists $tcInfoFile]} {
        continue
    }
    set fd  [open $tcInfoFile r]
    set lines [split [read $fd] \n]
    close $fd

    set toolchain ""
    foreach line $lines {
	if {("$line" == "") || ([string index $line 0] == "#")} {
	    set toolchain ""
	    continue
	}
	if {"$toolchain" == ""} {
	    set toolchain $line
	    set tcInfo_${toolchain}(TOOL_FAMILY) $family
	    if {[llength $toolchain] != 1} {
		puts "Error parsing $file. Bad toolchain name $line"
		set toolchain ""
	    }
	continue
	}
	regexp {([ 	]*)([^ 	]*)([ 	]*)(.*)} $line dummy \
		dummy info dummy val
	set tcInfo_${toolchain}($info) $val
    }
}

#########################################################################
#
# archDirFind - find the architecture directory for a given CPU
#
# SYNOPSIS 
#   archDirFind  cpu 
#
# PARAMETERS 
#   cpu:    cpu, e.g. PPC603
#
# RETURNS: architecture directory, e.g. ppc
#
# ERRORS: Could not find architecture directory for cpu
#
proc archDirFind cpu {
	switch -glob $cpu {
	    MC68*		{return mc68k}
	    MCF**		{return coldfire}
	    CPU32		{return mc68k}
	    I80*86		{return i86}
	    PENTIUM*		{return i86}
	    I960*		{return i960}
	    PPC*		{return ppc}
	    ARM*		{return arm}
	    STRONGARM*		{return arm}
	    XSCALE*             {return arm}
	    MIPS*		{return mips}
	    SPARC*		{return sparc}
	    SIMHPPA		{return simhppa}
	    SIMSPARCSOLARIS	{return simsolaris}
	    SIMNT		{return simnt}
	    SH*			{return sh}
	    MCORE*		{return mcore}
	    ULTRASPARC*		{return sparcv9}
	    FR*		        {return frv}
            default             {error "Could not find arch. dir for cpu $cpu"}
	}
}     

## this part of the file provides the interface between the
## gnu tool family and the project facility.

if {[string match "x86-win32" [wtxHostType]]} {
    set fileExt ".exe"
    set pathSeparators ";"
} else {
    set fileExt ""
    set pathSeparators ":;"
}

proc GetToolchainNamespaceFromCPU { cpu } {
	global g_mapCPUToNamespace
	set strResult $g_mapCPUToNamespace($cpu)
	if { $strResult == "" } {
		error "No namespace for $cpu." 
	}
	return $strResult
}

foreach toolchain [info vars tcInfo_*] {
    set cpu	[set ${toolchain}(CPU)]
    set tool	[set ${toolchain}(TOOL)]
    set family	[set ${toolchain}(TOOL_FAMILY)]
    set cc 	[format "%s%s" [set ${toolchain}(CC)] $fileExt]
    set ccPath [wtxPath host [wtxHostType] bin]$cc
    ## expose only the installed toolchains to the configuration tool
    if {![file exists [wtxPath target h tool $family make.$cpu$tool]]} {
	continue
    } else {
	# Check for presence of C compiler

        set compilerExists 0
        if {[file exists $ccPath]} {
            set compilerExists 1
        }
        if {!$compilerExists} {
            # not in hosttype/bin, but it might be in the env(PATH)
            set tPath $::env(PATH)
            set lPath [split $tPath $pathSeparators]
            foreach llpath $lPath {
                set ccPath $llpath/$cc
                if {[file exists $ccPath]} { set compilerExists 1 }
                if {$compilerExists} { continue }
            }
        }
        if {!$compilerExists} {
            # couldn't find it at all, consider it invalid.
            continue
        }
    }

    regsub tcInfo_ $toolchain "" toolchain

	global g_mapCPUToNamespace
	set g_mapCPUToNamespace($cpu) tc_$toolchain

    # C compiler

    namespace eval ::tc_${toolchain}::tool_cc {
	variable tool

	proc type {} {
	    return "C/C++ compiler"
	}
	proc inputSuffixes {} {
	    return ".c .cxx .cpp .cc .C"
	}
	proc outputFiles {inFile} {
	    return [file rootname [file tail $inFile]].o
	}
	proc buildCmds {flags file} {
	    variable tool
	    return [list "\$(CC) $flags -c $file"]
	}
	proc toolMacro {} {
	    return CC
	}
	proc flagsMacro {} {
	    return CFLAGS
	}
    }

    # assembler

    namespace eval ::tc_${toolchain}::tool_as {
	variable tool

	proc type {} {
	    return "assembler"
	}
	proc inputSuffixes {} {
	    return ".s"
	}
	proc outputFiles {inFile} {
	    return [file rootname [file tail $inFile]].o
	}
	proc buildCmds {flags file} {
	    variable tool
	    set tc [namespace parent]
	    # if the assembler has no C-preprocessor, we must invoke CPP
	    # before the invoking the assembler.
	    if {[${tc}::asmHasCpp]} {
		return [list "\$(AS) $flags -c $file -o [outputFiles $file]"]
	    }
	    global tcInfo_[${tc}::name]
	    set cppCmd [set tcInfo_[${tc}::name](CPP)]
	    set cppFlags [cppFlagsGet $flags $tc]
	    set tmpFile [file rootname $file]_tmp.s
	    return [list "\$(CPP) $cppFlags $file > ${tmpFile}" \
			"\$(AS) $flags -c ${tmpFile} -o [outputFiles $file]" \
			"\$(RM) ${tmpFile}"]
	}
	proc toolMacro {} {
	    return AS
	}
	proc flagsMacro {} {
	    return CFLAGS_AS
	}
    }

    # linker

    namespace eval ::tc_${toolchain}::tool_ld {
	variable tool

	proc type {} {
	    return "linker"
	}
	proc inputSuffixes {} {
	    return ""
	}
	proc outputFiles {inFile} {
	    return [file rootname [file tail $inFile]].o
	}
	proc buildCmds {flags file} {
	    variable tool
	    return [list "$tool $flags -c $file"]
	}
	proc toolMacro {} {
	    return LD
	}
	proc flagsMacro {} {
	    return LDFLAGS
	}
    }


    # the whole toolchain

    namespace eval ::tc_${toolchain} {
	# HIDDEN
	variable CPU
	variable TOOL
	variable TOOL_FAMILY
	variable DEPEND		;# utility for generating dependencies

	# PUBLIC

	proc type {} {
	    return C++
	}

	proc tool {} {
	    variable TOOL
            return   $TOOL
	}

	proc family {} {
	    variable TOOL_FAMILY
            return   $TOOL_FAMILY
	}

	proc cpu {} {
	    variable CPU
            return   $CPU
	}

	proc archDir {} {
	    variable ARCH
            return   $ARCH
	}

	proc name {} {
	    return [cpu][tool]
	}

	proc toolListGet {} {
  	    return [namespace children [namespace current] tool_*]
	}

	proc toolFindByFile {file} {
	    foreach tool [toolListGet] {
		if {[lsearch [${tool}::inputSuffixes] \
			[file extension $file]] != -1} {
		    return $tool
		}
	    }
	    prjWarnLog "no tool works on file $file"
	    return ""
	}

	proc toolFindByType type {
	    foreach tool [toolListGet] {
		if {[${tool}::type] == $type} {
		    return $tool
		}
	    }
	    prjWarnLog "no tool of type $type"
	    return ""
	}

	proc dependFiles {tool flags file } {
	    set cppFlags [cppFlagsGet $flags [namespace current]]
		if { [catch {set bUseQuickScan [::Dependencies::UseQuickScan?]}] || \
				 !$bUseQuickScan || [catch {
			set result [DependencyAnalyzer::GenerateDependenciesFromFile \
							$cppFlags $file]
		} ] } {
			set result [oldDependFiles $tool $flags $file]
		}
		set result
	}

    proc oldDependFiles {tool flags file} {
        variable DEPEND
        global tcInfo_[name]

        set cppFlags [cppFlagsGet $flags [namespace current]]

        #
        # If the compiler writes to standard error 
        # (e.g. a compiler warning) and standard error isn't redirected, 
        # then exec will return an error. To avoid this we redirect
        # stderr to a temporary file, which we can then use to 
        # inform the user of the errors. 
        #
        set errorFile [tempFileGet] 
        if {[catch {eval exec $DEPEND $cppFlags $file \
                2> [filenameQuoteIfNecessary $errorFile]} depend]} {
            set fd [open $errorFile r]
            set dependError [read $fd]
            close $fd
            error "dependency generation failed: $dependError"
        }
        file delete $errorFile

        # strip off line continuation
        regsub -all { \\} $depend {} depend 
        # convert windows style path to unix style.
        regsub -all {\\} $depend {\/} depend
        return [lrange $depend 2 end]
    }

	proc macroListGet {} {
	    global tcInfo_[name]
	    return [array names tcInfo_[name]]
	}

	proc macroDefaultValGet {macro} {
	    global tcInfo_[name]
	    return [set tcInfo_[name]($macro)]
	}

	# the following routines are specific to C++ toolchains
	# XXX - maybe move to architecturedb one day

	# if module1 references a common block symbol in module2, does
	# the linker drag in the whole module, or just the symbol?

	proc commSymLink {} {
	    switch -glob [archDir] {
		mc68k	{return "symbol"}
		default {return "module"}
	    }
	}

	# given a file, the default wtxdownload flags to be used when
	# downloading.
	# this is especially useful because C and C++ object file use
	# different downloading options, because they do different
	# stuff with common block symbols
	proc defaultWtxDownloadFlags { strFilename } {
		set bufNmOutput {}
		# remove the -g flag which request only globals, because we're
		# interested in the non-global cplusplus symbol
		regsub -- -g [macroDefaultValGet NM] {} strCmd
		set bFailed [catch { set bufNmOutput "\n[eval exec $strCmd $strFilename]"}]
		if { $bFailed || [regexp "\n0+\[ \t]+\[A-Za-z]\[ \t]+___gnu_compiled_cplusplus" \
				   $bufNmOutput] } {
			# it's C++ or the exec command failed (assume C++)
			return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_ALL}
		} else {
			# it's C 
			return {LOAD_GLOBAL_SYMBOLS|LOAD_COMMON_MATCH_NONE}
		}
	}		

	# character prepended to "C" symbols by the compiler

	proc cPrependChar {} {
	    switch -glob [cpu] {
		MIPS*	{return ""}
		PPC*	{return ""}
		ARM* {return ""}
		STRONGARM* {return ""}
		XSCALE* {return ""}
		PENTIUM* {return ""}
		SIMHPPA	{return ""}
		SIMSPARCSOLARIS	{return ""}
		ULTRA*	{return ""}
		default {return "_"}
	    }
	}

	# does the assembler have a preprocessor?

	proc asmHasCpp {} {
	    variable TOOL_FAMILY
            if {$TOOL_FAMILY == "gnu" || \
                $TOOL_FAMILY == "diab" } {
		return 1
	    }
	    return 0
	}
    }

    # grab default tool and flag info from the gnuInfo file.
    if {![info exists tcInfo_${toolchain}(DEPEND_GEN_UTIL)]} {
        set option_depend [set tcInfo_${toolchain}(OPTION_DEPEND)]
	set ::tc_${toolchain}::DEPEND \
			"[set tcInfo_${toolchain}(CPP)] $option_depend"
    } else {
	set ::tc_${toolchain}::DEPEND \
		[set tcInfo_${toolchain}(DEPEND_GEN_UTIL)]
    }
    set ::tc_${toolchain}::CPU	[set tcInfo_${toolchain}(CPU)]
    set ::tc_${toolchain}::TOOL	[set tcInfo_${toolchain}(TOOL)]
    set ::tc_${toolchain}::TOOL_FAMILY [set tcInfo_${toolchain}(TOOL_FAMILY)]
    set ::tc_${toolchain}::ARCH [archDirFind [set tcInfo_${toolchain}(CPU)]]
    set ::tc_${toolchain}::tool_ld::tool [set tcInfo_${toolchain}(LD)]
    set ::tc_${toolchain}::tool_cc::tool [set tcInfo_${toolchain}(CC)]
    set ::tc_${toolchain}::tool_as::tool [set tcInfo_${toolchain}(AS)]
    unset tcInfo_${toolchain}(CPU)
    unset tcInfo_${toolchain}(TOOL)
    if {![info exists tcInfo_${toolchain}(OPTION_INCLUDE_DIR)]} {
	set tcInfo_${toolchain}(OPTION_INCLUDE_DIR)	-I
    }
    if {![info exists tcInfo_${toolchain}(OPTION_DEFINE_MACRO)]} {
	set tcInfo_${toolchain}(OPTION_DEFINE_MACRO)	-D
    }
    if {![info exists tcInfo_${toolchain}(OPTION_UNDEFINE_MACRO)]} {
	set tcInfo_${toolchain}(OPTION_UNDEFINE_MACRO)	-U
    }
    if {![info exists tcInfo_${toolchain}(OPTION_LANG_C)]} {
	set tcInfo_${toolchain}(OPTION_LANG_C)	-xc
    }
    if {![info exists tcInfo_${toolchain}(OPTION_DEPEND)]} {
	set tcInfo_${toolchain}(OPTION_DEPEND)	-M
    }
    if {![info exists tcInfo_${toolchain}(OPTION_GENERATE_DEPENDENCY_FILE)]} {
	set tcInfo_${toolchain}(OPTION_GENERATE_DEPENDENCY_FILE) -MD
    }
    if {![info exists tcInfo_${toolchain}(CC_ARCH_SPEC)]} {
	set tcInfo_${toolchain}(CC_ARCH_SPEC) ""
    }
    
    # register the toolchain with the project facility

    prjTcAdd ::tc_${toolchain}
}

###############################################################################
#
# cppFlagsGet - get the C-preprocessor flags within a set of flags
#

proc cppFlagsGet {flags tc} {
    global tcInfo_[${tc}::name]
    set MD      [set tcInfo_[${tc}::name](OPTION_GENERATE_DEPENDENCY_FILE)]
    regsub -all " $MD" $flags {} cppFlags
    return $cppFlags
}

###############################################################################
#
# Returns 1 if toolchain is a simulator toolchain for the host
#
proc isSimulatorTc {tc hostType} {
    set retval 0
    switch $tc {
	::tc_SIMSPARCSOLARISgnu { 
	    if {[string match $hostType sun4-solaris*]} {
                set retval 1
            }
	}
        ::tc_SIMHPPAgnu {
            if {[string match $hostType parisc-hpux*]} {
		set retval 1
	    }
        }
	::tc_SIMNTgnu {
	    if {[string match $hostType x86-win32]} {
                set retval 1
	    }
	}
	default {
	    set retval 0
	}
    }
    return $retval
}

#########################################################################
#
# defaultBasisBspGet - returns default bsp to use for new bootable projects
#
# Returns the host-specific default BSP/toolchain to be used as a basis
# for other vxworks projects
# Return value is a tuple: <BSP, TOOLCHAIN> as a list
# If no value is saved in the registry, 
# the appropriate simulator bsp for the host is returned. 
#
# PARAMETERS
#   hostType: host type, e.g. x86-win32, sun4-solaris2
#   bIgnoreRegistry: (optional) if set to 1, ignore saved registry value and 
#                    return simulator bsp
#
# RETURNS: tuple: <BSP, TOOLCHAIN> as a list e.g. {simpc SIMNTgnu}
#
# ERRORS: N / A
#

proc defaultBasisBspGet {hostType {bIgnoreRegistry 0}} {
    switch -glob $hostType {
        sun4-sunos* {
            set retval [list [file join [wtxPath] target config sunos] gnu]
        }
	sun4-solaris* {
	    set retval [list [file join [wtxPath] target config solaris] gnu]
	}
	parisc-hpux* {
	    set retval [list [file join [wtxPath] target config hpux] gnu]
	}
	x86-win32 -
	default {
	    set retval [list [file join [wtxPath] target config simpc] gnu]
        }
    }
    if {$bIgnoreRegistry == 0} {
        set retval [appRegistryEntryRead -default $retval Workspace DefaultBsp]
    }

    return $retval
}

###############################################################################
#
# Set the default BSP/toolchain to be used as a basis
# for other vxworks projects
#

proc defaultBasisBspSet {bsp toolchain} {
    appRegistryEntryWrite Workspace DefaultBsp [list $bsp $toolchain] 
}

#########################################################################
#
# defaultBasisToolChainGet - returns default toolchain to use for new downloadable projects
#
# Returns the host-specific default tool chain to be used as a basis
# for other downloadable projects. If no value is saved in the registry, 
# the appropriate simulator toolchain for the host is returned. 
#
# PARAMETERS
#   hostType: host type, e.g. x86-win32, sun4-solaris2
#   bIgnoreRegistry: (optional) if set to 1, ignore saved registry value and 
#                    return simulator toolchain
#
# RETURNS: host-specific default tool chain, e.g. SIMNTgnu
#
# ERRORS: N / A
#

proc defaultBasisToolChainGet {hostType {bIgnoreRegistry 0}} {
    switch -glob $hostType {
	sun4-sunos* {
	    set retval SPARCgnu 
	}
	sun4-solaris* {
	    set retval SIMSPARCSOLARISgnu 
	}
	parisc-hpux* {
	    set retval SIMHPPAgnu 
	}
	x86-win32 -
	default {
	    set retval SIMNTgnu 
	}
    }
    if {$bIgnoreRegistry == 0} {
        set retval [appRegistryEntryRead -default $retval Workspace \
	        DefaultToolChain]
    }
    return $retval
}

###############################################################################
#
# Set the default tool chain to be used as a basis
# for other downloadable projects
#
proc defaultBasisToolChainSet {toolchain} {
    appRegistryEntryWrite Workspace DefaultToolChain $toolchain 
}

###############################################################################
#
# For a given bsp directory, return the applicable toolchains and the
# default toolchain.
# RETURNS: <list of tc names, default>, as a list
#

proc getToolChainInfoForBsp {bspDir} {
    set tmp [defaultBasisBspGet [wtxHostType]]
    set basisBsp [lindex $tmp 0] 
    set tool [lindex $tmp 1] 

    ::filePathFix bspDir
    set defaultCpuAndTool [cpuAndToolFromBspGet $bspDir]
    set defaultCpu [lindex $defaultCpuAndTool 0]
    set defaultTool [lindex $defaultCpuAndTool 1]

    set toolsMatchingCpu ""
    set matchingDiabTools ""
    foreach tc [prjTcListGet $defaultCpu {} C++] {
        lappend toolsMatchingCpu [${tc}::tool]
        if {[string match [${tc}::family] "diab"]} {
            lappend matchingDiabTools [${tc}::tool]
        }
    }

    set toolsMatchingCpu [lsort $toolsMatchingCpu]
    set matchingDiabTools [lsort $matchingDiabTools]
    removeDuplicatesFromList toolsMatchingCpu
    removeDuplicatesFromList matchingDiabTools 

    if {[llength $matchingDiabTools] > 0 && $matchingDiabTools != ""} {
        regsub gnu $defaultTool diab diabifiedDefault
        if {[lsearch $matchingDiabTools $diabifiedDefault] != -1} {
            set defaultTool $diabifiedDefault
        }
    }
    return [list $toolsMatchingCpu $defaultTool]
}

###########################################################################
# the dependency analyzer traverses through c or c++ code and returns
# a list of the headers that the c or c++ code depends on.  It caches 
# the data to avoid doing the same stuff twice.

# there are only two entry point into DependencyAnalyzer.
# they are DependencyAnalyzer::ResetCache and
# DependendencyAnalyzer::GenerateDependenciesFromFile.

namespace eval DependencyAnalyzer {
	variable _caches
	set _caches [list _sourceCache _badSourceCache _fileExistsCache]

	######################################################################
	# effect: empties the caches, forcing the analyzer to re-examine files
	# on disk next time GenerateDependenciesFromFile is called.
	proc ResetCache {} {
		variable _caches
		foreach cache $_caches {
			variable $cache
			catch {unset $cache}
			array set $cache {}
		}
	}
	ResetCache
	variable _expIncludeOption
	# regular expression matches -I include directives on gcc command line
	set _expIncludeOption "-I\[ \t]*(\"\[^\"]+\"|'\[^']+'|\[^ \t\r\n]*)"
	# regular expression matches #include in C code
	set _expInclude "(^|\n|\r)\[ \t]*#include\[ \t]*"
	variable _expMacroInclude 
	# regular exp matches #include MACRO in c code.
	set _expMacroInclude "([set _expInclude]\[^<\" \t])|(#define\[^#\n]+#include)"
	variable _expLocalInclude 
	# regular exp matches $include "filename.h" in c code
	set _expLocalInclude "[set _expInclude]\"(\[^\"]+)\""
	variable _expFarInclude 
	# regular exp matches $include <filename.h> in c code
	set _expFarInclude "[set _expInclude]<(\[^>]+)>"
}


# works just like tcl [file exists ...] and it memoizes (caches)
# the result
proc DependencyAnalyzer::FileExists { fullpath } {
	variable _fileExistsCache
	if ![info exists _fileExistsCache($fullpath)] {
		set _fileExistsCache($fullpath) [file exists $fullpath]
	}
	set _fileExistsCache($fullpath)
}

# removes comments and \ line continuers in C or C++ code
# returns the cleaned code
proc DependencyAnalyzer::CleanText { text } {
	# remove all c++ comments
	regsub -all "(^|\r|\n)\[ \t]*//\[^\n]*(\n|\$)" $text {} text
	# remove all c comments
	# hex 81 is not a legal ascii character, so use it as an end
	# of comment marker
	regsub -all {\*/} $text \x81 text
	regsub -all "/\\*\[^\x81]*\x81" $text {} text
	regsub -all \x81 $text /* text
	# turn multiline preprocessor directives into singleline ones
	regsub -all "\\\\(\r?)\n" $text {} text
	set text
}

###########################################################################
# args:
#    text: the full text of a c or c++ file
# returns:
#    a list of the following structure, representing the includes of the file
#    { <local|far> filename } {<local|far> filename} ...
#    local means it was included with "", far means it was included with <>
# throws errors:
#    if the text has a complex macro include, then it throws an error.
#    Here's an example of what I mean by a complex macro include:
#    #define x "Jeffie.h"
#    #include x
proc DependencyAnalyzer::GenerateShallowDependenciesFromText { text } {
	variable _expMacroInclude
	variable _expLocalInclude
	variable _expFarInclude

	set lResult [list]
	set text [CleanText $text]
	if [regexp $_expMacroInclude $text] {
		error "Text contains include macro."
	}

	# now remove all text except the includes
	# this keeps things O(n)
	# again, \x82 and \x83 are illegal ascii characters
	regsub -all "($_expLocalInclude)|($_expFarInclude)" \
		$text \x83\\0\x82 text
	regsub -all "\x82\[^\x83]*\x83" "\x82$text\x83" "|" text
	# now split the remaining text into the list of include statements
	set listIncludes [split $text "|"]
	foreach include $listIncludes {
		if { [regexp $_expFarInclude $include x ws file] } {
			lappend lResult [list far $file]
		} elseif { [regexp $_expLocalInclude $include x ws file] } {
			lappend lResult [list local $file]
		}
	}
	set lResult
}

###########################################################################
# args: 
#    fullpath: a filename naming a c or c++ source or header file
# returns:
#    a list in the form returned by GenerateShallowDependenciesFromText
# throws errors:
#    throws an error if the source file contains a complex include
#    throws an error if fullpath cannot be opened for reading
proc DependencyAnalyzer::GenerateShallowDependenciesFromFile { fullpath } {
	# look for dependencies in the cache
	set result [list ]
 	variable _sourceCache
 	if [info exists _sourceCache($fullpath)] {
		set result $_sourceCache($fullpath)
	} else {
		# it's not in the cache, so calculate
		if [catch {
			# use catch to prevent losing the file handle in event of error
			set f [open $fullpath r]
			set text [read $f]
			close $f
		} err] {
			catch {close $f}
			error $err
		}
		if [catch { set result [GenerateShallowDependenciesFromText $text] } ] {
			variable _badSourceCache
			set _badSourceCache($fullpath) {}
			error "$fullpath contains include macro."
		} else {
			# save result in cache
			set _sourceCache($fullpath) $result
		}
	}
	set result
}


###########################################################################
# args:
#    localDir: the directory in which the root c or c++ file resides
#    farDirs: a list of directories to search for other include files 
#    files: a list in the form returned by 
#           GenerateShallowDependenciesFromText
# returns:
#    A single list, with the full path of all the files.  If a file does
#    not exist in any of the directories, then it is not in the return list.
proc DependencyAnalyzer::CombineDirectoriesAndFiles { localDir farDirs files } {
	set lFullPaths [list ]
	foreach fileinfo $files {
		set bIsLocal 0
		if { [lindex $fileinfo 0] == "local" } {
			set filename [file join $localDir [lindex $fileinfo 1]]
			if [FileExists $filename] {
				lappend lFullPaths $filename
				set bIsLocal 1
			}
		}
		if !$bIsLocal {
			# it's a far include so we need to look through all the far directories
			catch { ;#to catch the break statement
				foreach dir $farDirs {
					set filename [file join $dir [lindex $fileinfo 1]]
					if [FileExists $filename] {
						lappend lFullPaths $filename
						break
					}
				}
			}
		}
	}
	set lFullPaths
}														  

###########################################################################
# ENTRY POINT
# args:
#    flags: a string containing the flags which will be passed to the 
#           c or c++ compiler
#    fullpath: an absolute path to the c or c++ source file for which
#              we want to generate dependencies
# returns:
#    A list of all existing header files that fullpath depends on.
# throws errors:
#    throws an error if a file existed but could not be opened, or
#    a file contained a complex include macro
# notes:
#    caches a lot of information so it never has to touch the file system
#    more than once for any file.  To clear the cache, call ResetCache.
proc DependencyAnalyzer::GenerateDependenciesFromFile \
	{ flags fullpath } {
	  
	array set visited {}
	
	set farDirectories [ExtractDirectoriesFromFlags $flags]

	set localDirectory [file dirname $fullpath]
	if { $localDirectory == "" } {
		set localDirectory [pwd]
	}
	GenerateDependenciesFromFileRecursive $fullpath $localDirectory\
		$farDirectories visited
	# remove the original .c file from visited because it's not
	# dependent on itself
	catch { unset visited($fullpath) }
	# remove the .c file from the cache, because it takes up a lot of
	# space and it is highly unlikely we'll see it again in this pass.
	variable _sourceCache
	catch { unset _sourceCache($fullpath) }
	array names visited
}

###########################################################################
# args:
#   fullpath: an absolute path to the c or c++ source or header file
#   localDirectory: the directory in which the source file resides
#   farDirectories: a list of directories in which to look for other header
#                   files
#   varVisited: the name the variable in the calling scope, which is an
#               array whos indices are files already visited.
# returns:
#   nothing
# throws errors:
#    throws an error if a file existed but could not be opened, or
#    a file contained a complex include macro
# notes:
#   it adds fullpath to the visited array
proc DependencyAnalyzer::GenerateDependenciesFromFileRecursive \
	{ fullpath localDirectory farDirectories varVisited } {

	# first check to see if this is a header with a #include MACRO
	variable _badSourceCache
	if [info exists _badSourceCache($fullpath)] {
		error "$fullpath contains include macro."
	}

	upvar $varVisited visited
	set visited($fullpath) {}

	set dependencies [GenerateShallowDependenciesFromFile $fullpath]
	
	set headers [CombineDirectoriesAndFiles $localDirectory \
					 $farDirectories $dependencies]
	# now recurse
	foreach header $headers {
		if { ![info exists visited($header)] } {
			GenerateDependenciesFromFileRecursive $header \
				[file dirname $header] $farDirectories visited
		}
	}
}

###########################################################################
# args:
#    flags: a string containing the compiler flags
# returns:
#    a list of all the include directories in the flags
proc DependencyAnalyzer::ExtractDirectoriesFromFlags { flags } {
	variable _expIncludeOption
	set lResult [list ]
	
	while { [regexp -- $_expIncludeOption $flags x includePath] } {
		lappend lResult [string trim $includePath {"'}] ;#"
		regsub -- $_expIncludeOption $flags {} flags
	}
	set lResult
}
