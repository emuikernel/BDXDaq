# helpEntryLib.tcl - help entry related library
#
# Copyright 1998 Wind River Systems, Inc
#
# modification history
# --------------------
# 01i,11feb02,wsl  add .lib and .rtn files to "help" link files, fix SPR 70490
# 01h,08mar99,fle  fixed a problem with file name extraction in
#                  subEntriesFileCreate
# 01g,24dec98,fle  modified helpEntryListUpdate to handle overloaded routines
# 01f,06nov98,fle  made htmlIndexCreate more win32 compatible
# 01e,16oct98,fle  added the rule parameter to subEntriesFileCreate
# 01d,08oct98,fle  made entryListInFileGet faster
# 01c,30sep98,fle  added category field to help entries
# 01b,11sep98,fle  added the book and chapter elements in the help entry
#                    description
# 01a,21aug98,fle  written, extracted from htmlLink.tcl v.01a
#

#
# DESCRIPTION
#
# This library contains the routines to use to manipulate help entry related
# objects. The help entries are generated by refgen and stored in the RTN,
# RTN.SUB, LIB and LIB.SUB files.
#
# A help entry is a Tcl list defined a follow :
#
# .TS
# expand;
# 1st element | entry name
# 2nd element | entry short description
# 3rd element | entry pattern as written in the doc file
# 4th element | entry link as it should be written in the doc file
# 5th element | entry book (Tornado Reference ...)
# 6th element | entry chapter (Tornado Tools ...)
# 7th element | entry category (bsp name, library tipe - C, tcl java ...)
# 8th element | entry doc file path
# .TE
#

#
# INTERNAL
#
# This Tcl library contains the following procedures :
#
# entryListInFileGet		- gets a list of entries from a file
# entryFromNameInFileGet	- gets an entry from a file towards its entry
#                                 name
# entryFromPatternInFileGet	- gets an entry from a file towards its pattern
# entryGet			- gets an entry into an entry list
# entryLinkUpdate		- update an entry link towards the entry
#                                 <directory>
# entryImportFileCreate		- updates importation file for htmlLink utility
# entryListInFileSave		- save an entry list in a file
# entryListUpdate		- update an entry list to an entry
# entryLinkUpdateInFile		- recursively update specified links file
# entryListSort			- sort an entry list according to <rule>
#                                 parameter
# subEntriesFileCreate		- creates an entry file of sub folders entries


################################################################################
#
# entryListInFileGet - gets a list of entries from a file
#
# This routine gets a list from a file, assuming that each line is a list entry
#
# SYNOPSIS
#   entryListInFileGet <fileList>
#
# PARAMETERS
#   fileName : list of files to extract entry list from
#
# RETURNS: The list contained by the files or {} if files do not exist or are
#          empty
#
# ERRORS: N/A
#

proc entryListInFileGet { fileList } {

    set fileEntries {}

    foreach fileName $fileList {

	if { [file exists $fileName] && [file readable $fileName] } {

	    set fileId [open $fileName r]

	    while { ! [eof $fileId] } {
		set fileEntry [gets $fileId]
		if { [llength $fileEntry] == 8 } {
		    lappend fileEntries $fileEntry
		} elseif { [llength $fileEntry] == 0 } {
		    continue
		} else {
		    puts stderr \
		      "ERROR: format problem in [file join [pwd] $fileName]"
		    exit 1
		}
	    }

	    close $fileId
	}
    }

    return $fileEntries
}

################################################################################
#
# entryFromNameInFileGet - gets an entry from a file towards its entry name
#
# This procedure gets an entire entry from <entryFile> according to the
# given <entryName>.
#
# NOTE
#   The entry name is the first element of a line in an entry file.
#
# SYNOPSIS
#   entryFromNameInFileGet entryName entryFile
#
# PARAMETERS:
#   entryName : the entry name to look for
#   entryFile : the entry file to look entry name in
#
# RETURNS: The complete entry or {} if no entry has been found
#
# ERRORS: N/A
#

proc entryFromNameInFileGet { entryName entryFile } {

    set foundEntry {}

    if { [file exists $entryFile] && [file readable $entryFile] } {
	set fileId [open $entryFile r]
    } else {
	return {}
    }

    set entryDesc [gets $fileId]

    # look for entry name until the end of file or entry is found

    while { (! [eof $fileId]) && ($foundEntry == {}) } {
	if { [lindex $entryDesc 0] == $entryName } {
	    set foundEntry $entryDesc
	}
	set entryDesc [gets $fileId]
    }

    close $fileId

    return $foundEntry
}

################################################################################
#
# entryFromPatternInFileGet - gets an entry from a file towards its pattern
#
# This procedure gets an entire entry from <entryFile> according to the
# given <entryPattern>.
#
# NOTE
#   The entry pattern is the third element of a line in an entry file.
#
# SYNOPSIS
#   entryFromNameInFileGet entryPattern entryFile
#
# PARAMETERS:
#   entryPattern : the entry pattern to look for
#   entryFile : the entry file to look entry pattern in
#
# RETURNS: The complete entry or {} if no entry has been found
#
# ERRORS: N/A
#

proc entryFromPatternInFileGet { entryPattern entryFile } {

    set foundEntry {}

    if { [file exists $entryFile] && [file readable $entryFile] } {
	set fileId [open $entryFile r]
    } else {
	return {}
    }

    set entryDesc [gets $fileId]

    # look for entry pattern until the end of file or entry is found

    while { (! [eof $fileId]) && ($foundEntry == {}) } {
	if { [lindex $entryDesc 2] == $entryPattern } {
	    set foundEntry $entryDesc
	}
	set entryDesc [gets $fileId]
    }

    close $fileId

    return $foundEntry
}

################################################################################
#
# entryGet - gets an entry into an entry list
#
# SYNOPSIS
#   entryGet <entryType> <searchedEntry> <inEntryList>
#
# This procedure allows to get an intry in <inEntryList> according to the
# <entryType> and <searchedEntry> parameters.
#
# <entryType> can have `-name', `-desc', `-pattern', `-link' '-book' `-chapter' 
# `-category' or `-loc' value. This allows to get a help entry from each of
# its fields. If the <entryType> is wrong, then it is defaulted to `-name'
#
# NOTE
#   Only the first occurrence of the <entryType> matching <searchedEntry> is
#   returned
#
# PARAMETERS
#   entryType : retrieving entry from its entryType element.
#   searchedEntry : searched entri in <inEntryList>
#   inEntryList : list of help entry to search <searchedEntry> in
#
# RETURNS: The found entry or {} if no entry was found
#
# ERRORS: N/A
#

proc entryGet { entryType searchedEntry inEntryList } {

    set foundEntry {}

    # set entry number according to entryType

    if { $entryType == "-desc" } {
	set entryNum 1
    } elseif { $entryType == "-pattern" } {
	set entryNum 2
    } elseif { $entryType == "-link" } {
	set entryNum 3
    } elseif { $entryType == "-book" } {
	set entryNum 4
    } elseif { $entryType == "-chapter" } {
	set entryNum 5
    } elseif { $entryType == "-category" } {
	set entryNum 6
    } elseif { $entryType == "-loc" } {
	set entryNum 7
    } else {
	set entryNum 0
    }

    # browse the entry list to find the searched entry according to chapter

    foreach entry $inEntryList {
	if { [lindex $entry $entryNum] == $searchedEntry } {
	    set foundEntry $entry
	    break
	}
    }

    return $foundEntry
}

################################################################################
#
# entryLinkUpdate - update an entry link towards the entry <directory>
#
# This routine updates the link field from the <entryDesc> variable according
# to the <directory> value
#
# SYNOPSIS
#   entryLinkUpdate entryLink directory
#
# PARAMETERS
#   entryDesc : the entry link to modify
#   directory : the directory to modify the entry link
#
# EXAMPLE
#
# .CS
#   entryLinkUpdate {<i><a href="index.html">HTML Works</a></i>} eHtml
#   <i><a href="./eHtml/index.html">HTML Works</a></i>
# .CE
#
# RETURNS: The modified entry link
#
# ERRORS: N/A
#

proc entryLinkUpdate { entryLink directory } {

    # look for the href html tag, and replace the link it links to

    regexp "(.*href\[^\"]+\")(\\./)?(\[^\"]*)(\".*)" $entryLink \
	   fullLink linkStart selfLoc link linkEnd

    set modifiedLink "$linkStart./$directory/[file tail $link]$linkEnd"

    # return the modified link

    return $modifiedLink
}

################################################################################
#
# entryImportFileCreate - updates importation file for htmlLink utility
#
# This routine updates the IMPORT file of the specified <inDir>. If not
# existing, the IMPORT file is created. The imported routines / liraries are
# assumed to be BOLD written in the html file.
#
# This routine opens all the html files of the <inDir> directory, gets all the
# bolded element of those files, then compares those element with elements in
# the LIB and RTN files that should contain all the locally defined routines /
# libraries.
#
# Thus, the IMPORT file should only contain elements that are bolded in the html
# file. Then, by looking in the local LIB, LIB.SUB, RTN and RTN.SUB files, the
# IMPORT file is updated to only keep unreferenced bolded links.
#
# SYNOPSIS
#   entryImportFileCreate <filePattern> [<directory>]
#
# PARAMETERS
#   filePattern : file pattern to be opened in <directory>
#   directory : the directory to look import marks in
#
# RETURNS: a list which first element is OK, or ERROR if it failed. Error
#          messages are appended at the end of the list
#
# ERRORS:
#   OPEN_FILE_ERROR : can not open file
#
# EXAMPLE
# .CS
#   entryImportFileCreate *.html /vobs/wpwr/docs/host/tgtsvr
#   OK
# .CE
#

proc entryImportFileCreate { filePattern {directory "."} } {

    set boldedTextList {}		;# list of current folder bolded text
    set helpEntryList {}		;# list of registered help entries
    set helpEntryPatternList {}		;# list of help entries patterns
    set tmpEntryList {}			;# list of temporary help entries
    set patternList {}			;# list of the local bolded patterns
    set status { {OK} }			;# returned status

    # go into the specified directory

    set prevPath [pwd]
    cd $directory

    # get the list of all the bolded text in all the doc files

    set docFileList [glob -nocomplain $filePattern]

    foreach docFile $docFileList {

	set fileBoldedTextList [htmlFormattedStringsGet $docFile bold]

	foreach boldedText $fileBoldedTextList {
	    lappend patternList $boldedText
	    lappend boldedTextList [list $boldedText \
					 "[pwd]/$docFile"]
	}
    }

    # get the current folder help rtn entries

    set allFileList [glob -nocomplain *.lib *.rtn LIB RTN]
    set helpEntryList [entryListInFileGet $allFileList]

    foreach helpEntry $helpEntryList {
	if { $helpEntry != {} } {
	    lappend helpEntryPatternList [lindex $helpEntry 2]
	}
    }

    # for each pattern of the local entry file, dismiss that entry from the
    # IMPORT file

    foreach pattern $helpEntryPatternList {
	set entryNum [lsearch -regexp $patternList $pattern]
	if { $entryNum != -1 } {
	    set boldedTextList [lreplace $boldedTextList $entryNum $entryNum {}]
	}
    }

    # save list in IMPORT file

    if { [catch "open IMPORT w" fileId] } {
	cd $prevPath
	set status [lreplace $status 0 0 ERROR]
	lappend status $fileId
	return $status
    }

    foreach boldedText $boldedTextList {
	if { $boldedText != {} } {

	    # replace all the \n chars with spaces as far as an entry is
	    # defined as a one-line in file

	    regsub -all "\n" $boldedText " " boldedText
	    puts $fileId $boldedText
	}
    }

    close $fileId
    cd $prevPath
    return $status
}

################################################################################
#
# entryListInFileSave - save an entry list in a file
#
# This procedure saves the <entryList> entry list into the specified <inFile>
# file
#
# SYNOPSIS
#   entryListInFileSave <entryList> <inFile>
#
# PARAMETERS
#   entryList : the entry list to save in file
#   inFile : the name of the file to save entry list in
#
# RETURNS:
#   a list with OK as first element if operation succeeded, or ERROR if
#   it failed. On failure, the second element in list is the error description
#
# ERRORS: N/A
#

proc entryListInFileSave { entryList inFile } {

    if { [catch "open $inFile w" fileId] } {
	return [list "ERROR" $fileId]
    }

    foreach entry $entryList {
	puts $fileId $entry
    }
    close $fileId

    return [list "OK" {}]
}

################################################################################
#
# entryListUpdate - update an entry list to an entry
#
# This routine updates a list from an entry.
#
# If entry is not in the List, it is added.
#
# If entry has changed it is replaced by new value. An entry is said changed
# when it has the same entry name, the same entry files, but is not exactly
# identical to what has been found in the <entryList>
#
# If entry is strictly identical in list, nothing is done.
#
# SYNOPSIS
#   entryListUpdate entryList newEntry
#
# PARAMETERS
#   entryList : list of existing entries in list
#   newEntry : list entry to update
#
# RETURNS: The updated list
#
# ERRORS: N/A
#

proc entryListUpdate { entryList newEntry } {

    set entryNames {}
    set entryFiles {}
    set entryLinks {}
    set newEntryName [lindex $newEntry 0]
    set newEntryLink [lindex $newEntry 3]
    set newEntryFile [lindex $newEntry end]

    # first look for all entry names and source files

    foreach entry $entryList {
	lappend entryNames [lindex $entry 0]
	lappend entryLinks [lindex $entry 3]
	lappend entryFiles [lindex $entry end]
    }

    # then look for entry name in list

    set entryNum [lsearch $entryNames $newEntryName]

    if { ($entryNum == -1) ||
	 ($newEntryFile != [lindex $entryFiles $entryNum]) ||
	 ($newEntryLink != [lindex $entryLinks $entryNum]) } {

	# list entry is not in list or its file location differs, or its link
	# differs from already existing one : add it to list

	lappend entryList $newEntry

    } else {

	if { $newEntry != [lindex $entryList $entryNum] } {
	    set entryList [lreplace $entryList $entryNum $entryNum \
				    $newEntry]
	}
    }

    if { [lsearch -exact $entryList $newEntry] ==  -1} {
	lappend entryList $newEntry
    }

    return $entryList
}

################################################################################
#
# entryListSort - sort an entry list according to <rule> parameter
#
# This utility is to sort an entry list according to the <rule> parameter.
#
# Values for <chapter> are `-name', `-desc', `-pattern', `-link', `-book',
# `-chapter', `-category' `-loc'. This allow to sort an entry list from all of
# its parameters.
#
# If <rule> is unknown, then the name parameter is used.
#
# SYNOPSIS
#   entryListSort <rule> <entryList>
#
# PARAMETERS
#   rule : the rule to use to sort the list
#   the list to be sorted by the <rule> parameter
#
# RETURNS: The sorted list
#
# ERRORS: N/A
#

proc entryListSort { rule entryList } {

    if { $rule == "-desc" } {
	set sortedEntryList [lsort -index 1 $entryList]
    } elseif { $rule == "-pattern" } {
	set sortedEntryList [lsort -index 2 $entryList]
    } elseif { $rule == "-link" } {
	set sortedEntryList [lsort -index 3 $entryList]
    } elseif { $rule == "-book" } {
	set sortedEntryList [lsort -index 4 $entryList]
    } elseif { $rule == "-chapter" } {
	set sortedEntryList [lsort -index 5 $entryList]
    } elseif { $rule == "-category" } {
	set sortedEntryList [lsort -index 6 $entryList]
    } elseif { $rule == "-loc" } {
	set sortedEntryList [lsort -index 7 $entryList]
    } else {
	set sortedEntryList [lsort -index 0 $entryList]
    }

    return $sortedEntryList
}

################################################################################
#
# subEntriesFileCreate - creates an entry file of sub folders entries
#
# This procedure creates the <entryFileName>.SUB file containing all references
# found in the one-level sub folders <entryFileName> files.
#
# This procedure first recursively gets all the one-level sub-folder files
# matching <entryFileName> then, it creates the <entryFileName>.SUB file where
# to save all the sub-folders entries in.
#
# The following table explains the values <rule> can have and the behaviour of
# `subEntriesFileCreate' in those cases.
#
# .TS
# expand;
# `-add' | T{
# just adds sub entries to entry list without checking if it is already in or
# not
# T}
# `-update' | T{
# the entry list is `updated'. If the entry name is found in the list, then
# the file location is checked. If it is not the same file locatio, then it
# is considered as a new entry, and the entry is added to the list. If the name
# and file location are the same, but not the content, then content is updated
# towards new entry content.
# T}
# .TE
#
# SYNOPSIS
#   subEntriesFileCreate <rule> <entryFileName>
#
# PARAMETERS
#   rule : the rule to apply to create sub entry files
#   entryFileName : either LIB or RTN for libraries and routines
#
# RETURNS: N/A
#
# ERRORS: N/A
#

proc subEntriesFileCreate { rule entryFileName } {

    set dirList {}		;# sub directories list
    set fileEntryList {}	;# file entries
    set curFileEntries {}	;# current file entries
    set entryFileList {}	;# entry files list

    if { $entryFileName != "RTN" && $entryFileName != "LIB" } {
	puts stderr "ERROR: Illegal value for entryFileName: $entryFileName"
	exit 1
    }

    # now search for file name occurrence in sub folders

    set startDir [pwd]
    set fileNameList [glob -nocomplain *]
    foreach fileName $fileNameList {

	if { [file isdirectory $fileName] } {

	    if { [catch {cd $fileName}] } {
		continue
	    }

	    if { $entryFileName == "RTN" } {
		set subList [glob -nocomplain RTN.SUB RTN *.rtn]
	    } else {
		set subList [glob -nocomplain LIB.SUB LIB *.lib]
	    }

	    foreach entry $subList {
		lappend entryFileList [file join $fileName $entry]
	    }

	    cd $startDir
	}
    }

    # if list of files is empty, no need to update current file

    if { $entryFileList == {} } {
	return
    }

    # update current entryFileName from all sub-dirs entryFileName

    foreach entryFile $entryFileList {

	set curFileEntries [entryListInFileGet $entryFile]

	foreach fileEntry $curFileEntries {

	    # get HTML file location in doc tree (last element of entry)

	    set fileName [lindex $fileEntry end]

	    if { $fileName == {} } {
		set location [file tail [file dirname $entryFile]]
	    } else {
		set location [file tail [file dirname $entryFile]]
		set location [file join $location $fileName]
	    }

	    # update link location

	    set updatedLink [entryLinkUpdate [lindex $fileEntry 3] $location]
	    set entryDesc [lrange $fileEntry 0 2]
	    set entryDesc [lappend entryDesc $updatedLink [lindex $fileEntry 4]\
				   [lindex $fileEntry 5] [lindex $fileEntry 6]]
	    set fileEntry [lappend entryDesc $location]

	    # update entry if necessary

	    if { $rule == "-update" } {
		set fileEntryList [entryListUpdate $fileEntryList $fileEntry]
	    } else {
		lappend fileEntryList $fileEntry
	    }
	}
    }

    # sort entries then save them one by one in the <entryFileName>.SUB file

    set fileEntryList [lsort -dictionary -index 0 $fileEntryList]
    set fileId [open "$entryFileName.SUB" w]
    foreach fileEntry $fileEntryList {
	puts $fileId $fileEntry
    }
    close $fileId
}
