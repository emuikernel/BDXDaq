/*
 * Copyright (c) 1983 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#ifndef lint
static char sccsid[] = "@(#)hayes.c	5.2 (Berkeley) 9/13/88";
#endif /* not lint */

/*
 * Routines for calling up on a Hayes Modem
 * (based on the old VenTel driver).
 * The modem is expected to be strapped for "echo".
 * Also, the switches enabling the DTR and CD lines
 * must be set correctly.
 * NOTICE:
 * The easy way to hang up a modem is always simply to
 * clear the DTR signal. However, if the +++ sequence
 * (which switches the modem back to local mode) is sent
 * before modem is hung up, removal of the DTR signal
 * has no effect (except that it prevents the modem from
 * recognizing commands).
 * (by Helge Skrivervik, Calma Company, Sunnyvale, CA. 1984) 
 */
/*
 * TODO:
 * It is probably not a good idea to switch the modem
 * state between 'verbose' and terse (status messages).
 * This should be kicked out and we should use verbose 
 * mode only. This would make it consistent with normal
 * interactive use thru the command 'tip dialer'.
 */
#include "tip.h"
#include <sys/time.h>

#define	min(a,b)	((a < b) ? a : b)


/* result codes */ ;
static char MDM_OK[] = "OK\r\n";
static char RRING[] = "RRING\r\n";
static char CONNECT[] = "CONNECT";	/* generic prefix */

#define	CMD_DELAY	5	/* number of seconds to wait for response
				 * while in command mode */
#define DIAL_DELAY	120	/* number of seconds to wait for response
				 * after sending dial string */
#define WRITE_DELAY	100	/* ms between each character written to modem */
#define	MAXSTR	256

static	int timeout = 0;
#define DUMBUFLEN	40
static char dumbuf[DUMBUFLEN];

#define	DIALING		1
#define IDLE		2
#define CONNECTED	3
#define	FAILED		4
static	int state = IDLE;

static char *hypretty();
static char hygetc();
static int hyread();;
static void hywrite();
static void hyerrputs();

hay_dialer(num, acu)
	register char *num;
	char *acu;
{
	register char *cp;
	register int connected = 0;
	char dummy;
	char buf[MAXSTR];
	int verbose = boolean(value(VERBOSE));
	char c;
#ifdef ACULOG
	char line[80];
#endif
	if (hay_sync() == 0)		/* make sure we can talk to the modem */
		return(0);
	if (ioctl(FD, TIOCHPCL, 0) < 0)
		perror("tip: TIOCHPCL ioctl");
	if (ioctl(FD, TIOCFLUSH, 0) < 0)	/* get rid of garbage */
		perror("tip: TIOCFLUSH ioctl");

	/* tell modem to not to echo */
	hywrite("ATE0\r");

	if (hyread(buf, CMD_DELAY, sizeof(buf)) == 0) {
		(void) fprintf(stderr, "hayes not responding\n");
		(void) fflush(stderr);
		return (0);
	}

	if (hyread(buf, CMD_DELAY, sizeof(buf)) == 0 ||
	    strcmp(buf, MDM_OK) != 0) {
		(void) fprintf(stderr, "hayes not responding (2)\n");
		(void) fflush(stderr);
		return (0);
	}

	/* if the "phone number" doesn't start with a digit, assume it's
	 * a command string to go to the hayes */
	if (verbose) {
		(void) printf("dialing... ");
		if (debug)
			putchar('\n');
		(void) fflush(stdout);
	}
	if (isdigit(*num))
		(void) sprintf(buf, "ATDT%s\r", num);
	else
		(void) sprintf(buf, "AT%s\r", num);
	state = DIALING;
	connected = 0;
	hywrite(buf);

#ifdef notdef
	/* Eat "OK" */
	if (hyread(buf, CMD_DELAY, sizeof(buf)) == 0 ||
	    strcmp(buf, MDM_OK) != 0) {
		state = FAILED;
		(void) fprintf(stderr, "didn't get OK\n");
		(void) fflush(stderr);
		return (0);
	}
#endif

	while (1) {
		if (hyread(buf, DIAL_DELAY, sizeof(buf)) == 0) {
			(void) strcpy(buf, "timeout on dial");
#ifdef ACULOG
			logent(value(HOST), num, NAME, buf);
#endif
			return (0);
		}
		/* Eat possible blank line */
		if (strcmp(buf, "\r\n") == 0)
			continue;
		if (strncmp(buf, RRING, strlen(RRING)))
			break;
		if (verbose) {
			(void) printf("ringing...");
			if (debug)
				putchar('\n');
			(void) fflush(stdout);
		}
	}

	if (strncmp(buf, CONNECT, strlen(CONNECT)) != 0) {
		char buf2[MAXSTR];

		state = FAILED;
		if (debug)
			putchar('\n');
		(void) fflush(stdout);
		(void) sprintf(buf2, "dial failed (%s)", hypretty(buf));
		(void) printf("%s", buf2);
		(void) fflush(stdout);
#ifdef ACULOG
		logent(value(HOST), num, NAME, buf2);
#endif
		return (0);
	}

	/*
	 * We assume the modem has lock speed set so we don't care
	 * what the connect speed was.
	 */
	ttysetup(speed(BR));
	if (verbose) {
		(void) printf("(%s)", hypretty(buf));
		if (debug)
			putchar('\n');
		(void) fflush(stdout);
	}

	if (ioctl(FD, TIOCFLUSH, 0) < 0)	/* get rid of garbage */
		perror("tip: TIOCFLUSH ioctl");
	return(1);
}


hay_disconnect()
{
	char c;
	int len, rlen;

	/* first hang up the modem*/
#ifdef DEBUG
	printf("\rdisconnecting modem....\n\r");
#endif
	ioctl(FD, TIOCCDTR, 0);
	sleep(1);
	ioctl(FD, TIOCSDTR, 0);
	goodbye();
}

hay_abort()
{

	char c;

	hywrite("\r");		/* send anything to abort the call */
	hay_disconnect();
}

error_rep(c)
	register char c;
{
	printf("\n\r");
	switch (c) {

	case '0':
		printf("OK");
		break;

	case '1':
		printf("CONNECT");
		break;
	
	case '2':
		printf("RING");
		break;
	
	case '3':
		printf("NO CARRIER");
		break;
	
	case '4':
		printf("ERROR in input");
		break;
	
	case '5':
		printf("CONNECT 1200");
		break;
	
	case '6':
		printf("NO DIALTONE");
		break;

	case '7':
		printf("BUSY");
		break;

	case '8':
		printf("NO ANSWER");
		break;

	default:
		printf("Unknown Modem error: %c (0x%x)", c, c);
	}
	printf("\n\r");
	return;
}

/*
 * set modem back to normal verbose status codes.
 */
goodbye()
{
	int len, rlen;
	char c;
	char buf[32];

	ioctl(FD, TIOCFLUSH, &len);	/* get rid of trash */
	if (hay_sync()) {
#ifndef DEBUG
		ioctl(FD, TIOCFLUSH, 0);
#endif
		hywrite("ATH0\r");			/* insurance */
#ifndef DEBUG
		number(value(DIALTIMEOUT)) = 10;	/* shorten timeout */
		if (hyread(buf, CMD_DELAY, sizeof(buf)) == 0) {
			printf("cannot hang up modem\n\r");
			printf("please use 'tip dialer' to make sure the line is hung up\n\r");
		}
#ifdef notdef
fprintf(stderr, "goodbye(): read \"");
hyerrputs(buf);
fprintf(stderr, "\"\n");
#endif
#endif
		ioctl(FD, FIONREAD, &len);
#ifdef DEBUG
		printf("goodbye1: len=%d -- ", len);
		rlen = read(FD, dumbuf, min(len, DUMBUFLEN));
		dumbuf[rlen] = '\0';
		printf("read (%d): %s\r\n", rlen, dumbuf);
#endif
		hywrite("ATE1\r");
#ifdef DEBUG
		ioctl(FD, FIONREAD, &len);
		printf("goodbye2: len=%d -- ", len);
		rlen = read(FD, dumbuf, min(len, DUMBUFLEN));
		dumbuf[rlen] = '\0';
		printf("read (%d): %s\r\n", rlen, dumbuf);
#endif
	}
	ioctl(FD, TIOCFLUSH, 0);	/* clear the input buffer */
	ioctl(FD, TIOCCDTR, 0);		/* clear DTR (insurance) */
	close(FD);
}

#define MAXRETRY	2

hay_sync()
{
	int len, retry = 0;
	char buf[32];
	int verbose = boolean(value(VERBOSE));
static int init = 0;

if (init) {
	fprintf(stderr, "skipping hay_sync()...\n");
	return;
}
++init;

	if (verbose) {
		(void) printf("syncing with dialer... ");
		if (debug)
			putchar('\n');
		(void) fflush(stdout);
	}
	while (retry++ <= MAXRETRY) {
		hywrite("\rAT\r");
		if (hyread(buf, CMD_DELAY, sizeof(buf)) &&
		    strcmp(buf, "\rAT\r\r\n") == 0)
			if (hyread(buf, CMD_DELAY, sizeof(buf)) &&
			    strcmp(buf, MDM_OK) == 0)
				return(1);
		ioctl(FD, TIOCCDTR, 0);
		ioctl(FD, TIOCSDTR, 0);
	}
	printf("Cannot synchronize with hayes...\n\r");
	(void) fflush(stdout);
	return(0);
}

static void
hyerrputc(c)
	char c;
{

	if (c & ~0177) {
		putc('M', stderr);
		putc('-', stderr);
		c &= 0177;
	}
	switch (c) {

	case '\r':
		putc('\\', stderr);
		putc('r', stderr);
		break;

	case '\n':
		putc('\\', stderr);
		putc('n', stderr);
		break;

	case '\t':
		putc('\\', stderr);
		putc('t', stderr);
		break;

	default:
		if (c < 0x20) {
			putc('^', stderr);
			putc(c + 0x40, stderr);
		} else
			putc(c, stderr);
	}
	(void) fflush(stderr);
}

static void
hyerrputs(s)
	register char *s;
{

	while (*s)
		hyerrputc(*s++);
}

/* Trim leading and trailing white space */
static char *
hypretty(s)
	register char *s;
{
	register char *cp;

	cp = s;
	cp += strlen(s) - 1;
	while (cp > s && isspace(*cp & 0177))
		*cp-- = '\0';
	cp = s;
	while (isspace(*cp & 0177))
		cp++;
	return(cp);
}

static void
hyputc(c)
	char c;
{
	struct timeval t;

	if (write(FD, &c, 1) != 1) {
		perror("tip: hyputc: write error");
		return;
	}
	if (debug)
		hyerrputc(c);
	t.tv_sec = 0;
	t.tv_usec = WRITE_DELAY * 1000000;
	(void) select(32, 0, 0, 0, &t);
}

static void
hywrite(cp)
	register char *cp;
{

	if (debug) {
		(void) fprintf(stderr, "\r-> \"");
		(void) fflush(stderr);
	}
	while (*cp != '\0')
		hyputc(*cp++);
	if (debug) {
		(void) fprintf(stderr, "\"\r\n");
		(void) fflush(stderr);
	}
}

static char
hygetc(timeout)
	unsigned int timeout;
{
	int n;
	char c;
	struct timeval t;
	int readfds;

	t.tv_sec = timeout;
	t.tv_usec = 0;
	readfds = 1 << FD;
	if ((n = select(FD+1, &readfds, 0, 0, &t)) <= 0) {
		if (n < 0)
			perror("hygetc: select");
		return (0);
	}
	if ((n = read(FD, &c, 1)) <= 0) {
		perror("hygetc: read");
		return (0);
	}
	if (debug)
		hyerrputc(c);
	return (c);
}

/*
 * Read a line from the telebit. We assume a line end with line feed.
 */
static int
hyread(buf, timeout, max)
	char *buf;
	unsigned int timeout, max;
{
	char *cp = buf;
	char c;
	int ret = 1;

	if (debug) {
		(void) fprintf(stderr, "\r<- \"");
		(void) fflush(stderr);
	}
	*buf = '\0';

#ifdef notdef
	/* get the initial \r \n */
	if ((*cp++ = hygetc(timeout)) == 0) {
		ret = 0;
		goto bail;
	}
	if ((*cp++ = hygetc(timeout)) == 0) {
		ret = 0;
		goto bail;
	}
#endif

	/* grab everything up to the next \n */
	while (cp < &buf[max - 2] && (*cp++ = c = hygetc(timeout)) != '\n')
		if (c == 0) {
			ret = 0;
			goto bail;
		}
	*cp = '\0';

bail:
	if (debug) {
		(void) fprintf(stderr, "\"%s\r\n", ret ? "" : " *");
		(void) fflush(stderr);
	}
	return(ret);
}
