#!/bin/sh
#
# mofset \- make structure member offset definitions header
#
# modification history
# --------------------
# 01a,24jan90,rbr  Written.
# 02a,15aug90,rbr  Added shell wrapper to compile and run the generated
#		   C program.  Also fixed bugs: accept -D definitions;
#		   ignore scalar typedefs; handle embedded unions; handle
#		   punctuation variations.
#
# SYNOPSIS
# \fBmofset\fR \fIheader-file\fR
#
# DESCRIPTION
# \fBmofset\fR reads structure and union type definitions from a C header
# (conforming to the Wind River Systems Coding Conventions) and generates
# a second header on the standard output,  containing symbolic constant
# definitions for the address offsets of structure members,  which can be
# used in assembly language code.  Symbolic constant and macro definitions
# from the source header will also be reproduced in the result header;  other
# preprocessor directives and C statements will be discarded.
#
# EXAMPLE
# .PP
# Given this input in \f(CWthing.h\fR:
# .DS
# .nf
# 
# .ft CW
# 	#define BIG	1024
# 
# 	typedef struct
# 		{
# 			int count;
# 			char string [BIG];
# 			FILE *fp;
# 		} THING;
# .ft R
# 
# .fi
# .DE
# the command
# .DS
# .nf
# 
# .ft CW
# 	mofset thing.h
# .ft R
# 
# .fi
# .DE
# would produce output like the following:
# .DS
# .nf
# 
# .ft CW
# 	/* generated from thing.h */
# 
# 	#define BIG	1024
# 
# 	/* begin structure member offsets */
# 
# 	#define	THING_COUNT                           0x0
# 	#define	THING_STRING                          0x4
# 	#define	THING_FP                              0x404
# 
# 	/* end offsets (THING) */
# .ft R
# .fi
# .DE
# .SH AUTHOR
# .PP
# Roger Rohrbach
#*/


# process options:

while true
do
    case ${1?"missing filename"} in
        -D*)
	    defines="$defines $1"
	    shift
	    ;;
        *)
	    break;;
    esac
done

trap "rm -f offsets$$*" 0 1 2 3 15


# generate C program to print offsets:

{
    grep -s '^#include[ 	]*"vxWorks.h"' $1 ||
	echo '#include "vxWorks.h"'

    awk "`sed -n '/^# awk program/,$p' $0`" $1
} > offsets$$.c


# Compile and run program.
# Ignore warnings generated by use of OFFSET() macro.

cc -o offsets$$ -I/usr/vw/h $defines offsets$$.c 2>&1 | grep -v ignored >&2

if [ -f offsets$$ ]
then
    offsets$$
    exit 0
else
    trap "" 0
    exit 1
fi


# end of shell program
# awk program follows

BEGIN {

    # define toupper[] function:

    split("_,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z", lower, ",");
    split("_,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z", upper, ",");

    for (i in lower)
	toupper[lower[i]] = upper[i];


    printf("#include\t\"%s\"\n", FILENAME);
    printf("main()\n\t{\n");
    printf("\tprintf(\"/* generated from %s */\\n\\n\");\n", FILENAME);
}

$1 ~ /#.*if.*/ {

    # Propagate #if, etc. to C program to control which structures
    # output is produced for.

    if (substr($2, 1, 3) == "INC")
	$2 = "NEVERMIND";	# disable include file toggle switch

    print;
}

$1 == "#define" {
    inDef = 1;
}

inDef == 1 {
    # Propagate symbolic constants/macros.

    # escape characters that should not be interpreted now:
    s = ""
    for (i = 1; i <= length; ++i)
    {
	c = substr($0, i, 1);
	if (c ~ /["\\]/)
	    c = "\\" c;
	else if (c == "%")
	    c = "%" c;
	s = s c;
    }
    printf("\tprintf(\"%s\\n\");\n", s);


    # stay inDef if this a multi-line macro definition

    if (index($0, "\\") != length)
	inDef = 0;
}

$1 == "typedef" {

    getline;

    if ($1 != "{")
	next;

    printf("\tprintf(\"\\n\\n/* begin structure member offsets */\\n\\n\");\n");

    members = 0;

    while (getline && $1 != "}")
    {
	# only examine structure member declarations
	if (!index($0, ";"))
	{
	    if ($1 == "union")
		while (getline && $1 != "}")
		    ;
	    else
	        continue;
	}

	# seek to variable name:
	word = 1;
	while (!(i = index($word, ";")))
	    ++word;
	j = index($word, "[");

	if (j == 1)
	{
	    --word;
	    len = length($word);
	}
	else if (j)
	    len = j - 1;
	else
	    len = length($word) - 1;

	# pick out the identifier name:


	c = s = "";
	for (i = 1; i <= len; ++i)
	{
	    c = substr($word, i, 1);
	    if (c ~ /[A-Za-z_0-9]/)
		s = s c;
	}

	len = length(s);
	varName[++members] = s;


	# this whole ordeal just maps lower- to upper-case to get varNameDef
	s = ""
	for (i = 1; i <= len; ++i)
	{
	    c = substr(varName[members], i, 1);
	    if (c2 = toupper[c])
		c = c2;
	    else
		c = "_" c;
	    s = s c;
	}
	varNameDef[members] = s;
    }


    # get structure name:

    len = length($2) - 1;
    structName = substr($2, 1, len);


    # more case mapping...
    s = ""
    for (i = 1; i <= len; ++i)
    {
	c = substr(structName, i, 1);
	if (c2 = toupper[c])
	    c = c2;
	s = s c;
    }
    structNameDef = s;


    # generate C statement to print symbolic constant for offset:

    for (i = 1; i <= members; ++i)
    {
	printf("\tprintf(\"#define\\t%s_%-32s", structNameDef, varNameDef[i]);
	printf("0x%%x\\n\", OFFSET(%s, %s));\n", structName, varName[i]);
    }

    printf("\tprintf(\"\\n/* end offsets (%s) */\\n\\n\\n\");\n", structName);
}

END {
    printf("\texit(0);\n\t}\n");
}
