/******************************************************************************
*              (c), Copyright, MOTOROLA  INC  - ECC                  *
*                                                                             *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MOTOROLA , INC.        *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT *
* OF MOTOROLA  OR ANY THIRD PARTY. MOTOROLA  RESERVES THE RIGHT AT ITS SOLE DISCRETION*
* TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MOTOROLA .       *
* THIS CODE IS PROVIDED "AS IS". MOTOROLA  MAKES NO WARRANTIES, EXPRESS,*
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.  *
******************************************************************************/

#ifdef PMC280_DUAL_CPU
/*******************************************************************************
* vxDbIntCtrl.c - Doorbell interrupt controller library
*
* DESCRIPTION:
*       This driver provides various interface routines to manipulate and
*       connect the hardware interrupts concerning the MV Doorbell facility.
*
*       Main features:
*        - The controller provides an easy way to hook a C Interrupt Service
*          Routine (ISR) to a specific interrupt caused by the Doorbell 
*          register 
*        - The controller interrupt mechanism provides a way for the programmer
*          to set the priority of an interrupt.
*        - Full interrupt control over the Doorbell facility.
*
*       Overall Interrupt Architecture description:
*        The MV handles interrupts in two stages:
*        STAGE 1: Main Cause register that summarize the interrupts generated 
*                 by each Internal MV unit.
*        STAGE 2: Unit specified cause registers, that distinguish between each
*                 specific interrupt event.
*        This Doorbell Interrupt Controller Driver handles the various 
*        interrupts  generated by the second stage.
*
*       The driver's execution flow has three phases:
*        1) Driver initialization. This initiation includes hooking driver's 
*           ISR to the MV Interrupt controller. Composed of frcDbIntCtrlInit() 
*           routine.
*        2) User ISR connecting. Here information about user ISR and interrupt 
*           priority is gathered. Composed of frcDbIntConnect() routine.
*        3) Interrupt handler. Here interrupts are being handle by the 
*           Interrupt Handler. Composed of frcDbIntHandler(), 
*
*       Full API:    
*         frcDbIntCtrlInit() - Initialise the Doorbell interrupt controller 
*                             driver.
*         frcDbIntConnect()  - Connect a user ISR to a Doorbell interrupt event.
*         frcDbIntEnable()   - Enable a given Doorbell interrupt cause.
*         frcDbIntDisable()  - Disable a given Doorbell interrupt cause.
*         frcDbIntHandler()  - Handles Doorbell interrupts according to user ISR.
*
*       The controller concept is very simple:
*        The Interrupt handler has a table which holds information on 
*        the connected user ISR. An Interrupt generated by one of the doorbell 
*	 bits will result a search through this table in order to allocate 
*	 the generating interrupt cause.
*        After the initiating interrupt cause is identify, the ISR reside in 
*        the same table entry is executed.
*       
*       The controller interface also includes interrupt control routines which
*       can enable/disable specific interrupts: frcDbIntDisable() and
*       frcDbIntEnable().
*   
* DEPENDENCIES:
*		GT Interrupt Control Driver.
*		SMP module.
*		VxWorks types and interrupt lib.
*
*******************************************************************************/

/* includes */
#include "vxDbIntCtrl.h"
#include "vxWorks.h"
#include "stdio.h"

#ifdef PMC280_DEBUG_UART_VX
#include "dbgprints.h"
#endif /* PMC280_DEBUG_UART_VX */

#include "gtSmp.h"

#ifdef INCLUDE_WINDVIEW
#include "private/funcBindP.h"
#include "private/eventP.h"
#include "wvLib.h"
#endif   /* INCLUDE_WINDVIEW */


/* defines  */
#define DB_0_CLEAR_VALUE   REG_CONTENT(SMP_CPU0_DOORBELL_CLEAR)
#define DB_0_CAUSE_VALUE   REG_CONTENT(SMP_CPU0_DOORBELL)
#define DB_0_MASK_VALUE    REG_CONTENT(SMP_CPU0_DOORBELL_MASK)
#define DB_1_CLEAR_VALUE   REG_CONTENT(SMP_CPU1_DOORBELL_CLEAR)
#define DB_1_CAUSE_VALUE   REG_CONTENT(SMP_CPU1_DOORBELL)
#define DB_1_MASK_VALUE    REG_CONTENT(SMP_CPU1_DOORBELL_MASK)

#define INVALID_CAUSE(cause)    \
                ((cause) <= DB_CAUSE_START || DB_CAUSE_END <= (cause))

#undef DEBUG    /* For debugging */

/* typedefs */


/* locals   */
LOCAL GT_ISR_ENTRY dbCauseArray[8]; /* Interrupt connection data storage    */
LOCAL int  dbCauseCount = 0; 	  /* Accumulates the number of connection */

LOCAL bool frcDbIntCtrlInitialized = false;
LOCAL void frcDbIntHandler(void);      /* Doorbell events handler */

/*******************************************************************************
* frcDbIntCtrlInit - Initiating the Doorbell Interrupt Controller driver.
*
* DESCRIPTION:
*       This routines connects the drivers interrupt handler, to its 
*       corresponding bits in the MV device main Interrupt Controller using the
*       gtIntConnect() routine.
*	It is also cleans and masks interrupts.
*
* INPUT:
*       None.
*
* OUTPUT:
*       The Doorbell cause & mask register are initialised (set to zero).
*       Driver's ISR are connected to the main cause register. 
*
* RETURN:
*       None.
*
*******************************************************************************/
void frcDbIntCtrlInit(void)
{
#ifdef PMC280_DEBUG_UART_VX
    if(frcWhoAmI())
    {
        dbg_puts1("CPU1: Entering frcDbIntCtrlInit\n");
    }
    else
    {
        dbg_puts0("CPU0: Entering frcDbIntCtrlInit\n");
    }
#endif /* PMC280_DEBUG_UART_VX */

    if(frcDbIntCtrlInitialized)
       return;

    if(frcWhoAmI())
    {
        DB_1_CAUSE_VALUE = 0;  /* Clear CPU1 Doorbell Cause register */
        DB_1_CLEAR_VALUE = 0;  /* Clear CPU1 Doorbell Clear register */
    }
    else
    {
        DB_0_CAUSE_VALUE = 0;  /* Clear CPU0 Doorbell Cause register */
        DB_0_CLEAR_VALUE = 0;  /* Clear CPU0 Doorbell Clear register */
    }

    if(frcWhoAmI())
    {
        gtIntConnect(P1_CPU_DB, frcDbIntHandler, 0, 9);
        gtIntEnable(P1_CPU_DB);
    }
    else
    {
        gtIntConnect(P0_CPU_DB, frcDbIntHandler, 0, 9);
        gtIntEnable(P0_CPU_DB);
    }

    frcDbIntCtrlInitialized = true;

#ifdef PMC280_DEBUG_UART_VX
    if(frcWhoAmI())
    {
        dbg_puts1("CPU1: Exiting frcDbIntCtrlInit\n");
    }
    else
    {
        dbg_puts0("CPU0: Exiting frcDbIntCtrlInit\n");
    }
#endif /* PMC280_DEBUG_UART_VX */
}


/*******************************************************************************
* frcDbIntConnect - connect a C routine to a specific Doorbell interrupt.
*
* DESCRIPTION:
*       This routine connects a specified user ISR to a specified Doorbell 
*       interrupt cause.
*       The ISR handler has its own user ISR array. 
*       The connection is done by setting the desired routine and parameter in 
*       the cause array (dbCauseArray[]):
*         1) Check for existing connection for the cause bit in the table.
*         2) Connecting the user ISR by inserting the given parameters into 
*           an entry according to the user ISR given priority.
*
* INPUT:
*       DB_CAUSE cause   - Doorbell interrupt cause. See SDMA_DB. 
*       VOIDFUNCPTR routine  - user ISR.
*       int parameter	 - user ISR parameter.
*       int prio - Interrupt handling priority where 0 is highest.
*
* OUTPUT:
*       A table entry is filled.
*
* RETURN:
*       OK    - if the table entry of the cause bit, was filled. 
*       ERROR - if cause argument is invalid or connected cause is already 
*                found in table.
*
*******************************************************************************/
STATUS frcDbIntConnect(DB_CAUSE cause,
                      VOIDFUNCPTR routine,
                      int parameter,
                      int prio)
{
    int i, sysIntOldConfig;

    /* Make sure that this is an atomic operation */
    sysIntOldConfig = intLock();

    /* Check the validity of the parameters */
    if(routine == NULL)
    {
        logMsg("\nfrcDbIntConnect: NULL pointer routine\n",0,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }
    else if(prio < 0)
    {
        logMsg("\nfrcDbIntConnect: Invalid interrupt priority\n",0,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }
    else if(INVALID_CAUSE(cause))
    {
        logMsg("\nfrcDbIntConnect: Invalid cause %d\n",cause,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }

    /* Scan the table to check for double connection to the same cause bit */
    for(i = dbCauseCount; i >= 0; i--)
        if(dbCauseArray[i].causeBit == SWAP_CAUSE_BIT(cause))
        {
            logMsg("\nfrcDbIntConnect(cause %d): ERROR\nAn attempt to \
                   reconnect ISR to an existing cause bit.\n", cause,0,0,0,0,0); 
            intUnlock(sysIntOldConfig);
            return ERROR;
        }

    /* Connection phase */
    for(i = dbCauseCount; i >= 0; i--)
    {
        if(i == 0 || dbCauseArray[i-1].prio < prio) /* Make connection */
        {
            dbCauseArray[i].causeBit = SWAP_CAUSE_BIT(cause);
            dbCauseArray[i].userISR  = routine;
            dbCauseArray[i].arg      = parameter;
            dbCauseArray[i].prio     = prio;
            dbCauseCount++;
            break;
        }
        else
        {
            /* Push the low priority connection down the table */
            dbCauseArray[i].causeBit = dbCauseArray[i-1].causeBit;
            dbCauseArray[i].userISR  = dbCauseArray[i-1].userISR;
            dbCauseArray[i].arg      = dbCauseArray[i-1].arg;
            dbCauseArray[i].prio     = dbCauseArray[i-1].prio;    
        }
    }

    intUnlock(sysIntOldConfig);
    return OK;
}

/******************************************************************************
* frcDbIntEnable - Enable a Doorbell interrupt
*
* DESCRIPTION:
*       This routine unmasks a specified Doorbell cause in the mask register.
*       The routine will preform argument validity check.
*
* INPUT:
*       DB_CAUSE cause - Doorbell interrupt cause as defined in DB_CAUSE.
*
* OUTPUT:
*       The appropriate bit in the Doorbell mask register is set.
*
* RETURN:
*       OK    - If the bit was set
*       ERROR - if the bit was invalid
*
*******************************************************************************/
STATUS frcDbIntEnable(DB_CAUSE cause)
{
    if (INVALID_CAUSE(cause))
    {
        logMsg("\nfrcDbIntEnable: Invalid cause %d\n", cause,0,0,0,0,0);
        return ERROR;
    }

    /* Set mask bit to enable interrupt */
    if(frcWhoAmI())
    {
        DB_1_MASK_VALUE |= SWAP_CAUSE_BIT(cause);
    }
    else
    {
        DB_0_MASK_VALUE |= SWAP_CAUSE_BIT(cause);
    }

    return OK;
}

/******************************************************************************
* frcDbIntDisable - Disable a Doorbell interrupt
*
* DESCRIPTION:
*       This routine masks a specified Doorbell interrupt in the mask register.
*       The routine will preform argument validity check.
*
* INPUT:
*       DB_CAUSE cause - Doorbell interrupt cause as defined in DB_CAUSE.
*
* OUTPUT:
*       The appropriate bit in the SDMA mask register is reset.
*
* RETURN:
*       OK    - If the bit was reset
*       ERROR - if the bit was invalid
*
*******************************************************************************/
STATUS frcDbIntDisable(DB_CAUSE cause)
{
    if (INVALID_CAUSE(cause))
    {
        logMsg("\nfrcDbIntDisable: Invalid cause %d\n", cause,0,0,0,0,0);
        return ERROR;
    }

    /* Reset mask bit to disable interrupt */
    if(frcWhoAmI())
    {
        DB_1_MASK_VALUE &= ~SWAP_CAUSE_BIT(cause);
    }
    else
    {
        DB_0_MASK_VALUE &= ~SWAP_CAUSE_BIT(cause);
    }

    return OK;
}

/*******************************************************************************
* frcDbIntClear - Clear a Doorbell interrupt
*
* DESCRIPTION:
*       This routine clears a specified Doorbell interrupt in the cause 
*       register. The routine will preform argument validity check. 
*
* INPUT:
*       DB_CAUSE cause - Doorbell interrupt cause as defined in DB_CAUSE.	
*
* OUTPUT:
*       The appropriate bit in the Doorbell Clear register is reset.
*
* RETURN:
*       OK    - If the bit was reset
*       ERROR - if the bit was invalid
*
*******************************************************************************/
STATUS  frcDbIntClear(DB_CAUSE cause)
{
    if (INVALID_CAUSE(cause))
    {
        logMsg("\nfrcDbIntClear: Invalid cause %d\n", cause,0,0,0,0,0);
        return ERROR;
    }
    
    /* Reset mask bit to disable interrupt */
    if(frcWhoAmI())
    {
        DB_1_CLEAR_VALUE |= SWAP_CAUSE_BIT(cause);
    }
    else
    {
        DB_0_CLEAR_VALUE |= SWAP_CAUSE_BIT(cause);
    }
    
    return OK;
}

/*******************************************************************************
* frcDbIntSend - Send a Doorbell interrupt
*
* DESCRIPTION:
*       This routine sends a specified Doorbell interrupt in the cause 
*       register. The routine will preform argument validity check. 
*
* INPUT:
*       DB_CAUSE cause - Doorbell interrupt cause as defined in DB_CAUSE.	
*
* OUTPUT:
*       The appropriate bit in the Doorbell Clear register is set.
*
* RETURN:
*       OK    - If the bit was reset
*       ERROR - if the bit was invalid
*
*******************************************************************************/
STATUS  frcDbIntSend(DB_CAUSE cause)
{
    if (INVALID_CAUSE(cause))
    {
        logMsg("\nfrcDbIntSend: Invalid cause %d\n", cause,0,0,0,0,0);
        return ERROR;
    }
   
    /*
     * Note:
     * If we are sending a doorbell interrupt from CPU0, we need to write to
     * CPU1's Doorbell (cause) register and vice versa if we want to doorbell
     * interrupt CPU0.
     */ 
    if(frcWhoAmI())
    {
        DB_0_CAUSE_VALUE |= SWAP_CAUSE_BIT(cause);
    }
    else
    {
        DB_1_CAUSE_VALUE |= SWAP_CAUSE_BIT(cause);
    }
    
    return OK;
}

/*******************************************************************************
* frcDbIntHandler - Doorbell interrupt handler.
*
* DESCRIPTION:
*       This routine handles the Doorbell interrupts. 
*       As soon as the interrupt signal is active the CPU analyzes the Doorbell 
*       Interrupt Cause register in order to locate the originating 
*       interrupt event. 
*       Then the routine calls the user specified service routine for that 
*       interrupt cause.
*       The function scans the dbCauseArray[] (dbCauseCount valid entries)
*       trying to find a hit in the dbCauseArray cause table.
*       When found, the ISR in the same entry is executed.
*	Note: The handler automatically acknowledges the generating interrupts.
*
* INPUT:
*       None.
*
* OUTPUT:
*       If a cause bit is active and it's connected to an ISR function,
*       the function will be called.
*
* RETURN:
*       None.
*
*******************************************************************************/
void frcDbIntHandler (void)
{
    int     i; 
    unsigned int causeAndMask;
    static unsigned int dbIntCount = 0;
    UINT intNum;

    dbIntCount++;

#ifdef DEBUG
    logMsg("\nvxDbIntHandler: Entering...", 0,0,0,0,0,0);
#endif /* DEBUG */

    /* Cause bit is active if an interrupt occurred and the bit is unmasked. */
    if(frcWhoAmI())
    {
        causeAndMask = DB_1_CAUSE_VALUE & DB_1_MASK_VALUE;
    }
    else
    {
        causeAndMask = DB_0_CAUSE_VALUE & DB_0_MASK_VALUE;
    }

    for(i = 0; i < dbCauseCount; i++)

        if(causeAndMask & dbCauseArray[i].causeBit)
        {
            /* Acknowledge interrupt */
            if(frcWhoAmI())
            {
                DB_1_CLEAR_VALUE |= (dbCauseArray[i].causeBit);
		    intNum = P1_CPU_DB;
            }
            else
            {
                DB_0_CLEAR_VALUE |= (dbCauseArray[i].causeBit);

			intNum = P0_CPU_DB;

            }
			
		#ifdef INCLUDE_WINDVIEW
		WV_EVT_INT_ENT(intNum);  
		#endif 
            /* Perform the ISR */
            (*dbCauseArray[i].userISR) (dbCauseArray[i].arg);
        }                                                            

#ifdef DEBUG
    logMsg("\nvxDbIntHandler: Exiting...", 0,0,0,0,0,0);
#endif /* DEBUG */
    
}
#endif /* PMC280_DUAL_CPU */
