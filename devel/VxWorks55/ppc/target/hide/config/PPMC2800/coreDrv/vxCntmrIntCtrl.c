/******************************************************************************
*              (c), Copyright, MOTOROLA  INC  - ECC                  *
*                                                                             *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MOTOROLA , INC.        *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT *
* OF MOTOROLA  OR ANY THIRD PARTY. MOTOROLA  RESERVES THE RIGHT AT ITS SOLE DISCRETION*
* TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MOTOROLA .       *
* THIS CODE IS PROVIDED "AS IS". MOTOROLA  MAKES NO WARRANTIES, EXPRESS,*
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.  *
*******************************************************************************

*******************************************************************************
* vxCntmrIntCtrl.c - GT Counter/Timer interrurpt controller library
*
* DESCRIPTION:
*       This driver provides various interface routines to manipulate and
*       connect the hardware interrupts concerning the GT Counter/Timer
*       facility.
*
*       Main features:
*        - The controller provides an easy way to hook a C Interrupt Service
*          Routine (ISR) to a specific interrupt caused by the GT Counter/Timer.
*        - The controller interrupt mechanism provides a way for the programmer
*          to set the priority of an interrupt.
*        - Full interrupt control over the GT Counter/Timer facility.
*
*       Overall Interrupt Architecture description:
*        The GT handles interrupts in two stages:
*        STAGE 1: Main Cause register that summarize the interrupts generated
*                 by each Internal GT unit.
*        STAGE 2: Unit specified cause registers, that distinguish between each
*                 specific interrupt event.
*        This Counter/Timer Interrupt Controller Driver handles the various
*        interrupts generated by the second stage.
*
*       All Counter/Timer interrupt causes are numbered using the CNTMR_CAUSE
*       enumerator.
*       There are 32 interrupts causes (most of them are Reserved)
*       The Counter/Timer 0-3 interrupt causes bits 0 - 3
*
*       The driver's execution flow has three phases:
*       1) Driver initialization. This initiation includes hooking driver's ISR
*          to the GT Interrupt controller. Composed of vxCntmrIntCtrlInit().
*       2) User ISR connecting. Here information about user ISR and interrupt
*          priority is gathered. Composed of vxCntmrIntConnect() routine.
*       3) Interrupt handler. Here an interrupt is being handle by the Interrupt
*          Handlers (driver's ISR).
*          Interrupt acknowledge is also done in this stage.
*
*       Full API:
*         vxCntmrIntCtrlInit()- Initiate the Counter/Timer driver.
*         vxCntmrIntConnect() - Connect a user ISR to a Counter/Timer interrupt
*                               event.
*         vxCntmrIntEnable()  - Enable a given Counter/Timer interrupt cause.
*         vxCntmrIntDisable() - Disable a given Counter/Timer interrupt cause.
*         vxCntmrIntHandler() - Handle Counter/Timer 0-3 interrupts.
*
*       The controller concept is very simple:
*        The Interrupt handlers has a small table which holds
*        information on the connected ISR. For example, vxCntmrIntHandler() has
*        cntmrIntArray[] which holds the ISR concerning Counter/Timers 0 - 3
*        An Interrupt generated by one of those Counter/Timers will
*        result a search through this table in order to allocate the generating
*        interrupt cause. After the initiating interrupt cause is identify,
*        the ISR reside in the same table entry is executed.
*
*       The controller interface also includes interrupt control routines which
*       can enable/disable specific interrupts:
*       vxCntmrIntEnable() and vxCntmrIntDisable().
*
* DEPENDENCIES:
*       GT Interrupt Control Driver.
*	VxWorks types and interrupt lib.
*
******************************************************************************/

/* includes */
#include "vxCntmrIntCtrl.h"
#ifdef PMC280_DUAL_CPU
#include "gtSmp.h"
#endif /* PMC280_DUAL_CPU */

#include "config.h"

#ifdef INCLUDE_WINDVIEW
#include "private/funcBindP.h"
#include "private/eventP.h"
#include "wvLib.h"
#endif  /* INCLUDE_WINDVIEW */

/* defines  */
#define CNTMR_CAUSE_REG     REG_CONTENT(TIMER_COUNTER_0_3_INTERRUPT_CAUSE)
#define CNTMR_MASK_REG      REG_CONTENT(TIMER_COUNTER_0_3_INTERRUPT_MASK)

#define VALID_COUNTER(cause)  (CNTMR0_EXP <= (cause) && (cause) <= CNTMR3_EXP)
#define INVALID_CAUSE(cause)    \
                    ((cause) <= CNTMR_CAUSE_START || CNTMR_CAUSE_END <= (cause))


/* typedefs */
#define TIMER_CAUSE_TC0 (0x1 << 0)
#define TIMER_CAUSE_TC1 (0x1 << 1)
#define TIMER_CAUSE_TC2 (0x1 << 2)
#define TIMER_CAUSE_TC3 (0x1 << 3)




/* locals   */

/* GT_ISR_ENTRY array accumulates user ISR information for each cntmr group. */
LOCAL GT_ISR_ENTRY cntmrIntArray[5];

/* Each counter accumulate the number of connection done to a cause array. For*/
/* example cntmrCount counts the number of connection done to cntmrIntArray   */
LOCAL int cntmrCount = 0;

LOCAL bool vxCntmrIntCtrlInitialized = false;

/* Interrupt Controller's ISR */
LOCAL void  vxCntmrIntHandler (void);

LOCAL UINT frcGetIntNumForTmrArray(UINT uwCausebit);

/*******************************************************************************
* vxCntmrIntCtrlInit - Initiating the Counter/Timer driver.
*
* DESCRIPTION:
*       This routines connects the drivers interrupt handlers, each to its
*       corresponding bit in the GT main Interrupt Controller using the
*       gtIntConnect() routine.
*
* INPUT:
*       None.
*
* OUTPUT:
*       The Counter/Timer casue & mask register are initiated (set to zero).
*       Driver's ISR is connected to the main cause register.
*       interrupts are unmasked.
*
* RETURN:
*       None.
*
*******************************************************************************/
void vxCntmrIntCtrlInit(void)
{
#ifdef PMC280_DUAL_CPU
    /*
     * The "Timer/Counter" resource is partitioned with Timer0 and Timer1
     * given to CPU0 and Timer2 and Timer3 given to CPU1. The code below
     * assumes that timers on CPU0 are initialised before those on CPU1. In
     * other words, CPU0 has the responsibility of clearing a few registers
     * although it is not half of the timers.
     */
    if(frcWhoAmI())
    {
        if(vxCntmrIntCtrlInitialized)
            return;

        gtIntConnect(TIMER2, vxCntmrIntHandler, 0, 9);
        gtIntConnect(TIMER3, vxCntmrIntHandler, 0, 9);

        gtIntEnable(TIMER2);
        gtIntEnable(TIMER3);
    }
    else
    {
        if(vxCntmrIntCtrlInitialized)
            return;

        CNTMR_CAUSE_REG = 0; /* Clean Cause register (case of warm reboot) */
        CNTMR_MASK_REG  = 0; /* Clean Mask register (case of warm reboot)  */

        /*
         * Connect a user ISR to the Counter/Timer bits in the main
         * cause register
         */
        gtIntConnect(TIMER0, vxCntmrIntHandler, 0, 9);
        gtIntConnect(TIMER1, vxCntmrIntHandler, 0, 9);

        /* Unmask those bits */
        gtIntEnable(TIMER0);
        gtIntEnable(TIMER1);
    }
#else
    if(vxCntmrIntCtrlInitialized)
        return;

    CNTMR_CAUSE_REG = 0; /* Clean Cause register (case of warm reboot) */
    CNTMR_MASK_REG  = 0; /* Clean Mask register (case of warm reboot)  */

    /* Connect a userISR to the Counter/Timer bits in the main cause register */
    gtIntConnect(TIMER0, vxCntmrIntHandler, 0, 9);
    gtIntConnect(TIMER1, vxCntmrIntHandler, 0, 9);
    gtIntConnect(TIMER2, vxCntmrIntHandler, 0, 9);
    gtIntConnect(TIMER3, vxCntmrIntHandler, 0, 9);

    /* Unmask those bits */
    gtIntEnable(TIMER0);
    gtIntEnable(TIMER1);
    gtIntEnable(TIMER2);
    gtIntEnable(TIMER3);
#endif /* PMC280_DUAL_CPU */

    vxCntmrIntCtrlInitialized = true;
}


/*******************************************************************************
* vxCntmrIntConnect - connect a C routine to a specific Counter/Timer interrupt.
*
* DESCRIPTION:
*       This routine connects a specified user ISR to a specified GT
*       Counter/Timer interrupt cause.
*       Each ISR handler has its own user ISR array.
*       The connection is done by setting the desired routine and parameter in
*       the corresponding cause array (i.e. cntmrIntArray[]):
*        1) Finding the origin register of the cause bit Counter/Timer 0-3 or
*        2) Check for existing connection for the cause bit in the table.
*        3) Connecting the user ISR by inserting the given parameters into an
*           entry according to the user ISR given priority.
*
* INPUT:
*       cause     - Timer/Counter interrupt cause. See CNTMR_INT_CAUSE.
*       routine   - user ISR.
*       parameter - user ISR parameter.
*       prio      - Interrupt handling priority where 0 is highest.
*
* OUTPUT:
*       An appropriate table entry is filled.
*
* RETURN:
*       OK    - if the table entry of the cause bit, was filled.
*       ERROR - if cause argument is invalid or connected cause is already
*                found in table.
*
*******************************************************************************/
STATUS vxCntmrIntConnect(CNTMR_CAUSE cause, VOIDFUNCPTR routine, int parameter,
                         int prio)
{
    GT_ISR_ENTRY *intCauseArray;/*Pointer to the selected cause table    */
    int *intConnectCount;       /*Pointer to the table connection counter*/
    int i, sysIntOldConfig;

    /* Make sure that this is an atomic operation */
    sysIntOldConfig = intLock();

    /* Check the validity of the parameters */
    if(routine == NULL)
    {
        logMsg("\nvxCntmrIntConnect: NULL pointer routine\n",0,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }
    else if(prio < 0)
    {
        logMsg("\nvxCntmrIntConnect: Invalid interrupt priority\n",0,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }
    else if(VALID_COUNTER(cause) || cause == CNTMR_SUM)
    {
        intCauseArray   = cntmrIntArray;
        intConnectCount = &cntmrCount;
    }
    else
    {
        logMsg("\nvxCntmrIntConnect: Invalid cause %d\n",cause,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }


    /* Scan the table to check for double connection to the same cause bit */
    for(i=*intConnectCount; i>=0; i--)
        if(intCauseArray[i].causeBit == SWAP_CAUSE_BIT(cause))
        {
            logMsg("\nvxCntmrIntConnect(cause %d): ERROR\n",cause,0,0,0,0,0);
            logMsg("   An attempt to reconnect ISR to an existing cause bit.\n",
                   0,0,0,0,0,0);
            intUnlock(sysIntOldConfig);
            return ERROR;
        }

    /* Connection phase */
    /* The search starts from the bottom of the table, because:     */
    /*  1) if the priority is the highest, we can put it straight   */
    /*     in the end of the table                                  */
    /*  2) we can push the highests priority down the table,right   */
    /*     away, with out the need to copy the struct.              */

    for(i = *intConnectCount; i >= 0; i--)
    {
        if(i == 0 || intCauseArray[i-1].prio < prio) /* Make connection */
        {
            intCauseArray[i].causeBit = SWAP_CAUSE_BIT(cause);
            intCauseArray[i].userISR  = routine;
            intCauseArray[i].arg      = parameter;
            intCauseArray[i].prio     = prio;
            (*intConnectCount)++;
            break;
        }
        else
        {
            /* Push the low priority connection down the table */
            intCauseArray[i].causeBit = intCauseArray[i-1].causeBit;
            intCauseArray[i].userISR  = intCauseArray[i-1].userISR;
            intCauseArray[i].arg      = intCauseArray[i-1].arg;
            intCauseArray[i].prio     = intCauseArray[i-1].prio;
        }
    }
    intUnlock(sysIntOldConfig);
    return OK;
}

/*******************************************************************************
* vxCntmrIntEnable - Enable a Counter/Timer interrupt
*
* DESCRIPTION:
*       This routine unmasks a specified GT Counter/Timer interrupt cause
*       on the appropriate mask register.
*       The routine will preform argument validity check.
*
* INPUT:
*       cause - Counter/Timer cause as defined in CNTMR_INT_CAUSE.
*
* OUTPUT:
*       The appropriate bit in the appropriate mask register is set.
*
* RETURN:
*       OK    - If the bit was unmasked
*       ERROR - if the bit was invalid
*
*******************************************************************************/
STATUS vxCntmrIntEnable(CNTMR_CAUSE cause)
{
    volatile UINT32 *maskReg; /* The issued mask register */

#ifdef PMC280_DUAL_CPU
    /* Lock */
    frcMv64360semTake(CNTMR_SEM, MV64360_SMP_WAIT_FOREVER);

    if(VALID_COUNTER(cause))
    {
        GT_INT_CAUSE gtCause;
        gtCause = (cause | 0x8); /* to enable TIMER0-3 in main cause */
        gtIntEnable(gtCause);
    }
    else if(CNTMR_SUM != cause)
    {
        logMsg("\nvxCntmrIntEnable: Invalid cause %d\n", cause,0,0,0,0,0);
        return ERROR;
    }

    maskReg = &CNTMR_MASK_REG;
    *maskReg |= SWAP_CAUSE_BIT(cause);

    /* Unlock */
    frcMv64360semGive(CNTMR_SEM);
#else
    if(VALID_COUNTER(cause))
    {
        GT_INT_CAUSE gtCause;
        gtCause = (cause | 0x8); /* to enable TIMER0-3 in main cause */
        gtIntEnable(gtCause);
    }
    else if(CNTMR_SUM != cause)
    {
        logMsg("\nvxCntmrIntEnable: Invalid cause %d\n", cause,0,0,0,0,0);
        return ERROR;
    }

    maskReg = &CNTMR_MASK_REG;

    *maskReg |= SWAP_CAUSE_BIT(cause);
#endif /* PMC280_DUAL_CPU */

    return OK;
}

/*******************************************************************************
* vxCntmrIntDisable - Disable a Counter/Timer interrupt
*
* DESCRIPTION:
*       This routine masks a specified GT Counter/Timer interrupt cause
*       on the appropriate mask register.
*       The routine will preform argument validity check.
*
* INPUT:
*       cause - Counter/Timer cause as defined in CNTMR_INT_CAUSE.
*
* OUTPUT:
*       The appropriate bit in the appropriate mask register is reset.
*
* RETURN:
*       OK    - If the bit was masked
*       ERROR - if the bit was invalid
*
*******************************************************************************/
STATUS vxCntmrIntDisable(CNTMR_CAUSE cause)
{
    volatile UINT32 *maskReg;  /* The issued mask register */

#ifdef PMC280_DUAL_CPU
    /* Lock */
    frcMv64360semTake(CNTMR_SEM, MV64360_SMP_WAIT_FOREVER);

    if(VALID_COUNTER(cause))
    {
        GT_INT_CAUSE gtCause;
        gtCause = (cause | 0x8); /* to disable TIMER0-3 in main cause */
        gtIntDisable(gtCause);
    }
    else if(CNTMR_SUM != cause)
    {
        logMsg("\nvxCntmrIntDisable: Invalid cause %d\n", cause,0,0,0,0,0);
        return ERROR;
    }

    maskReg = &CNTMR_MASK_REG;
    *maskReg &= ~(SWAP_CAUSE_BIT(cause));

    /* Unlock */
    frcMv64360semGive(CNTMR_SEM);
#else
    if(VALID_COUNTER(cause))
    {
        GT_INT_CAUSE gtCause;
        gtCause = (cause | 0x8); /* to disable TIMER0-3 in main cause */
        gtIntDisable(gtCause);
    }
    else if(CNTMR_SUM != cause)
    {
        logMsg("\nvxCntmrIntDisable: Invalid cause %d\n", cause,0,0,0,0,0);
        return ERROR;
    }

    maskReg = &CNTMR_MASK_REG;

    *maskReg &= ~(SWAP_CAUSE_BIT(cause));
#endif /* PMC280_DUAL_CPU */

    return OK;
}

/*******************************************************************************
* vxCntmrIntHandler - Counter/Timer 0-3 Interrupt controller routine.
*
* DESCRIPTION:
*       This routine handles the Counter/Timer 0-3 interrupts.
*       As soon as the interrupt signal is active the CPU analyzes the GT
*       Counter/Timer 0-3 Interrupt Cause register in order to locate the
*       originating interrupt event.
*       Then the routine calls the user specified service routine for that
*       interrupt cause.
*       The function scans the cntmrIntArray[] (cntmrCount valid entries)
*       trying to find a hit in the cntmrIntArray cause table.
*       When found, the ISR in the same entry is executed.
*
* INPUT:
*       None.
*
* OUTPUT:
*       If a cause bit is active and it's connected to an ISR function,
*       the function will be called.
*
* RETURN:
*       None.
*
*******************************************************************************/
void vxCntmrIntHandler (void)
{
    int     i;
    unsigned int causeAndMask;  /* Prevents the GT access each iteration */
UINT intNum;


#ifdef PMC280_DUAL_CPU
    /* Lock */
    frcMv64360semTake(CNTMR_SEM, MV64360_SMP_WAIT_FOREVER);

    /* cause bit is active if an interrupt occured and the bit is unmasked. */
    causeAndMask = CNTMR_CAUSE_REG & CNTMR_MASK_REG;

    for(i = 0; i < cntmrCount; i++)

        if(causeAndMask & cntmrIntArray[i].causeBit)
        {

		     intNum = frcGetIntNumForTmrArray(cntmrIntArray[i].causeBit);
	#ifdef INCLUDE_WINDVIEW
	 WV_EVT_INT_ENT(intNum);
	#endif

            /* Perform the ISR */
            (*cntmrIntArray[i].userISR) (cntmrIntArray[i].arg);

            /* Reset the interrutp cause bit in the Timer/Counter cause */
            /* register                                                 */
            CNTMR_CAUSE_REG = ~(cntmrIntArray[i].causeBit);
        }

    /* Unlock */
    frcMv64360semGive(CNTMR_SEM);
#else
    /* cause bit is active if an interrupt occured and the bit is unmasked. */
    causeAndMask = CNTMR_CAUSE_REG & CNTMR_MASK_REG;

    for(i = 0; i < cntmrCount; i++)

        if(causeAndMask & cntmrIntArray[i].causeBit)
        {
		intNum = frcGetIntNumForTmrArray(cntmrIntArray[i].causeBit);
	#ifdef INCLUDE_WINDVIEW
	 WV_EVT_INT_ENT(intNum);
	#endif


            /* Perform the ISR */
            (*cntmrIntArray[i].userISR) (cntmrIntArray[i].arg);

            /* Reset the interrutp cause bit in the Timer/Counter cause */
            /* register                                                 */
            CNTMR_CAUSE_REG = ~(cntmrIntArray[i].causeBit);
        }
#endif /* PMC280_DUAL_CPU */
}

/*******************************************************************************
* frcGetIntNumForTmrArray
*
* DESCRIPTION:
*       This routine taked the cause register value and correspondingly
*       give the intNum
*
* INPUT:
*       Cause Register value
*
* OUTPUT:
*       Interrupt Number
*
*
* RETURN:
*       None.
*
*******************************************************************************/
UINT frcGetIntNumForTmrArray(UINT uwCausebit)
{

	UINT intNum;

	switch(uwCausebit)
	{
		case TIMER_CAUSE_TC0:
			intNum = TIMER0;
		break;

		case TIMER_CAUSE_TC1:
			intNum = TIMER1;
		break;

		case TIMER_CAUSE_TC2:
	   		intNum = TIMER2;
		break;

		case TIMER_CAUSE_TC3:
       			intNum = TIMER3;
		break;

		default:
			intNum = TIMER0;
		break;

	}   /* end of switch statement */

	return (intNum);

}  /* end of frcGetIntNumForTmrArray */

