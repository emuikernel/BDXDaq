/******************************************************************************
*              (c), Copyright, MOTOROLA  INC - ECC                  *
*                                                                             *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MOTOROLA , INC.        *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT *
* OF MOTOROLA  OR ANY THIRD PARTY. MOTOROLA  RESERVES THE RIGHT AT ITS SOLE DISCRETION*
* TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MOTOROLA .       *
* THIS CODE IS PROVIDED "AS IS". MOTOROLA  MAKES NO WARRANTIES, EXPRESS,*
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.  *
*******************************************************************************

*******************************************************************************
* vxGppIntCtrl.c - GPP Interrupt controller library
*
* DESCRIPTION:
*       This driver provides various interface routines to manipulate and
*       connect the hardware interrupts described by the GPP facility 
*       (i.e. PCI, UART, etc.). 
*       Once a GPP pin is configued as input pin active low, it behaves as an
*       interrupt pin. When asserted, the interrupt reflects in the GPP cause
*       register generating interrupt event if not masked.  
*
*       For example the RS232 channel A interrupt is connected to GPP pin 21
*       which means that when this pin is activate (low value) the GPP cause
*       register bit 21 will be set to signal an interrupt from this UART chnl.
*
*       Main features:
*       - The controller provides an easy way to hook a C Interrupt Service
*         Routine (ISR) to a specific interrupt caused by the GT GPP interrupt.    
*       - This controller automatically acknowledges the interrupt as soon as 
*         the user C Interrupt service Routine returns.
*       - The controller interrupt mechanism provides a way for the programmer
*         to set the priority of an interrupt.
*       - Full interrupt control over the GT GPP facility.
*
*       Overall Interrupt Architecture description:
*       The GT handles interrupts in two stages:
*       STAGE 1: Main Cause register that summarize the interrupts generated by
*		         each Internal GT unit.
*       STAGE 2: Unit specified cause registers, that distinguish between each
*                specific interrupt event.
*       This System Interrupt Controller Driver handles the various interrupts 
*       generated by the GPP interrupt cause register.
*
*       The driver's execution flow has three phases:
*        1) Driver initialization.
*           This initiation includes hooking driver's ISR to 
*           the GT Interrupt controller. Composed of frcGppIntCtrlInit() routine.
*        2) User ISR connecting. Here information about system ISR and 
*           interrupt priority is gathered. Composed of frcGppIntConnect() 
*           routine.
*        3) Interrupt handler. Here an interrupt is being handle by the
*           Interrupt Handlers (driver's ISR). Composed of gpp7_0Int(), 
*           gpp15_8Int(), gpp23_16Int(), gpp31_24Int(). 
*
*       Full API:
*        frcGppIntCtrlInit() - Initiate the GPP Interrupt Controller driver.
*        frcGppIntConnect()  - Connect the system ISR to a GPP interrupt event.
*        frcGppIntEnable()   - Enable a given GPP interrupt cause.
*        frcGppIntDisable()  - Disable a given GPP interrupt cause.
*        gpp7_0Int() 	    - Handle GPP  7- 0 interrupts.
*        gpp15_8Int() 	    - Handle GPP 15- 8 interrupts.
*        gpp23_16Int() 	    - Handle GPP 23-16 interrupts.
*        gpp31_24Int() 	    - Handle GPP 31-24 interrupts.
*
*
*       The controller concept is very simple:
*        Each of the Interrupt handlers has a small table which holds 
*        information on the connected ISR. For example, gpp23_16Int() has 
*        gpp23_16Array[] which holds the ISR concerning RS232 channel A and 
*        RS232 channel B. 
*        An Interrupt generated by one of those pins will result a search 
*        through this table in order to locate the generating interrupt cause. 
*        After the initiating interrupt cause is identify, the ISR reside in 
*        the same table entry is executed. 
*        Before the ISR executes the interrupt is acknowledged.
*
*       The controller interface also includes interrupt control routines 
*       which can enable/disable specific interrupts: frcGppIntDisable() and 
*       frcGppIntEnable().
*
* DEPENDENCIES:
*       GT Interrupt Control Driver.
*		VxWorks types and interrupt lib.
*
******************************************************************************/

/* includes */
#include "vxGppIntCtrl.h" 

#ifdef PMC280_DUAL_CPU
#include "gtSmp.h"
#endif /* PMC280_DUAL_CPU */

#include "config.h"

#ifdef INCLUDE_WINDVIEW
#include "private/funcBindP.h"
#include "private/eventP.h"
#include "wvLib.h"
#endif  /* INCLUDE_WINDVIEW */

/* defines  */
#define GPP_CAUSE_REG           REG_CONTENT(GPP_INTERRUPT_CAUSE)  
#define GPP_MASK0_REG          REG_CONTENT(GPP_INTERRUPT_MASK)  
#define GPP_MASK1_REG           REG_CONTENT(GPP_INTERRUPT_MASK1)  

#define INVALID_CAUSE(cause)    ((cause) < 0 || 31 < (cause))
/* typedefs */


/* locals   */
/* GT_ISR_ENTRY array accumulates ISR information for each GPP group. */
LOCAL GT_ISR_ENTRY gpp23_16Array[8];
LOCAL GT_ISR_ENTRY gpp31_24Array[8];
LOCAL GT_ISR_ENTRY gpp7_0Array[8];
LOCAL GT_ISR_ENTRY gpp15_8Array[8];

/*Each counter accumulate the number of connection done to a cause array. */
LOCAL int gpp23_16Count = 0;   
LOCAL int gpp31_24Count = 0;
LOCAL int gpp7_0Count = 0;
LOCAL int gpp15_8Count = 0;

LOCAL bool vxGppIntCtrlInitialized = false;

/* Interrupt Controller's ISR */
LOCAL void  gpp23_16Int (void);
LOCAL void  gpp31_24Int (void);
LOCAL void  gpp7_0Int (void);
LOCAL void  gpp15_8Int (void);

#if 0
LOCAL void  gpp23_16Int1 (void);
LOCAL void  gpp31_24Int1 (void);
LOCAL void  gpp7_0Int1 (void);
LOCAL void  gpp15_8Int1 (void);
#endif


/*******************************************************************************
* frcGppIntCtrlInit - Initiating the GPP Interrupt Controller driver.
*
* DESCRIPTION:
*       This routines connects the drivers interrupt handlers, each to its 
*       corresponding bit in the GT Interrupt Controller using the 
*		gtIntConnect() routine. GPP pins 0-23 does not contains any interrupt 
*		pins, thus routines gpp7_0Int() and gpp15_8Int() are not connected. 
*		They are for future use.
*
* INPUT:
*       None.
*
* OUTPUT:
*       Driver's ISR are connected to the CPU's Interrupt vector and 
*       interrupts are unmasked.
*
* RETURN:
*       None.
*
*******************************************************************************/
void frcGppIntCtrlInit(void)
{
#ifdef PMC280_DUAL_CPU
    if(!frcWhoAmI())
    {
        if(vxGppIntCtrlInitialized)
            return;

        GPP_CAUSE_REG = 0; /* Clean cause register (case of Warm boot) */
        GPP_MASK_REG(0) = 0; /* Clean mask register (case of Warm boot) */
        
        gtIntConnect(P0_GPP_23_16, gpp23_16Int, 0, 9);      
        gtIntConnect(P0_GPP_31_24, gpp31_24Int, 0, 9);
        gtIntConnect(P0_GPP_15_8,  gpp15_8Int,  0, 9);
        gtIntConnect(P0_GPP_7_0 ,  gpp7_0Int ,  0, 9);        

        gtIntEnable(P0_GPP_23_16);
        gtIntEnable(P0_GPP_31_24);
        gtIntEnable(P0_GPP_15_8);
        gtIntEnable(P0_GPP_7_0);
    }
   else
    {
         if(vxGppIntCtrlInitialized)
            return;

        GPP_CAUSE_REG = 0; /* Clean cause register (case of Warm boot) */       
        GPP_MASK_REG(1) = 0; /* Clean mask register (case of Warm boot) */

        gtIntConnect(P1_GPP_23_16, gpp23_16Int, 0, 9);      
        gtIntConnect(P1_GPP_31_24, gpp31_24Int, 0, 9);
        gtIntConnect(P1_GPP_15_8,  gpp15_8Int,  0, 9);
        gtIntConnect(P1_GPP_7_0 ,  gpp7_0Int ,  0, 9);        

       
    } 
#else
    if(vxGppIntCtrlInitialized)
        return;

    GPP_CAUSE_REG = 0; /* Clean cause register (case of Warm boot) */

    GPP_MASK_REG(0) = 0;
    GPP_MASK_REG(1) = 0;

    gtIntConnect(P0_GPP_23_16, gpp23_16Int, 0, 9);      
    gtIntConnect(P0_GPP_31_24, gpp31_24Int, 0, 9);
    gtIntConnect(P0_GPP_15_8,  gpp15_8Int,  0, 9);
    gtIntConnect(P0_GPP_7_0 ,  gpp7_0Int ,  0, 9);              

    gtIntEnable(P0_GPP_23_16);
    gtIntEnable(P0_GPP_31_24);
    gtIntEnable(P0_GPP_15_8);
    gtIntEnable(P0_GPP_7_0);
#endif /* PMC280_DUAL_CPU */

    vxGppIntCtrlInitialized = true;
}

/*******************************************************************************
* frcGppIntConnect - connect a C routine to a specific GPP interrupt.
*
* DESCRIPTION:
*       This routine connects a specified ISR to a specified GPP interrupt 
*       cause. Each ISR handler has its own user ISR array. The connection 
*       is done by setting the desired routine and parameter in the 
*		corresponding cause array (i.e. gpp23_16Array[]):
*       1) Check for existing connection for the same cause bit in the table.
*       2) Connecting the user ISR by inserting the given parameters into an
*          entry according to the user ISR given priority.
*
* INPUT:
*       cause     - GPP interrupt cause (0-31).
*       routine   - user ISR.
*       parameter - user ISR parameter.
*       prio      - Interrupt handling priority where 0 is highest.    
*
* OUTPUT:
*       An appropriate table entry is filled.
*
* RETURN:
*       OK    if succeeded 
*       ERROR if cause argument is wrong or connected cause is already 
*             found in table.
*
*******************************************************************************/
STATUS frcGppIntConnect(GPP_CAUSE cause, VOIDFUNCPTR routine, int parameter, int prio)
{
    GT_ISR_ENTRY *intCauseArray; /* Pointer to the selected cause table */
    int *intConnectCount;       /* Pointer to the table connection counter*/
    int i, sysIntOldConfig;

    sysIntOldConfig = intLock();

    /* Check for cause parameter validity */
    if(routine == NULL)
    {
        logMsg("\nfrcGppIntConnect: NULL pointer routine\n",0,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }
    else if(prio < 0)
    {
        logMsg("\nfrcGppIntConnect: Invalid interrupt priority\n",0,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }
    else if(INVALID_CAUSE(cause))
    {
        logMsg("\nfrcGppIntConnect: Invalid cause %d (0-31)\n", cause,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }
    else if(16 <= cause && cause <= 23)
    {
        intCauseArray   = gpp23_16Array;
        intConnectCount = &gpp23_16Count;
    }
    else if(24 <= cause && cause <= 31)
    {
        intCauseArray   = gpp31_24Array;
        intConnectCount = &gpp31_24Count;
    }
    else if(8 <= cause && cause <= 15)
    {
        intCauseArray   = gpp15_8Array;
        intConnectCount = &gpp15_8Count;
    }
    else if(0 <= cause && cause <= 7)
    {
         intCauseArray  = gpp7_0Array;
         intConnectCount = &gpp7_0Count;
    }
    else
    { /* undefined interrupt cause */
        logMsg("\nfrcGppIntConnect: undefined cause %d\n", cause,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }

    /* Scan the table to check for double connection to the same cause bit */
    for(i=*intConnectCount; i>=0; i--)
    {
        if(intCauseArray[i].causeBit == SWAP_CAUSE_BIT(cause))
        {
            logMsg("\nfrcGppIntConnect(cause %d): ERROR\n",cause,0,0,0,0,0);
            logMsg("   An attempt to reconnect ISR to an existing cause bit.\n",
                   0,0,0,0,0,0); 
            intUnlock(sysIntOldConfig);
            return ERROR;
        }
    }

        /* Connection phase */
    for(i=*intConnectCount; i>=0; i--)
    {
        if(i==0 || intCauseArray[i-1].prio < prio) /* Make connection */
        {
            intCauseArray[i].causeBit = SWAP_CAUSE_BIT(cause);
            intCauseArray[i].userISR  = routine;
            intCauseArray[i].arg      = parameter;
            intCauseArray[i].prio     = prio;
            (*intConnectCount)++;
            break;
        }
        else
        {
            /* Push the low priority connection down the table */
            intCauseArray[i].causeBit = intCauseArray[i-1].causeBit;
            intCauseArray[i].userISR  = intCauseArray[i-1].userISR;
            intCauseArray[i].arg      = intCauseArray[i-1].arg;
            intCauseArray[i].prio     = intCauseArray[i-1].prio;












        }


    }
    intUnlock(sysIntOldConfig);
    return OK;
}
/*******************************************************************************
* frcGppIntEnable - Enable a GPP interrupt
*
* DESCRIPTION:
*       This routine makes a specified GT GPP interrupt cause available to 
*		the CPU.
*
* INPUT:
*       cause - GPP interrupt cause (0-31).
*
* OUTPUT:
*       The appropriate bit in GPP mask register is reset.
*
* RETURN:
*       OK.
*
* SEE ALSO:
*       frcGppIntDisable()
*
*******************************************************************************/
STATUS frcGppIntEnable(GPP_CAUSE cause)
{
 int cpu=0;

#ifdef PMC280_DUAL_CPU
   if(frcWhoAmI())
      cpu=1;
   else
      cpu=0;
#endif /* PMC280_DUAL_CPU */ 

   if (INVALID_CAUSE(cause))
    {
        logMsg("\nfrcGppIntEnable: Invalid cause %d (0-31)\n", cause,0,0,0,0,0);
        return ERROR;
    }

    GPP_MASK_REG(cpu) |= SWAP_CAUSE_BIT(cause);
    return OK;
}

/*******************************************************************************
* frcGppIntDisable - Disable a GPP interrupt
*
* DESCRIPTION:
*       This routine makes a specified GT GPP interrupt cause unavailable to
*       the CPU.
*
* INPUT:
*       cause - GPP interrupt cause (0-31).
*
* OUTPUT:
*       The appropriate bit in GPP mask register is reset.
*
* RETURN:
*       OK.
*
* SEE ALSO:
*       frcGppIntEnable()
*
*******************************************************************************/
STATUS frcGppIntDisable(GPP_CAUSE cause)
{
  int cpu=0;

#ifdef PMC280_DUAL_CPU
   if(frcWhoAmI())
      cpu=1;
   else
      cpu=0;
#endif /* PMC280_DUAL_CPU */
 
   
    if (INVALID_CAUSE(cause))
    {
        logMsg("\nfrcGppIntDisable: Invalid cause %d (0-31)\n", cause,0,0,0,0,0);
        return ERROR;
    }
	
    GPP_MASK_REG(cpu) &= ~SWAP_CAUSE_BIT(cause);
    return OK;
}
/*******************************************************************************
* frcGppCPU1IntEnable - Enable a GPP interrupt
*
* DESCRIPTION:
*       This routine makes a specified GT GPP interrupt cause available to 
*		the CPU.
*
* INPUT:
*       cause - GPP interrupt cause (0-31).
*
* OUTPUT:
*       The appropriate bit in GPP mask register is reset.
*
* RETURN:
*       OK.
*
* SEE ALSO:
*       frcGppCPU1IntDisable()
*
*******************************************************************************/
STATUS frcGppCPU1IntEnable(GPP_CAUSE cause)
{
    if (INVALID_CAUSE(cause))
    {
        logMsg("\nfrcGppCPU1IntEnable: Invalid cause %d (0-31)\n", cause,0,0,0,0,0);
        return ERROR;
    }

    GPP_MASK1_REG |= SWAP_CAUSE_BIT(cause);
    return OK;
}

/*******************************************************************************
* frcGppCPU1IntDisable - Disable a GPP interrupt
*
* DESCRIPTION:
*       This routine makes a specified GT GPP interrupt cause unavailable to
*       the CPU.
*
* INPUT:
*       cause - GPP interrupt cause (0-31).
*
* OUTPUT:
*       The appropriate bit in GPP mask register is reset.
*
* RETURN:
*       OK.
*
* SEE ALSO:
*       frcGppIntEnable()
*
*******************************************************************************/
STATUS frcGppCPU1IntDisable(GPP_CAUSE cause)
{
    if (INVALID_CAUSE(cause))
    {
        logMsg("\nfrcGppCPU1IntDisable: Invalid cause %d (0-31)\n", cause,0,0,0,0,0);
        return ERROR;
    }
	
    GPP_MASK1_REG &= ~SWAP_CAUSE_BIT(cause);
    return OK;
}

/*******************************************************************************
* gpp23_16Int - GPP pins 23-16 Interrupt controller routine.
*
* DESCRIPTION:
*      This routine handles the GPP pins 23-16 interrupts. 
*      As soon as the interrupt signal is active the CPU analyzes the GT GPP 
*      Interrupt Cause register in order to locate the originating interrupt 
*      event. Then the routine calls the user specified service routine for that 
*      interrupt cause. The GPP interrupt is edge triggered thus the user ISR is 
*      performed as long as the GPP bit value is active.
*      The function scans the gpp23_16Array[] (gpp23_16Count valid entries)
*      trying to find a hit in the gpp23_16Array cause table.
*      When found, the ISR in the same entry is executed.
*      Before ISR execution, the handler acknowledges the initiating interrupt. 
*
* INPUT:
*       None.
*
* OUTPUT:
*       See description.
*
* RETURN:
*       None.
*
*******************************************************************************/
void gpp23_16Int(void)
{
    int     i,key,cpu=0;          /* i iterates over the registrated gpp23_16Array[] */
    unsigned int gppActiveInt;

#ifdef INCLUDE_WINDVIEW
    UINT intNum = P0_GPP_23_16;
#endif

#ifdef PMC280_DUAL_CPU
   if(frcWhoAmI())
   {	   
      cpu=1;
      intNum = P1_GPP_23_16;
   }   
   else
   {	   
      cpu=0;
      intNum = P0_GPP_23_16;
   }   
#endif /* PMC280_DUAL_CPU */

#ifdef INCLUDE_WINDVIEW
	WV_EVT_INT_ENT(intNum);  /* to support for Wind View */
#endif 
 
    key = intLock();    
    gppActiveInt = GPP_CAUSE_REG & GPP_MASK_REG(cpu);
	
	for(i=0; i<gpp23_16Count; i++)
    {
        /* Check ISR array hit  */
        if(gppActiveInt & gpp23_16Array[i].causeBit)
        { 
            /* Reset the interrupt cause bit in the GPP cause register */
            GPP_CAUSE_REG = ~(gpp23_16Array[i].causeBit); 

            /* Perform the ISR */
            (*gpp23_16Array[i].userISR) (gpp23_16Array[i].arg);
        } 
    }
   intUnlock(key);
}

/*******************************************************************************
* gpp31_24Int - GPP pins 31-24 Interrupt controller routine.
*
* DESCRIPTION:
*      This routine handles the GPP pins 31-24 interrupts.                          
*      As soon as the interrupt signal is active the CPU analyzes the GT GPP        
*      Interrupt Cause register in order to locate the originating interrupt        
*      event. Then the routine calls the user specified service routine for that    
*      interrupt cause. The GPP interrupt is edge triggered thus the user ISR is    
*      performed as long as the GPP bit value is active.                            
*      The function scans the gpp31_24Array[] (gpp31_24Count valid entries)         
*      trying to find a hit in the gpp31_24Array cause table.                       
*      When found, the ISR in the same entry is executed.                           
*      Before ISR execution, the handler acknowledges the initiating interrupt.     
*                                                                                   
* INPUT:
*       None.
*
* OUTPUT:
*       See description.
*
* RETURN:
*       None.
*
*******************************************************************************/
void gpp31_24Int (void)
{
    int     i,key,cpu=0;          /* i iterates over the registrated gpp31_24Array[] */
    unsigned int gppActiveInt;
    #ifdef INCLUDE_WINDVIEW
    UINT intNum = P0_GPP_31_24;

    #endif


#ifdef PMC280_DUAL_CPU
   if(frcWhoAmI())
   {	   
      cpu=1;
      intNum = P1_GPP_31_24;
   }   
   else
   {	   
      cpu=0;
      intNum = P0_GPP_31_24; 
   }   
#endif /* PMC280_DUAL_CPU */

#ifdef INCLUDE_WINDVIEW
	WV_EVT_INT_ENT(intNum);  /* to support for Wind View */
#endif 
 
    key = intLock();    
    gppActiveInt = GPP_CAUSE_REG & GPP_MASK_REG(cpu);
	
     for(i=0; i<gpp31_24Count; i++)
      {
        /* Check ISR array hit  */
        if(gppActiveInt & gpp31_24Array[i].causeBit)
        {
            /* Reset the interrupt cause bit in the GPP cause register */
            GPP_CAUSE_REG = ~(gpp31_24Array[i].causeBit);

            /* Perform the ISR */
            (*gpp31_24Array[i].userISR) (gpp31_24Array[i].arg);
        }
    }
   intUnlock(key);
}
/*******************************************************************************
* FUNCTION:  gpp15_8Int - GPP pins 15-8 Interrupt controller routine.
*
* DESCRIPTION:
*      This routine handles the GPP pins 15-8 interrupts. 
*      As soon as the interrupt signal is active the CPU analyzes the GT GPP 
*      Interrupt Cause register in order to locate the originating interrupt 
*      event. Then the routine calls the user specified service routine for that 
*      interrupt cause. The GPP interrupt is edge triggered thus the user ISR is 
*      performed as long as the GPP bit value is active.
*      The function scans the gpp15_8Array[] (gpp15_8Count valid entries)
*      trying to find a hit in the gpp15_8Array cause table.
*      When found, the ISR in the same entry is executed.
*      Before ISR execution, the handler acknowledges the initiating interrupt.
*      
*      NOTE: Poling on the GPP value bit is done to handle edge triggered interrupt.
*
* INPUT:
*       None.
*
* OUTPUT:
*       See description.
*
* RETURN:
*       None.
*
*******************************************************************************/
void gpp15_8Int (void)
{
    int     i,key,cpu=0;          /* i iterates over the registrated gpp31_24Array[] */
    unsigned int gppActiveInt;
#ifdef INCLUDE_WINDVIEW
    UINT intNum = P0_GPP_15_8;
#endif

#ifdef PMC280_DUAL_CPU
   if(frcWhoAmI())
   {	   
      cpu=1;
      intNum = P1_GPP_15_8;
   }   
   else
   {	   
      cpu=0;
      intNum = P0_GPP_15_8;
   }   
#endif /* PMC280_DUAL_CPU */
#ifdef INCLUDE_WINDVIEW
	WV_EVT_INT_ENT(intNum);  /* to support for Wind View */
#endif 
   
 
    key = intLock();    
    gppActiveInt = GPP_CAUSE_REG & GPP_MASK_REG(cpu);
    
    for(i=0; i<gpp15_8Count; i++)
     {
        /* Check ISR array hit  */
        if(gppActiveInt & gpp15_8Array[i].causeBit)
        {
            /* Reset the interrupt cause bit in the GPP cause register */
            GPP_CAUSE_REG = ~(gpp15_8Array[i].causeBit);

            /* Perform the ISR */
            (*gpp15_8Array[i].userISR) (gpp15_8Array[i].arg);
        }
    }
   intUnlock(key);
}


/*******************************************************************************
* FUNCTION:   gpp7_0Int - GPP pins 7-0 Interrupt controller routine.
*
* DESCRIPTION:
*      This routine handles the GPP pins 7-0 interrupts. 
*      As soon as the interrupt signal is active the CPU analyzes the GT GPP 
*      Interrupt Cause register in order to locate the originating interrupt 
*      event. Then the routine calls the user specified service routine for that 
*      interrupt cause. The GPP interrupt is edge triggered thus the user ISR is 
*      performed as long as the GPP bit value is active.
*      The function scans the gpp31_24Array[] (gpp31_24Count valid entries)
*      trying to find a hit in the gpp31_24Array cause table.
*      When found, the ISR in the same entry is executed.
*      Before ISR execution, the handler acknowledges the initiating interrupt.
*      
*      NOTE: Poling on the GPP value bit is done to handle edge triggered interrupt.
*
* INPUT:
*       None.
*
* OUTPUT:
*       See description.
*
* RETURN:
*       None.
*
*******************************************************************************/
void gpp7_0Int (void)
{
    int     i,key,cpu=0;          /* i iterates over the registrated gpp31_24Array[] */
    unsigned int gppActiveInt;
#ifdef INCLUDE_WINDVIEW
    UINT intNum = P0_GPP_7_0;
#endif

#ifdef PMC280_DUAL_CPU
   if(frcWhoAmI())
   {	   
      cpu=1;
      intNum = P1_GPP_7_0;
   }   
   else
   {	   
      cpu=0;
      intNum = P0_GPP_7_0;
   }   
#endif /* PMC280_DUAL_CPU */
#ifdef INCLUDE_WINDVIEW
	WV_EVT_INT_ENT(intNum);  /* to support for Wind View */
#endif 
 
    key = intLock();    
    gppActiveInt = GPP_CAUSE_REG & GPP_MASK_REG(cpu);
	
    for(i=0; i<gpp7_0Count; i++)
     {
        /* Check ISR array hit  */
        if(gppActiveInt & gpp7_0Array[i].causeBit)
        {
            /* Reset the interrupt cause bit in the GPP cause register */
            GPP_CAUSE_REG = ~(gpp7_0Array[i].causeBit);

            /* Perform the ISR */
            (*gpp7_0Array[i].userISR) (gpp7_0Array[i].arg);
        }
    }
    intUnlock(key);
}
#if 0
/*******************************************************************************
* gpp23_16Int - GPP pins 23-16 Interrupt controller routine.
*
* DESCRIPTION:
*      This routine handles the GPP pins 23-16 interrupts. 
*      As soon as the interrupt signal is active the CPU analyzes the GT GPP 
*      Interrupt Cause register in order to locate the originating interrupt 
*      event. Then the routine calls the user specified service routine for that 
*      interrupt cause. The GPP interrupt is edge triggered thus the user ISR is 
*      performed as long as the GPP bit value is active.
*      The function scans the gpp23_16Array[] (gpp23_16Count valid entries)
*      trying to find a hit in the gpp23_16Array cause table.
*      When found, the ISR in the same entry is executed.
*      Before ISR execution, the handler acknowledges the initiating interrupt. 
*
* INPUT:
*       None.
*
* OUTPUT:
*       See description.
*
* RETURN:
*       None.
*
*******************************************************************************/
void gpp23_16Int1(void)
{
    int     i,key;          /* i iterates over the registrated gpp23_16Array[] */
    unsigned int gppActiveInt;

    key = intLock();    
    gppActiveInt = GPP_CAUSE_REG & GPP_MASK1_REG;
	
	for(i=0; i<gpp23_16Count; i++)
    {
        /* Check ISR array hit  */
        if(gppActiveInt & gpp23_16Array[i].causeBit)
        { 
            /* Reset the interrupt cause bit in the GPP cause register */
            GPP_CAUSE_REG = ~(gpp23_16Array[i].causeBit); 

            /* Perform the ISR */
            (*gpp23_16Array[i].userISR) (gpp23_16Array[i].arg);
        } 
    }
   intUnlock(key);
}

/*******************************************************************************
* gpp31_24Int - GPP pins 31-24 Interrupt controller routine.
*
* DESCRIPTION:
*      This routine handles the GPP pins 31-24 interrupts.                          
*      As soon as the interrupt signal is active the CPU analyzes the GT GPP        
*      Interrupt Cause register in order to locate the originating interrupt        
*      event. Then the routine calls the user specified service routine for that    
*      interrupt cause. The GPP interrupt is edge triggered thus the user ISR is    
*      performed as long as the GPP bit value is active.                            
*      The function scans the gpp31_24Array[] (gpp31_24Count valid entries)         
*      trying to find a hit in the gpp31_24Array cause table.                       
*      When found, the ISR in the same entry is executed.                           
*      Before ISR execution, the handler acknowledges the initiating interrupt.     
*                                                                                   
* INPUT:
*       None.
*
* OUTPUT:
*       See description.
*
* RETURN:
*       None.
*
*******************************************************************************/
void gpp31_24Int1 (void)
{
    int     i,key;          /* i iterates over the registrated gpp31_24Array[] */
    unsigned int gppActiveInt;
    
    key = intLock();    
    gppActiveInt = GPP_CAUSE_REG & GPP_MASK1_REG;
	
     for(i=0; i<gpp31_24Count; i++)
      {
        /* Check ISR array hit  */
        if(gppActiveInt & gpp31_24Array[i].causeBit)
        {
            /* Reset the interrupt cause bit in the GPP cause register */
            GPP_CAUSE_REG = ~(gpp31_24Array[i].causeBit);

            /* Perform the ISR */
            (*gpp31_24Array[i].userISR) (gpp31_24Array[i].arg);
        }
    }
   intUnlock(key);
}
/*******************************************************************************
* FUNCTION:  gpp15_8Int - GPP pins 15-8 Interrupt controller routine.
*
* DESCRIPTION:
*      This routine handles the GPP pins 15-8 interrupts. 
*      As soon as the interrupt signal is active the CPU analyzes the GT GPP 
*      Interrupt Cause register in order to locate the originating interrupt 
*      event. Then the routine calls the user specified service routine for that 
*      interrupt cause. The GPP interrupt is edge triggered thus the user ISR is 
*      performed as long as the GPP bit value is active.
*      The function scans the gpp15_8Array[] (gpp15_8Count valid entries)
*      trying to find a hit in the gpp15_8Array cause table.
*      When found, the ISR in the same entry is executed.
*      Before ISR execution, the handler acknowledges the initiating interrupt.
*      
*      NOTE: Poling on the GPP value bit is done to handle edge triggered interrupt.
*
* INPUT:
*       None.
*
* OUTPUT:
*       See description.
*
* RETURN:
*       None.
*
*******************************************************************************/
void gpp15_8Int1 (void)
{
    int     i,key;          /* i iterates over the registrated gpp31_24Array[] */
    unsigned int gppActiveInt;

    key = intLock();    
    gppActiveInt = GPP_CAUSE_REG & GPP_MASK1_REG;
	
	for(i=0; i<gpp15_8Count; i++)
    {
        /* Check ISR array hit  */
        if(gppActiveInt & gpp15_8Array[i].causeBit)
        {
            /* Reset the interrupt cause bit in the GPP cause register */
            GPP_CAUSE_REG = ~(gpp15_8Array[i].causeBit);

            /* Perform the ISR */
            (*gpp15_8Array[i].userISR) (gpp15_8Array[i].arg);
        }
    }
   intUnlock(key);
}


/*******************************************************************************
* FUNCTION:   gpp7_0Int - GPP pins 7-0 Interrupt controller routine.
*
* DESCRIPTION:
*      This routine handles the GPP pins 7-0 interrupts. 
*      As soon as the interrupt signal is active the CPU analyzes the GT GPP 
*      Interrupt Cause register in order to locate the originating interrupt 
*      event. Then the routine calls the user specified service routine for that 
*      interrupt cause. The GPP interrupt is edge triggered thus the user ISR is 
*      performed as long as the GPP bit value is active.
*      The function scans the gpp31_24Array[] (gpp31_24Count valid entries)
*      trying to find a hit in the gpp31_24Array cause table.
*      When found, the ISR in the same entry is executed.
*      Before ISR execution, the handler acknowledges the initiating interrupt.
*      
*      NOTE: Poling on the GPP value bit is done to handle edge triggered interrupt.
*
* INPUT:
*       None.
*
* OUTPUT:
*       See description.
*
* RETURN:
*       None.
*
*******************************************************************************/
void gpp7_0Int1 (void)
{
    int     i,key;          /* i iterates over the registrated gpp31_24Array[] */
    unsigned int gppActiveInt;

    key = intLock();    
    gppActiveInt = GPP_CAUSE_REG & GPP_MASK1_REG;
	
    for(i=0; i<gpp7_0Count; i++)
     {
        /* Check ISR array hit  */
        if(gppActiveInt & gpp7_0Array[i].causeBit)
        {
            /* Reset the interrupt cause bit in the GPP cause register */
            GPP_CAUSE_REG = ~(gpp7_0Array[i].causeBit);

            /* Perform the ISR */
            (*gpp7_0Array[i].userISR) (gpp7_0Array[i].arg);
        }
    }
    intUnlock(key);
}
#endif
