/******************************************************************************
*              (c), Copyright, MOTOROLA  INC  - ECC                  *
*                                                                             *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MOTOROLA , INC.        *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT *
* OF MOTOROLA  OR ANY THIRD PARTY. MOTOROLA  RESERVES THE RIGHT AT ITS SOLE DISCRETION*
* TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MOTOROLA .       *
* THIS CODE IS PROVIDED "AS IS". MOTOROLA  MAKES NO WARRANTIES, EXPRESS,*
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.  *
*******************************************************************************

*******************************************************************************
* vxEthernetIntCntl.c - Ethernet Interrupt controller library
*
* DESCRIPTION:
*       This driver provides various interface routines to manipulate and
*       connect the hardware interrupts described by the Ethernet facility.
*		The Ethernet device introduce two interrupt cause registers levels:
*		1) Interrupt cause register.
*		2) Interrupt cause extended register.
*		The only way the CPU can respond to Interrupt cause extended register
*		is using the Interrupt cause extended register summarize bit in the 
*		Interrupt cause register. This driver automatically handels those 
*		interrupts.
*
*   	Main features:
*       - This driver introduce an efficient way to handle Ethernet SDMA events.
*       - Ethernet interrupt registration architecture is transparent to the 
*		  user. The user merely has to be familiar with the SDMA events.
*		- The controller provides an easy way to hook a C Interrupt Service
*         Routine (ISR) to a specific interrupt caused by the Ethenret SDMA.    
*       - This controller automatically acknowledge interrupts.
*       - The controller interrupt mechanism provides a way for the programmer
*         to set the priority of an interrupt.
*       - Full interrupt control over the Ethernet SDMA interrupt events.
*
*       Overall Interrupt Architecture description:
*       The Marvell's device handles interrupts in two stages:
*       STAGE 1: Main Cause register that summarize the interrupts generated by
*		         each Internal unit.
*       STAGE 2: Unit specified cause registers, that distinguish between each
*                specific interrupt event.
*       This System Interrupt Controller Driver handles the various interrupts 
*       generated by the Ethernet interrupt cause registers.
*
*       The driver's execution flow has three phases:
*       1) Driver initialization.
*          This initiation includes hooking driver's ISR to 
*          the Main Interrupt controller.
*       2) User ISR connecting. Here information about user ISR and interrupt 
*          priority is gathered. Each handler has its private connection array
*		   where all connections relevent to this ISR are stored.
*       3) Interrupt handler. Here an interrupt is being handle by the Interrupt 
*          Handlers. Interrupt acknowledge is also done in this stage.
*
*   Full API:
*      vxEthernetIntCntlInit() - Initiate the Interrupt Controller driver.
*      vxEthernetIntConnect()  - Connect the user ISR to an interrupt events.
*      ethPort0Handler() 	   - Handle Ethernet port 0 cause interrupts.
*      ethPort0ExtHandler()    - Handle Ethernet port 0 cause extend interrupts.
*      ethPort1Handler() 	   - Handle Ethernet port 1 cause interrupts.
*      ethPort1ExtHandler()    - Handle Ethernet port 1 cause extend interrupts.
*      vxEthernetIntDisable()  - Disable a given Ethernet interrupt cause.
*      vxEthernetIntEnable()   - Enable a given Ethernet interrupt cause.
*
*
*   	The controller concept is very simple:
*   	Each of the Interrupt handlers has a small table which holds 
*		information on the connected ISR. For example, ethPort1Handler() has 
*		ethPort1Array[] which holds the ISR concerning port 1 events. An 
*		Interrupt generated by one of those pins will result a search through 
*		this table in order to locate the generating interrupt cause. After the 
*		initiating interrupt cause is identify, the ISR reside in the same 
*		table entry is executed. Before the ISR executes the interrupt is 
*		acknowledged. 
*
*   	The controller API also includes interrupt control routines which can 
*   	enable/disable specific interrupts.
*
* DEPENDENCIES:
*		VxWorks.
*		Ethernet low level driver module.
*		Main Interrupt controller module.
*
******************************************************************************/

/* includes */
#include <vxWorks.h>
#include "ethernet.h" 
#include "vxEthernetIntCtrl.h" 
#include "gtIntControl.h" 
#include "intLib.h"  
#include "logLib.h" 

#include "config.h"

#ifdef INCLUDE_WINDVIEW
#include "private/funcBindP.h"
#include "private/eventP.h"
#include "wvLib.h"
#endif


/* defines  */

#define CAUSE_BIT(cause)		(1 << cause)

#define ETH_0_CAUSE_REG		(REG_CONTENT(ETH_INTERRUPT_CAUSE_REG(0)))
#define ETH_0_MASK_REG  	(REG_CONTENT(ETH_INTERRUPT_MASK_REG(0)))          

#define ETH_0_CAUSE_EXT_REG	(REG_CONTENT(ETH_INTERRUPT_CAUSE_EXTEND_REG(0)))
#define ETH_0_MASK_EXT_REG 	(REG_CONTENT(ETH_INTERRUPT_EXTEND_MASK_REG(0)))          

#define ETH_1_CAUSE_REG		(REG_CONTENT(ETH_INTERRUPT_CAUSE_REG(1)))         
#define ETH_1_MASK_REG  	(REG_CONTENT(ETH_INTERRUPT_MASK_REG(1)))          

#define ETH_1_CAUSE_EXT_REG	(REG_CONTENT(ETH_INTERRUPT_CAUSE_EXTEND_REG(1)))         
#define ETH_1_MASK_EXT_REG 	(REG_CONTENT(ETH_INTERRUPT_EXTEND_MASK_REG(1)))          

/* typedefs */


/* locals   */
/* GT_ISR_ENTRY array accumulates ISR information for each Ethenret handler. */
LOCAL GT_ISR_ENTRY ethPort0Array[32];
LOCAL GT_ISR_ENTRY ethPort0ExtArray[32];
LOCAL GT_ISR_ENTRY ethPort1Array[32];                                                     
LOCAL GT_ISR_ENTRY ethPort1ExtArray[32];                                                     

/*Each counter accumulate the number of connection done to a cause array. */
LOCAL int ethPort0Count 	= 0;   
LOCAL int ethPort0ExtCount 	= 0;   
LOCAL int ethPort1Count 	= 0;   
LOCAL int ethPort1ExtCount	= 0;   

LOCAL int ethernetIntCtrlInitialized = false;   

/* Interrupt Controller's ISR */
static void ethPort0Handler(void); 
static void ethPort0ExtHandler(void); 
static void ethPort1Handler(void); 
static void ethPort1ExtHandler(void); 

/*******************************************************************************
* vxEthernetIntCntlInit - Initiating the Ethernet Interrupt Controller driver.
*
* DESCRIPTION:
*       This routines connects the drivers interrupt handlers, each to its 
*       corresponding bit in the Main Interrupt Controller using the 
*		gtIntConnect() routine. The routine also connects the extended 
*		interrupts handlers to the extended interrupt cause summary in the 
*		Ethenret cause register. Enabling those interrupt is done in the 
*		connection phase in case there is a connection done to a extended cause
*		interrupt. This is done to simplify the use of ethernet interrupt 
*		system.
*
* INPUT:
*       None.
*
* OUTPUT:
*       Driver's ISR are connected to the CPU's Interrupt vector and 
*       interrupts are unmasked.
*
* RETURN:
*       None.
*
*******************************************************************************/
void vxEthernetIntCntlInit()
{
    if(ethernetIntCtrlInitialized)
        return;

	ETH_0_CAUSE_REG 	= 0;  /* Clean Cause register (case of warm reboot)	*/
	ETH_0_MASK_REG  	= 0;  /* Clean Cause register (case of warm reboot)	*/
	
	ETH_0_CAUSE_EXT_REG = 0;  /* Clean Cause register (case of warm reboot)	*/
	ETH_0_MASK_EXT_REG  = 0;  /* Clean Cause register (case of warm reboot)	*/
    
	ETH_1_CAUSE_REG  	= 0;  /* Clean Mask register (case of warm reboot)	*/
	ETH_1_MASK_REG   	= 0;  /* Clean Mask register (case of warm reboot)	*/
	
	ETH_1_CAUSE_EXT_REG = 0;  /* Clean Mask register (case of warm reboot)	*/
	ETH_1_MASK_EXT_REG  = 0;  /* Clean Mask register (case of warm reboot)	*/
	
    /* Connect the user ISR's to the ethernet bits in the main cause register */
	gtIntConnect(GE0, ethPort0Handler, 0, ETH_PORT_0_ISR_PRIO);      
	gtIntConnect(GE1, ethPort1Handler, 0, ETH_PORT_1_ISR_PRIO);      

    /* Unmask those bits */
	gtIntEnable(GE0);
	gtIntEnable(GE1);

	/* Connect the Ethernet extended interrupt */
    vxEthernetIntConnect(ETH_0, ETH_INT_CAUSE_EXTEND, ethPort0ExtHandler, 0, 0);  
    vxEthernetIntConnect(ETH_1, ETH_INT_CAUSE_EXTEND, ethPort1ExtHandler, 0, 0);  
    
	ethernetIntCtrlInitialized = true;

}

/*******************************************************************************
* vxEthernetIntConnect - connect a C routine to a specific Ethernet interrupt.
*
* DESCRIPTION:
*       This routine connects a specified ISR to a specified Ethernet interrupt 
*       cause. Each ISR handler has its own user ISR array. The connection 
*       is done by setting the desired routine and parameter in the correspond 
*       cause array (i.e. ethPort0Array[] for port 0 events):
*       1) Check for existing connection for the same cause bit in the table.
*       2) Connecting the user ISR by inserting the given parameters into an
*          entry according to the user ISR given priority.
*		This function will enable extended interrupt only if there are 
*		connection done to extended cause register cause.
*
* INPUT:
*       ETH_PORT ethPortNum: Ethernet port number. See ETH_PORT enumerator.
*		ETH_CAUSE     cause: Ethernet interrupt cause. See ETH_CAUSE enumerator. 
*       VOIDFUNCPTR routine: user ISR.
*       int       parameter: user ISR parameter.
*       int            prio: Interrupt handling priority where 0 is highest.    
*
* OUTPUT:
*       An appropriate table entry is filled.
*
* RETURN:
*       OK    if succeeded 
*       ERROR if cause argument is wrong or connected cause is already 
*             found in table.
*
*******************************************************************************/
bool vxEthernetIntConnect(ETH_PORT 	  ethPortNum,   
						  ETH_CAUSE   cause,               
						  VOIDFUNCPTR routine,           
						  int 		  parameter,                 
						  int 		  prio)                      
{
    GT_ISR_ENTRY *ethIntCauseArray; /* pointer to the selected cause table    */
    int *ethIntConnectCount;   		/* pointer to the table connection counter*/
    int i, sysIntOldConfig;

    sysIntOldConfig = intLock();
    /* check for cause parameter validity */
    if(routine == NULL)
    {
        logMsg("vxEthernetIntConnect: NULL pointer routine\n",0,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return false;
    }
    else if(prio < 0)
    {
        logMsg("vxEthernetIntConnect: Invalid priority\n",0,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return false;
    }
    
	switch(ethPortNum)
	{
		case(ETH_0):
			if(cause < 32)
			{
				ethIntCauseArray = ethPort0Array;
				ethIntConnectCount = &ethPort0Count;
			}
			else
			{
				ethIntCauseArray = ethPort0ExtArray;
				ethIntConnectCount = &ethPort0ExtCount;
				cause %= 32;
				vxEthernetIntEnable(ETH_0, ETH_INT_CAUSE_EXTEND);

			}
			break;
		
		case(ETH_1):
			if(cause < 32)
			{
				ethIntCauseArray = ethPort1Array;
				ethIntConnectCount = &ethPort1Count;
			}
			else
			{
				ethIntCauseArray = ethPort1ExtArray;
				ethIntConnectCount = &ethPort1ExtCount;
				cause %= 32;
				vxEthernetIntEnable(ETH_1, ETH_INT_CAUSE_EXTEND);
			}
			break;
		
		default:
			logMsg("vxEthernetIntConnect: Invalid cause %d\n",cause,0,0,0,0,0);
			intUnlock(sysIntOldConfig);
			return false;
    }

    /* Scan the table to check for double connection to the same cause bit */
    for(i=*ethIntConnectCount; i >= 0; i--)
        if(ethIntCauseArray[i].causeBit == SWAP_CAUSE_BIT(cause))
        {
            intUnlock(sysIntOldConfig);
            return false;
        }

    /* Connection phase */
    for(i=*ethIntConnectCount; i>=0; i--)
    {
        if(i==0 || ethIntCauseArray[i-1].prio < prio) /* Make connection */
        {
            ethIntCauseArray[i].causeBit = SWAP_CAUSE_BIT(cause);
            ethIntCauseArray[i].userISR  = routine;
            ethIntCauseArray[i].arg      = parameter;
            ethIntCauseArray[i].prio     = prio;
            (*ethIntConnectCount)++;
            break;
        }
        else
        {
            /* Push the low priority connection down the table */
            ethIntCauseArray[i].causeBit = ethIntCauseArray[i-1].causeBit;
            ethIntCauseArray[i].userISR  = ethIntCauseArray[i-1].userISR;
            ethIntCauseArray[i].arg      = ethIntCauseArray[i-1].arg;
            ethIntCauseArray[i].prio     = ethIntCauseArray[i-1].prio;    
        }
    }
    intUnlock(sysIntOldConfig);
    return true;
}

/*******************************************************************************
* ethPort0Handler - Ethernet port 0 handler for cause interrupts.
*
* DESCRIPTION:
*      	This routine handles the interrupt generated by ethernet port 0 by the 
*		cause register. 
*      	When interrupt pend, the handler analyzes the Ethernet interrupt 
*      	cause register in order to locate the originating interrupt event. 
*		Then the routine calls the user specified service routine for 
*		that interrupt cause. 
*      	The function scans the ethPort0Array[] trying to find a hit in the 
*		connection table.
*      	When found, the ISR in the same entry is executed.
*      	Before ISR execution, the handler acknowledges the initiating interrupt.
*
* INPUT:
*       None.
*
* OUTPUT:
*       See description.
*
* RETURN:
*       None.
*
*******************************************************************************/
void ethPort0Handler(void)
{
    int     i;
    unsigned int ethActiveInt;
#ifdef INCLUDE_WINDVIEW
	WV_EVT_INT_ENT(GE0);  /* Change this later */
#endif 


	ethActiveInt = ETH_0_CAUSE_REG & ETH_0_MASK_REG;

	for(i = 0; i < ethPort0Count; i++)
    {                                                                                
		/* Check ISR array hit  */                                                    
        if(ethActiveInt & ethPort0Array[i].causeBit)
        { 
            /* Clear interrupt cause bit in the Ethernet cause register */
			ETH_0_CAUSE_REG = ~(ethPort0Array[i].causeBit);
            
            /* Perform the ISR */
            (*ethPort0Array[i].userISR) (ethPort0Array[i].arg);
        } 
    }
}

/*******************************************************************************
* ethPort0ExtHandler - Ethernet port 0 handler for extended cause interrupts.
*
* DESCRIPTION:
*      	This routine handles the interrupt generated by ethernet port 0 by the 
*		extended cause register. 
*      	When interrupt pend, the handler analyzes the Ethernet interrupt 
*      	extended cause register in order to locate the originating interrupt 
*      	event. Then the routine calls the user specified service routine for 
*		that interrupt cause. 
*      	The function scans the ethPort0ExtArray[] trying to find a hit in the 
*		connection table.
*      	When found, the ISR in the same entry is executed.
*      	Before ISR execution, the handler acknowledges the initiating interrupt.
*
* INPUT:
*       None.
*
* OUTPUT:
*       See description.
*
* RETURN:
*       None.
*
*******************************************************************************/
void ethPort0ExtHandler(void)
{
    int     i;
    unsigned int ethActiveInt;

	ethActiveInt = ETH_0_CAUSE_EXT_REG & ETH_0_MASK_EXT_REG;
				    
	for(i = 0; i < ethPort0ExtCount; i++)
    {                                                                                
		/* Check ISR array hit  */                                                    
        if(ethActiveInt & ethPort0ExtArray[i].causeBit)
        { 
            /* Clear interrupt cause bit in the extended cause register */
			ETH_0_CAUSE_EXT_REG = ~(ethPort0ExtArray[i].causeBit);
            
            /* Perform the ISR */
            (*ethPort0ExtArray[i].userISR) (ethPort0ExtArray[i].arg);
        } 
    }
}

/*******************************************************************************
* ethPort1Handler - Ethernet port 1 handler for cause interrupts.
*
* DESCRIPTION:
*      	This routine handles the interrupt generated by ethernet port 1 by the 
*		cause register. 
*      	When interrupt pend, the handler analyzes the Ethernet interrupt 
*      	cause register in order to locate the originating interrupt event. 
*		Then the routine calls the user specified service routine for 
*		that interrupt cause. 
*      	The function scans the ethPort1Array[] trying to find a hit in the 
*		connection table.
*      	When found, the ISR in the same entry is executed.
*      	Before ISR execution, the handler acknowledges the initiating interrupt.
*
* INPUT:
*       None.
*
* OUTPUT:
*       See description.
*
* RETURN:
*       None.
*
*******************************************************************************/
void ethPort1Handler(void)
{
    int     i;
    unsigned int ethActiveInt;
#ifdef INCLUDE_WINDVIEW
	WV_EVT_INT_ENT(GE1);  /* Change this later */
#endif 


	ethActiveInt = ETH_1_CAUSE_REG & ETH_1_MASK_REG;
				    
	for(i = 0; i < ethPort1Count; i++)
    {                                                                                
		/* Check ISR array hit  */                                                    
        if(ethActiveInt & ethPort1Array[i].causeBit)
        { 
            /* Clear interrupt cause bit in the Ethernet cause register */
			ETH_1_CAUSE_REG = ~(ethPort1Array[i].causeBit);
            
            /* Perform the ISR */
            (*ethPort1Array[i].userISR) (ethPort1Array[i].arg);
        } 
    }
}

/*******************************************************************************
* ethPort1ExtHandler - Ethernet port 1 handler for extended cause interrupts.
*
* DESCRIPTION:
*      	This routine handles the interrupt generated by ethernet port 1 by the 
*		extended cause register. 
*      	When interrupt pend, the handler analyzes the Ethernet interrupt 
*      	extended cause register in order to locate the originating interrupt 
*      	event. Then the routine calls the user specified service routine for 
*		that interrupt cause. 
*      	The function scans the ethPort1ExtArray[] trying to find a hit in the 
*		connection table.
*      	When found, the ISR in the same entry is executed.
*      	Before ISR execution, the handler acknowledges the initiating interrupt.
*
* INPUT:
*       None.
*
* OUTPUT:
*       See description.
*
* RETURN:
*       None.
*
*******************************************************************************/
void ethPort1ExtHandler(void)
{
    int     i;          
    unsigned int ethActiveInt;

	ethActiveInt = ETH_1_CAUSE_EXT_REG & ETH_1_MASK_EXT_REG;
				    
	for(i = 0; i < ethPort1ExtCount; i++)
    {                                                                                
		/* Check ISR array hit  */                                                    
        if(ethActiveInt & ethPort1ExtArray[i].causeBit)
        { 
            /* Clear interrupt cause bit in the extended cause register */
			ETH_1_CAUSE_EXT_REG = ~(ethPort1ExtArray[i].causeBit);
            
            /* Perform the ISR */
            (*ethPort1ExtArray[i].userISR) (ethPort1ExtArray[i].arg);
        } 
    }
}

/*******************************************************************************
* vxEthernetIntDisable - Disable an Ethernet interrupt
*
* DESCRIPTION:
*       This routine masks a specified interrupt in either Ethernet mask or 
*		extended mask registers.
*       The routine will preform argument validity check. 
*
* INPUT:
*		ETH_PORT ethPortNum - Ethernet port number. See ETH_PORT.
*       ETH_CAUSE cause     - Ethernet interrupt cause as defined in ETH_CAUSE. 		
*
* OUTPUT:
*       The appropriate bit in the either Ethernet mask or extended mask 
*		registers is reset.
*
* RETURN:
*       true    - If the bit was reset
*       false - if the bit was invalid
*
*******************************************************************************/
bool vxEthernetIntDisable(ETH_PORT ethPortNum, ETH_CAUSE cause)
{
	unsigned int ethMask;
    
	if(cause < 32)
	{
		GT_REG_READ(ETH_INTERRUPT_MASK_REG(ethPortNum), &ethMask); 
		ethMask &= ~CAUSE_BIT(cause);
		GT_REG_WRITE(ETH_INTERRUPT_MASK_REG(ethPortNum), ethMask); 
    }
	else
	{
		GT_REG_READ(ETH_INTERRUPT_EXTEND_MASK_REG(ethPortNum), &ethMask); 
		ethMask &= ~CAUSE_BIT(cause % 32);
		GT_REG_WRITE(ETH_INTERRUPT_EXTEND_MASK_REG(ethPortNum), ethMask); 
    }
    
	return true;
}

/*******************************************************************************
* vxEthernetIntEnable - Enable an Ethernet interrupt
*
* DESCRIPTION:
*       This routine unmasks a specified interrupt in either Ethernet mask or 
*		extended mask registers.
*       The routine will preform argument validity check. 
*
* INPUT:
*		ETH_PORT ethPortNum - Ethernet port number. See ETH_PORT.
*       ETH_CAUSE cause     - Ethernet interrupt cause as defined in ETH_CAUSE. 		
*
* OUTPUT:
*       The appropriate bit in either Ethernet mask or extended mask 
*		registers is set.
*
* RETURN:
*       true    - If the bit was reset
*       false - if the bit was invalid
*
*******************************************************************************/
bool vxEthernetIntEnable(ETH_PORT ethPortNum, ETH_CAUSE cause)
{
	unsigned int ethMask;

	if(cause < 32)
	{
		GT_REG_READ(ETH_INTERRUPT_MASK_REG(ethPortNum), &ethMask); 
		ethMask |= CAUSE_BIT(cause);
		GT_REG_WRITE(ETH_INTERRUPT_MASK_REG(ethPortNum), ethMask); 
    }
	else
	{
		GT_REG_READ(ETH_INTERRUPT_EXTEND_MASK_REG(ethPortNum), &ethMask); 
		ethMask |= CAUSE_BIT(cause % 32);
		GT_REG_WRITE(ETH_INTERRUPT_EXTEND_MASK_REG(ethPortNum), ethMask); 
    }
	
	return true;
}

