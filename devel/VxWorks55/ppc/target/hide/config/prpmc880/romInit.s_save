/* romInit.s - Motorola PrPMC880 ROM initialization module */

/* Copyright 1984-1999 Wind River Systems, Inc. */
/* Copyright 1996-2003 Motorola, Inc. All Rights Reserved */

/*
modification history
--------------------
01a,31mar03,simon  Ported. from ver 01b, mcp905/romInit.s.
*/

/*
DESCRIPTION
This module contains the entry code for the VxWorks bootrom.
The entry point romInit, is the first code executed on power-up.
It sets the BOOT_COLD parameter to be passed to the generic
romStart() routine.

The routine sysToMonitor() jumps to the location 4 bytes
past the beginning of romInit, to perform a "warm boot".
This entry point allows a parameter to be passed to romStart().

This code is intended to be generic across PowerPC 603/604 boards.
Hardware that requires special register setting or memory
mapping to be done immediately, may do so here.
*/

#define    _ASMLANGUAGE
#include "vxWorks.h"
#include "sysLib.h"
#include "asm.h"
#include "config.h"
#include "regs.h"    
#include "mv64360.h"

#include "arch/ppc/mmu603Lib.h"

#define DSSALL .long 0x7E00066C  /* explicit encoding for DSSALL instruction */

#define MSSCR0		    1014	 /* Memory Subsystem Control Register */
#define L2CR		    1017	 /* L2 Cache Control Register */
#define PPC_L2CR_L2IO	    0x00100000   /* L2 Instruction-Only Mode */
#define PPC_HID0_TBEN	    0x04000000	 /* Time Base Enable - bit 5 */
#define PPC_HID1_EMCP	    0x80000000	 /* Machine Check Signal Enable - */
                                         /* Bit 0 */ 
#define CACHE_STACK_ADRS    (0x00003000) /* No-RAM cache initial stack top */
#define CACHE_STACK_SIZE    (8*1024)

    /* Exported internal functions */

    .data
    FUNC_EXPORT(_romInit)       /* start of system code */
    FUNC_EXPORT(romInit)        /* start of system code */
    FUNC_EXPORT(_romInitWarm)   /* start of system code */
    FUNC_EXPORT(romInitWarm)    /* start of system code */

    /* externals */

    /* system initialization routine */

    FUNC_IMPORT(romStart)       /* system initialization routine */         

    /* MV64360 System Memory Controller Initialization */

    FUNC_IMPORT(sysMv64360SdramInit)

    _WRS_TEXT_SEG_START

/******************************************************************************
*
* romInit - entry point for VxWorks in ROM
*
* romInit
*     (
*     int startType    /@ only used by 2nd entry point @/
*     )
*/

FUNC_LABEL(_romInit)
FUNC_BEGIN(romInit)

    /* This is the cold boot entry (ROM_TEXT_ADRS) */

    bl    cold

_romInitWarm:
romInitWarm:

    /* This is the warm boot entry (ROM_WARM_ADRS) */

    bl    warm

    /* copyright notice appears at beginning of ROM (in TEXT segment) */

    .ascii   "Copyright 1984-1999 Wind River Systems, Inc."
    .balign 2

cold:
    li    r31, BOOT_COLD
    bl    start          /* skip over next instruction */

            
warm:
    or    r31, r3, r3    /* startType to r31 */

start:

    /* Zero-out registers: r0 & SPRGs */

    xor     r0,r0,r0
    mtspr   272,r0
    mtspr   273,r0
    mtspr   274,r0
    mtspr   275,r0
    mtspr   276,r0
    mtspr   277,r0
    mtspr   278,r0
    mtspr   279,r0

    /* initialize the stack pointer */

    lis     sp, HI(CACHE_STACK_ADRS)
    ori     sp, sp, LO(CACHE_STACK_ADRS)

    /*
     * Set HID0 to a known state
     *
     * At this point we only want to set the Time Base Enable (TBEN), 
     * which enables both the time base and the decrementer.
     *
     * Synchronization requirements: when modifying the TBEN bit
     * of HID0 an isync must follow the mtspr.
     */

    lis     r3,HI(PPC_HID0_TBEN)           /* 0x04000000 */
    ori     r3,r3,LO(PPC_HID0_TBEN)
    isync
    mtspr   HID0,r3
    isync

    /*
     * At this point we would normally want to set the Machine Check 
     * Signal Enable (EMCP) in HID1.  However, on the MCPM905 the
     * MCP signal is connected to a pull-up and therefore not used as
     * it is on other boards.
     */

    /*
     * Set MSR to a known state 
     *
     * At power-up the IP bit is set to 1.  The IP (Exception Prefix) 
     * bit specifies the physical address for exceptions.  If set to 0, 
     * exceptions are vectored to the physical address 0x000n_nnnn, 
     * which is the setting we desire.  If set to 1, exceptions are 
     * vectored to the physical address 0xFFFn_nnnn.  
     *
     * Synchronization requirements: there is no specific synchronization
     * requirement for clearing all bits in the MSR, therefore the 
     * strictest synchronization will be applied.  This means a DSSALL and
     * sync preceding, as well as a sync and isync following.
     */

    andi.   r3, r3, 0
    DSSALL
    sync
    mtmsr   r3
    sync
    isync

    /* 
     * Init the MMU Segment registers 
     *
     * Synchronization requirements: According to the MPC7450 RISC
     * Microprocessor Family User's Manual a dssall and sync must precede
     * a mtsr, and a sync and isync must follow.  But since this is 
     * initialization code an isync before and after each mtsr will be 
     * considered sufficient.
     */

    andi.   r3, r3, 0
    isync
    mtsr    0,r3
    isync
    mtsr    1,r3
    isync
    mtsr    2,r3
    isync
    mtsr    3,r3
    isync
    mtsr    4,r3
    isync
    mtsr    5,r3
    isync
    mtsr    6,r3
    isync
    mtsr    7,r3
    isync
    mtsr    8,r3
    isync
    mtsr    9,r3
    isync
    mtsr    10,r3
    isync
    mtsr    11,r3
    isync
    mtsr    12,r3
    isync
    mtsr    13,r3
    isync
    mtsr    14,r3
    isync
    mtsr    15,r3
    isync

    /* 
     * MV64360 CPU Address Decoding (MV64360 Internal Register Space)
     *
     * The MV64360 has 21 windows in its CPU interface:
     * -> 4 for SDRAM chip selects
     * -> 5 for device chip selects (0,1,2,3,boot)
     * -> 5 for PCI_0 interface
     * -> 5 for PCI_1 interface
     * -> 1 for integrated SRAM
     * -> 1 for internal registers 
     *
     *
     * At this point we will disable all PCI interface windows(10),
     * the integrated SRAM window(1), device chip selects 2 and
     * 3(2), and SDRAM chip selects.  Device chip selects 2 and 3 
     * are not used on this board.
     *
     * NOTE: According to page 97 of the MV64360 System Controller Manual,
     *       the internal registers of the MV64360 are always programmed in
     *       Little Endian.  This requires us to perform byte-swapping when
     *       reading from and/or writing to the internal registers.
     */

    lis     r3,HI(0xF1000000)     /* r3 = MV64360 Internal Registers Base */
    ori     r3,r3,LO(0xF1000000)  /*      address at power-up */

    /* 
     * Disable PCI I/F, Integrated SRAM, Device Chip Select 0,1 & 3,
     * and SDRAM Chip Select Windows.
     */

    addis   r4,r0,0x000F          /* r4 = 0x000FFEBE to be programmed into */
/* Sergey: following line was modified */
    ori     r4,r4,0xFEAE          /* the Base Address Enable register(0x278) */ 
    /* Sergey: ori     r4,r4,0xFEBE */         /* the Base Address Enable register(0x278) */ 
    addis   r5,r0,0x0000                  /* r5 = Base Address Enable */
    ori     r5,r5,CPUIF_BASE_ADDR_ENABLE  /*      Register offset */
    isync                         /* synchronize */
    stwbrx  r4,r3,r5              /* Program Base Addr Enable Reg */
    eieio                         /* synchronize */
    sync

    /* 
     * Read Internal Register Space Window Register
     * This guarantees that all previous transactions in the CPU
     * Interface Pipe are flushed.
     */
    
    lis     r5,HI(CPUIF_INTERNAL_SPACE_BASE_ADDR) /* r5 = Internal Reg Space */
    ori     r5,r5,LO(CPUIF_INTERNAL_SPACE_BASE_ADDR) /*   Window reg offset */ 
    lwbrx   r10,r3,r5 
    sync

    /* 
     * Disable MV64360 Watchdog Timer 
     *
     * A write sequence of '01' followed by '10' into CTL1(25:24) of the
     * Watchdog Configuration Register will disable the watchdog timer
     * when the EN bit is equal to 1 (ie. the watchdog is enabled),
     * otherwise this write sequence will enable the watchdog timer.
     */

disableWatchdog:
    addis   r4,r0,0xFCFF              /* r4 = mask of 0xFCFFFFFF */        
    ori     r4,r4,0xFFFF
    addis   r5,r0,0x0000              /* r5 = Watchdog Configuration */
    ori     r5,r5,WDOG_CFG_REG        /*      Register offset */
    isync
    lwbrx   r10,r3,r5                 /* r10 = watchdog configuration reg */ 
    sync
    and     r10,r10,r4                /* r10 = watchdog config reg */
    sync                              /* with CTL1 bits set to '00' */
    oris    r6,r10,0x0100             /* r6 = watchdog config reg */ 
                                      /* with CTL1 bits set to '01' */
    stwbrx  r6,r3,r5                  /* write r6 to watchdog config reg */ 
    eieio                             /* synchronize */
    sync
    oris    r6,r10,0x0200             /* r6 = watchdog config reg */
                                      /* with CTL1 bits set to '10' */
    stwbrx  r6,r3,r5                  /* write r6 to watchdog config reg */
    eieio                             /* synchronize */
    sync
    lwbrx   r10,r3,r5                 /* Read register to ensure disabled */ 
    sync
    addis   r4,r0,0x8000              /* r4 = mask 0f 0x80000000 */
    ori     r4,r4,0x0000
    and.    r10,r10,r4                /* r10 = watchdog config reg with */
                                      /* all bits except 31 (EN) masked */
    bne     disableWatchdog       

    /* Program Device Bank 2 to allow access to System Status Register 1 */
    bl      progDevBank2	 

    /* turn the LED off */
    addis	r4,r0,HI(SYSTEM_STATUS_REG_1)	/* base address of LED system register */
    ori	r4,r4,LO(SYSTEM_STATUS_REG_1)	
    eieio
    sync
    addi	r3,r0,0xff
    stb	r3,0(r4)		/* write transmit char to char1 */
    eieio
    sync
       
    /*
     * System Memory Configuration and Initialization
     *
     * On a cold boot only, the system memory controller must be
     * configured and the DRAM must be scrubbed.  On a warm boot this 
     * is not necessary so proceed to the "C Entry Point".
     */

memConfig:
    cmpwi   r31,BOOT_COLD           /* check for warm boot */
    bne     goCEntry                /* if warm boot, skip memory config */

    /*
     * In order to program the memory controller we need to have
     * access to some sort of memory in order for our C routine,
     * to compute and then store our memory controller parameters.  
     * Since the memory controller controls DRAM, and since we are 
     * initializing the controller, we cannot use DRAM for this, we 
     * must use some other memory.  The memory that we will use is 
     * the L1 cache in write-back mode.  All references within this 
     * space will not be flushed out to DRAM.  We accomplish this in 
     * the following manner:
     *
     * 1. Program the data BATs for memory management.  We
     *    must have some type of memory management operating
     *    if we are going to use data cache in copyback mode.
     *    Use the DBAT0 to access the first 256MB of system
     *    memory (cacheing allowed) and DBAT1 to access the MV64360 
     *    registers and FLASH bank A (cache inhibited).
     *    All other DBATs are disabled (2 through 7).
     *    This is necessary in order to configure the controller.  Once
     *    the controller is programmed we no longer need the DBATs.
     *
     * 2. Invalidate the data cache, instruction cache, and TLB entries.
     *
     * 4. Enable the data MMU.
     *
     * 5. Turn on the data cache and instruction cache.
     *
     * 6. Zero out some of the L1 data cache in the address range
     *    occupied by the stack so that the cache tag entires are
     *    present and all future stack access hit the L1 cache and
     *    don't go out to DRAM.
     */

    bl      setDbats

    /* DBAT contents arranged DBAT0L, DBAT0H, DBAT1L, ... */

    /* first 256 MB of RAM starting at 0x00000000 */

    .long   ((0x00000000    & _MMU_LBAT_BRPN_MASK) | _MMU_LBAT_PP_RW |\
            _MMU_LBAT_GUARDED)
    .long   ((0x00000000    &_MMU_UBAT_BEPI_MASK) | _MMU_UBAT_BL_256M |\
            _MMU_UBAT_VS | _MMU_UBAT_VP)

    /* 256 MB MV64360 register and FLASH bank A access starting at 0xF0000000 */

    .long   ((0xF0000000    & _MMU_LBAT_BRPN_MASK) | _MMU_LBAT_PP_RW |\
            _MMU_LBAT_CACHE_INHIBIT | _MMU_LBAT_GUARDED)
    .long   ((0xF0000000    & _MMU_UBAT_BEPI_MASK) | _MMU_UBAT_BL_256M |\
            _MMU_UBAT_VS | _MMU_UBAT_VP)

    /* Disable DBAT2 */

    .long   (0x00000000)
    .long   (0x00000000)

    /* Disable DBAT3 */

    .long   (0x00000000)
    .long   (0x00000000) 

    /* 
     * DBATs 4 - 7
     *
     * It is not necessary to explicitly disable DBATs 4 through 7.  At 
     * power-up these DBATs are disabled - HID0[HIGH_BAT_EN] = 0 by
     * default.
     */

    /* 
     * load DBATs from table above 
     *
     * Synchronization requirements: A DSSALL and sync must precede the
     * mtspr and then a sync and isync must follow.
     */

setDbats:
    DSSALL
    sync
    mfspr   r4,LR
    addi    r4,r4,-4
    lwzu    r3,4(r4)
    mtspr   DBAT0L,r3
    lwzu    r3,4(r4)
    mtspr   DBAT0U,r3
    lwzu    r3,4(r4)
    mtspr   DBAT1L,r3
    lwzu    r3,4(r4)
    mtspr   DBAT1U,r3
    lwzu    r3,4(r4)
    mtspr   DBAT2L,r3
    lwzu    r3,4(r4)
    mtspr   DBAT2U,r3
    lwzu    r3,4(r4)
    mtspr   DBAT3L,r3
    lwzu    r3,4(r4)
    mtspr   DBAT3U,r3
    sync
    isync

    /*
     * Zero out the SDR1 register.  We do this since we do not wish to
     * use the "page table" part of the MMU, but rather the DBATs.
     *
     * Synchronization requirements: A DSSALL and sync must precede a
     * mtspr and then a sync and isync must follow.
     */

    xor     r0,r0,r0
    DSSALL
    sync
    mtspr   SDR1,r0       /* SDR1 - Address of Page Table */
    sync
    isync

    /* invalidate entries within both Translation Lookaside Buffers */

    bl      tlbInval

    /*
     * Now that the MMU has been configured we can enable the data
     * MMU by turning on data address translation.
     *
     * Synchronization requirements: A DSSALL and sync must precede
     * a mtmsr and then a sync and isync must follow.
     */

    mfmsr   r3
    lis     r4,HI(1<<(31-_PPC_MSR_BIT_DR))     /* MSR[DR] = 1 */
    ori     r4,r4,LO(1<<(31-_PPC_MSR_BIT_DR))
    or      r4,r3,r4
    DSSALL
    sync
    mtmsr   r4
    sync
    isync

    /* Turn on data cache */

    bl      dCacheOn

    /* Turn on Instruction Cache */

    bl      iCacheOn

    /* Initialize some memory in the cache stack */

    lis     r3,HI(CACHE_STACK_SIZE)
    ori     r3,r3,LO(CACHE_STACK_SIZE)
    subf    r3,r3,sp

fillLoop:
    dcbz    r0,r3
    addi    r3,r3,_CACHE_ALIGN_SIZE
    cmplw   r3,sp
    blt     fillLoop

    xor     r0,r0,r0                     /* insure r0 is zero */

    /* Program the MV64360 System Memory Controller */

    bl      sysMv64360SdramInit

    or      r15,r3,r3			/* save memory size */

    /*
     * We have been using DBATs up until now.  We will disable the
     * DBATs by turning off address translation.  First we must disable
     * the data cache.  Once the data MMU is disabled we will enable the 
     * data cache once again.  The instruction cache is still enabled.  Then
     * we will scrub the DRAM before disabling both the data and instruction
     * caches - the caches will be disabled when we leave romInit. 
     */

    bl      dCacheOff     /* Disable the data cache */

    /* Disable the data MMU */

    mfmsr   r3
    rlwinm  r3,r3,0,_PPC_MSR_BIT_DR+1,_PPC_MSR_BIT_DR-1  /* MSR[DR] = 0 */
    DSSALL
    sync
    mtmsr   r3
    sync
    isync

#ifdef INCLUDE_ECC

    /* 
     * Turn the data cache back on for the DRAM scrub 
     *
     * This will reduce the time to scrub DRAM.  
     */

    bl      dCacheOn

    /*
     * Scrub memory so that it is in a known state for error
     * correction/detection.
     */

    xor     r3,r3,r3			/* memory starting address = 0 */
    add     r4,r3,r15			/* memory ending address + 1 */

    bl      memoryScrub			/* scrub system memory */

    bl      dCacheOff

#endif /* INCLUDE_ECC */

    /* 
     * Disable Instruction Cache
     *
     * The data and instruction caches should be disabled when exiting
     * romInit.
     */

    bl      iCacheOff

goCEntry:

    /* go to C entry point */

    or      r3,r31,r31
    addi    sp,sp,-FRAMEBASESZ      /* get frame stack */

    /* goto romStart from ../all/bootInit.c */

    lis     r6,HI(romStart)
    ori     r6,r6,LO(romStart)

    lis     r7,HI(romInit)
    ori     r7,r7,LO(romInit)

    lis     r8,HI(ROM_TEXT_ADRS)
    ori     r8,r8,LO(ROM_TEXT_ADRS)

    sub     r6,r6,r7
    add     r6,r6,r8 

    mtlr    r6
    blr

FUNC_END(romInit)

/******************************************************************************
*
* progDevBank2 - Program device bank 2
*
* This routine programs device bank 2 to allow access to system status 
* register 1.  The base address is programmed to 0xFF200000.
*
* RETURNS: N/A
*/

FUNC_BEGIN(progDevBank2)

        mfspr   r16,LR                  /* save return instruction pointer */
        bl      phbInit_b               /* set link register */

        /*
         * device (xport) address decoder for SIO
         */
/* Sergey: following line was modified */
        .long   (MV64360_REG_BASE + CPUIF_BASE_ADDR_ENABLE), 0x000FFEAE
        /* Sergey: .long   (MV64360_REG_BASE + CPUIF_BASE_ADDR_ENABLE), 0x000FFEBE */
        .long   (MV64360_REG_BASE + CPUIF_DEVCS2_BASE_ADDR), \
		(MV64360_DEVCS2_BASE_ADDR >> 16)
        .long   (MV64360_REG_BASE + CPUIF_DEVCS2_SIZE), ((MV64360_DEVCS2_SIZE >> 16) -1 )
        .long   (MV64360_REG_BASE + DVCTL_DEVICE_BANK2_PARAMS), 0x8FCFFFFF
        .long   0       /* end-of-table */

phbInit_b:
        mfspr   r5,LR                    /* r5 = pointer to table */

phbInit_c:
        lwz     r4,0(r5)                /* register offset */
        cmpwi   r4,0                    /* check for end-of-table */
        beq     phbInit_d               /* branch if end-of-table */
        lwz     r3,4(r5)                /* register value */
        stwbrx  r3,r0,r4                /* write value to register */
        lwbrx   r3,r0,r4                /* read back to push data out */
        addi    r5,r5,8                 /* bump to next entry in table */
        eieio
        sync
        b       phbInit_c               /* continue for next table entry */

phbInit_d:

        mtspr   LR,r16                  /* restore return instruction pointer */
        bclr    0x14,0x0                /* return to caller */
FUNC_END(progDevBank2)

/******************************************************************************
*
* tlbInval - Invalidate the Translation Lookaside Buffers
*
* The MPC7455 implements separate 128-entry data and instruction TLBs to
* maximize performance.  Each TLB contains 128 entries organized as a two-way
* set-associative array with 64 sets (64 indexes).  Each tlbie instruction
* invalidates four entries, two for ITLB and two for DTLB.  Since there are
* 64 indexes, we must execute the tlbie instruction 64 times, incrementing
* the index value by one each time, in order to invalidate both TLBs.  
* According to page 2-92 of the MPC7450 RISC Microprocessor Family User's
* Manual, a tlbsync instruction must follow the sequence of 64 tlbie
* instructions.
*
* RETURNS: N/A. 
*/

FUNC_BEGIN(tlbInval)
    li      r4,128
    xor     r3,r3,r3           /* p0 = 0 */
    mtctr   r4                 /* CTR = 64 */

    isync                      /* context sync req'd before tlbie */
tlbLoop:
    tlbie   r3
    sync                       /* sync instr req'd after tlbie */
    addi    r3,r3,0x1000       /* increment bits 14-19 */
    bdnz    tlbLoop            /* decrement CTR, branch if CTR != 0 */
    tlbsync

    bclr    0x14,0x0	       /* return to caller */
FUNC_END(tlbInval)

/******************************************************************************
*
* iCacheOn - Turn Instruction Cache On
*
* This routine enables the instruction cache by setting the Instruction
* Cache Enable (ICE) bit in HID0.  It also flash invalidates the instruction
* cache, via the Instruction Cache Flash Invalidate (ICFI) bit in HID0.
*
* RETURNS: N/A. 
*/

FUNC_BEGIN(_iCacheOn)
FUNC_BEGIN(iCacheOn)
    mfspr   r4, HID0               /* r4 = HID0 */
    ori     r4,r4,(_PPC_HID0_ICE+_PPC_HID0_ICFI) /* Set ICE & ICFI */
    isync
    mtspr   HID0, r4               /* Enable Instr Cache & Inval cache */
    isync                   

    rlwinm  r3,r4,0,(_PPC_HID0_BIT_ICFI+1),(_PPC_HID0_BIT_ICFI-1) /* Clear */
                                                                  /* ICFI */
    mtspr   HID0, r3        
    isync

    bclr    0x14,0x0	           /* return to caller */
FUNC_END(_iCacheOn)
FUNC_END(iCacheOn)

/******************************************************************************
*
* iCacheOff - Turn Instruction Cache Off
*
* This routine disables the instruction cache by unsetting the Instruction
* Cache Enable (ICE) bit in HID0.  It also flash invalidates the instruction
* cache, via the Instruction Cache Flash Invalidate (ICFI) bit in HID0, prior 
* to disabling the instruction cache.
*
* RETURNS: N/A. 
*/

FUNC_BEGIN(_iCacheOff)
FUNC_BEGIN(iCacheOff)
    mfspr   r4,HID0                /* r4 = HID0 */
    ori     r4,r4,(_PPC_HID0_ICE + _PPC_HID0_ICFI) /* Set ICE & ICFI */
    DSSALL                         /* required before changing ICE or ICFI */
    sync                           
    mtspr   HID0,r4                /* Enable inst cache & invalidate cache */
    sync                           /* required after changing ICE or ICFI */
    isync

    rlwinm  r4,r4,0,_PPC_HID0_BIT_ICE+1,_PPC_HID0_BIT_ICE-1    /* clear ICE */
    rlwinm  r3,r4,0,(_PPC_HID0_BIT_ICFI+1),(_PPC_HID0_BIT_ICFI-1) /* clear */
                                                                  /* ICFI */
    DSSALL                         /* required before changing ICE or ICFI */
    sync                      
    mtspr   HID0,r4                /* Disable instruction cache, clear ICFI */
    sync                           /* required after changing ICE or ICFI */
    isync

    bclr    0x14,0x0	           /* return to caller */
FUNC_END(_iCacheOff)
FUNC_END(iCacheOff)

/******************************************************************************
*
* dCacheOn - Turn Data Cache On
*
* This routine enables the data cache by setting the Data Cache Enable (DCE) 
* bit in HID0.  It also flash invalidates the data cache, via the Data Cache 
* Flash Invalidate (DCFI) bit in HID0.
*
* RETURNS: N/A. 
*/

FUNC_BEGIN(_dCacheOn)
FUNC_BEGIN(dCacheOn)
    mfspr   r4,HID0                /* r4 = HID0 */ 
    ori     r4,r4,(_PPC_HID0_DCE + _PPC_HID0_DCFI) /* Set DCE & DCFI */
    DSSALL                         /* required before changing DCE or DCFI */
    sync                           
    mtspr   HID0,r4                /* Enable data cache & invalidate cache */
    sync                           /* required after changing DCE or DCFI */
    isync

    rlwinm  r3,r4,0,(_PPC_HID0_BIT_DCFI+1),(_PPC_HID0_BIT_DCFI-1) /* Clear */
                                                                  /* DCFI */
    DSSALL                         /* required before changing DCE or DCFI */
    sync
    mtspr   HID0, r3               /* Clear data cache invalidate bit */ 
    sync                           /* required after changing DCE or DCFI */
    isync

    bclr    0x14,0x0               /* return to caller */
FUNC_END(_dCacheOn)
FUNC_END(dCacheOn)

/******************************************************************************
*
* dCacheOff - Turn Data Cache Off
*
* This routine disables the data cache by unsetting the Data Cache Enable (DCE)
* bit in HID0.  It also flash invalidates the data cache, via the Data Cache 
* Flash Invalidate (DCFI) bit in HID0, prior to disabling the data cache.
*
* Errata: Error No. 21694 PTE changed (C) bit corruption when data L1
*         cache disabled
* Errata Workaround: Disable the L2 hardware prefetch engine (MSSCR0[L2PFE]=0).
*
* RETURNS: N/A. 
*/

FUNC_BEGIN(_dCacheOff)
FUNC_BEGIN(dCacheOff)
    mfspr   r4,HID0                /* r4 = HID0 */
    ori     r4,r4,(_PPC_HID0_DCE + _PPC_HID0_DCFI) /* Set DCE & DCFI */
    DSSALL                         /* required before changing DCE or DCFI */
    sync                           
    mtspr   HID0,r4                /* Enable data cache & invalidate cache */
    sync                           /* required after changing DCE or DCFI */
    isync

    rlwinm  r4,r4,0,_PPC_HID0_BIT_DCE+1,_PPC_HID0_BIT_DCE-1    /* clear DCE */
    rlwinm  r3,r4,0,(_PPC_HID0_BIT_DCFI+1),(_PPC_HID0_BIT_DCFI-1) /* clear */
                                                                  /* DCFI */
    DSSALL                         /* required before changing DCE or DCFI */
    sync                      
    mtspr   HID0,r4                /* Disable data cache, clear DCFI */
    sync                           /* required after changing DCE or DCFI */
    isync

    addis   r5,r0,0xFFFF           /* r5 = mask for MSSCR0[L2PFE] bits */
    ori     r5,r5,0xFFFC
    mfspr   r4,MSSCR0              /* r4 = MSSCR0 */
    and     r4,r4,r5	           /* r4 = MSSCR0 with L2PFE bits cleared */
    DSSALL                         /* required before changing L2PFE bits */
    sync
    mtspr   MSSCR0,r4              /* clear L2PFE bits */
    sync                           /* required after changing L2PFE bits */
    isync 

    bclr    0x14,0x0               /* return to caller */
FUNC_END(_dCacheOff)
FUNC_END(dCacheOff)

/******************************************************************************
*
* memoryScrub - DRAM initialization.
*
* This routine's purpose is to initialize (i.e., scrub) DRAM, the MV64360 
* protects DRAM by utilizing ECC, so the scrub insures that the entire 
* DRAM array's check bits are initialized to a known state.
*
* ARGUMENTS:
* r3 = starting address of DRAM
* r4 = ending address of DRAM (plus 1)
*
* RETURNS: N/A
*/

FUNC_BEGIN(memoryScrub)
        mfspr   r16,LR                  /* save return instruction pointer */
        or      r13,r3,r3               /* save argument #1, start address */
        or      r14,r4,r4               /* save argument #2, end address */
        xor     r0,r0,r0                /* clear r0 */

        /*
         * Enable floating point support in the processor so that
         * we can scrub memory using 64 bit reads and writes.
         */

        mfmsr   r3
	lis     r4,HI(1<<(31-_PPC_MSR_BIT_FP))
        ori     r4,r4,LO(1<<(31-_PPC_MSR_BIT_FP))
	or      r4,r3,r4
	DSSALL
	sync
        mtmsr   r4
	sync
	isync

        bl      loadScrubData

        .long   0x00000000,0x00000000

loadScrubData:

        mfspr   r4,LR                   /* address of the above table of 0's */
        lfd     0,0(r4)                 /* load the 0's into fpr0 */


        /* Setup scrub loop specifics */

        subf    r18,r13,r14             /* calculate number of bytes */
        rlwinm  r18,r18,29,3,31         /* calculate number of doubles */
        addi    r17,r13,-8              /* starting address munged */
        mtspr   CTR,r18                 /* load number of doubles/words */

        /* Loop through the entire DRAM array, initialize memory */

scrubLoop:

        stfdu   0,8(r17)                /* write contents of fpr0 to memory */
        bc      16,0,scrubLoop          /* branch until counter == 0 */

        sync
        mtspr   CTR,r18                 /* load number of doubles/words */
        addi    r17,r13,-8              /* starting address munged */

readLoop:

        /*
         * It is necessary to read the memory after writing it, to
         * ensure that all data has been flushed from the cache and
         * has been written to memory.
         */

        lfdu    0,8(r17)                /* read memory into fpr0 */
        bc      16,0,readLoop           /* branch until counter == 0 */

scrubExit:

	/* Disable floating point support in the processor before exiting */

	mfmsr   r3
	rlwinm  r3,r3,0,_PPC_MSR_BIT_FP+1,_PPC_MSR_BIT_FP-1
	DSSALL
	sync
	mtmsr   r3
	sync
	isync

        mtspr   LR,r16                  /* restore return instruction pointer */
        bclr    0x14,0x0                /* return to caller */
FUNC_END(memoryScrub)
