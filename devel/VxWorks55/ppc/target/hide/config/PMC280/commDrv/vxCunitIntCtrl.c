/******************************************************************************
*              (c), Copyright, FORCE COMPUTERS INDIA Limited                  *
*                                                                             *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF FORCE COMPUTERS, INC.        *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT *
* OF FORCE OR ANY THIRD PARTY. FORCE RESERVES THE RIGHT AT ITS SOLE DISCRETION*
* TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO FORCE COMPUTERS.       *
* THIS CODE IS PROVIDED "AS IS". FORCE COMPUTERS MAKES NO WARRANTIES, EXPRESS,*
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.  *
*******************************************************************************

*******************************************************************************
* vxCunitIntCtrl.c - MV C-Unit interrupt controller library
*
* DESCRIPTION:
*       This driver provides various interface routines to manipulate and
*       connect the hardware interrupts concerning the MV C-Unit facility.
*
*       Main features:
*        - The controller provides an easy way to hook a C Interrupt Service
*          Routine (ISR) to a specific interrupt caused by the MV C-Unit.
*        - The controller interrupt mechanism provides a way for the programmer
*          to set the priority of an interrupt.
*        - Full interrupt control over the C-Unit facility.
*
*       Overall Interrupt Architecture description:
*        The MV handles interrupts in two stages:
*        STAGE 1: Main Cause register that summarize the interrupts generated 
*                 by each Internal MV unit.
*        STAGE 2: Unit specified cause registers, that distinguish between each
*                 specific interrupt event.
*        This C-Unit Interrupt Controller Driver handles the various interrupts 
*        generated by the second stage.
*
*       All C-Unit various interrupt causes are numbered using the CUNIT_CAUSE
*       enumerator. 
*
*       The driver's execution flow has three phases:
*        1) Driver initialization. This initiation includes hooking driver's 
*           ISR to the MV Interrupt controller. Composed of vxCunitIntCtrlInit() 
*           routine.
*        2) User ISR connecting. Here information about user ISR and interrupt 
*           priority is gathered. Composed of vxCunitIntConnect() routine.
*        3) Interrupt handler. Here an interrupt is being handle by the 
*           Interrupt Handlers (driver's ISR). Composed of cunitIntHandler(), 
*
*       Full API:    
*         vxCunitIntCtrlInit() - Initiate the C-Unit driver.
*         vxCunitIntConnect()  - Connect a user ISR to a C-Unit interrupt event.
*         vxCunitIntEnable()   - Enable a given C-Unit interrupt cause.
*         vxCunitIntDisable()  - Disable a given C-Unit interrupt cause.
*         cunitIntHandler()    - Handle C-Unit interrupts.
*
*       The controller concept is very simple:
*        The Interrupt handler has a table which holds information on 
*        the connected ISR. 
*        An Interrupt generated by one of the C-Unit causes will result a 
*        search through this table in order to allocate the generating 
*        interrupt cause.
*        After the initiating interrupt cause is identify, the ISR reside in 
*        the same table entry is executed.
*       
*       The controller interface also includes interrupt control routines which
*       enable/disable specific interrupts: vxCunitIntDisable() and
*       vxCunitIntEnable().
*   
* DEPENDENCIES:
*		MV Interrupt Control Driver.
*       MPSC module.
*		VxWorks.
*
******************************************************************************/

/* includes */
#include "sdma.h"
#include "vxCunitIntCtrl.h" 

#ifdef PMC280_DEBUG_UART_VX
#include "dbgprints.h"
#endif /* PMC280_DEBUG_UART_VX */

#ifdef PMC280_DUAL_CPU
#include "gtSmp.h"
#endif /* PMC280_DUAL_CPU */
#include "config.h"

#ifdef INCLUDE_WINDVIEW
#include "private/funcBindP.h"
#include "private/eventP.h"
#include "wvLib.h"
#endif
/* defines  */
#define CUNIT_CAUSE_VALUE   REG_CONTENT(CUNIT_INTERRUPT_CAUSE_REG)
#define CUNIT_MASK_VALUE    REG_CONTENT(CUNIT_INTERRUPT_MASK_REG)

#define INVALID_CAUSE(cause)    \
                ((cause) <= CUNIT_CAUSE_START || CUNIT_CAUSE_END <= (cause))

/* typedefs */


/* locals   */

LOCAL GT_ISR_ENTRY cunitCauseArray[6];/* Interrupt connection data storage    */
LOCAL int cunitCauseCount = 0;        /* Accumulates the number of connection */ 
LOCAL bool vxCunitIntCtrlInitialized = false;
LOCAL void  cunitIntHandler(void);    /* C-Unit event handler                 */

/*******************************************************************************
* vxCunitIntCtrlInit - Initiating the C-Unit Interrupt Controller driver.
*
* DESCRIPTION:
*       This routines connects the drivers interrupt handlers to its 
*       corresponding bit in the MV main Interrupt Controller using the
*       gtIntConnect() routine.
*
* INPUT:
*       None.
*
* OUTPUT:
*       The C-Unit cause & mask register are initiated (set to zero).
*       Driver's ISR are connected to the main cause register. 
*
* RETURN:
*       None.
*
*******************************************************************************/
void vxCunitIntCtrlInit(void)
{
#ifdef PMC280_DUAL_CPU
    if(!frcWhoAmI())
    {
#ifdef PMC280_DEBUG_UART_VX
        dbg_puts0("CPU0: Entering vxCunitIntCtrlInit\n");
#endif /* PMC280_DEBUG_UART_VX */

        if(vxCunitIntCtrlInitialized)
           return;

        CUNIT_CAUSE_VALUE = 0;  /* Clean Cause register */
        CUNIT_MASK_VALUE  = 0;  /* Clean Mask register  */
    
        /* Connect the user ISR to the C-Unit bits in the main cause register */
        gtIntConnect(SERIAL_ERR  ,cunitIntHandler, 0, 9);

        /* Unmask those bits */
        gtIntEnable(SERIAL_ERR);

        vxCunitIntCtrlInitialized = true;

#ifdef PMC280_DEBUG_UART_VX
        dbg_puts0("CPU0: Exiting vxCunitIntCtrlInit\n");
#endif /* PMC280_DEBUG_UART_VX */
    }
#else
    if(vxCunitIntCtrlInitialized)
       return;

    CUNIT_CAUSE_VALUE = 0;  /* Clean Cause register */
    CUNIT_MASK_VALUE  = 0;  /* Clean Mask register  */
    
    /* Connect the user ISR's to the C-Unit bits in the main cause register */
    gtIntConnect(SERIAL_ERR  ,cunitIntHandler, 0, 9);

    /* Unmask those bits */
    gtIntEnable(SERIAL_ERR);

    vxCunitIntCtrlInitialized = true;
#endif /* PMC280_DUAL_CPU */
}


/*******************************************************************************
* vxCunitIntConnect - connect a C routine to a specific C-Unit interrupt.
*
* DESCRIPTION:
*       This routine connects a specified user ISR to a specified MV C-Unit 
*       interrupt cause.
*       Each ISR handler has its own user ISR array. 
*       The connection is done by setting the desired routine and parameter in 
*       the cunitCauseArray cause array:
*         1) Check for existing connection for the cause bit in the table.
*         2) Connecting the user ISR by inserting the given parameters into 
*           an entry according to the user ISR given priority.
*
* INPUT:
*		MPSC_NUM    mpscNum - MPSC channel mucker. See MPSC_NUM.
*       CUNIT_CAUSE   cause - C-Unit interrupt cause as defined in CUNIT_CAUSE.
*       VOIDFUNCPTR routine - User Interrupt Service Routine.
*       int       parameter - user ISR parameter.
*       int           prio  - Interrupt handling priority where 0 is highest.
*
* OUTPUT:
*       An appropriate table entry is filled.
*
* RETURN:
*       OK    - if the table entry of the cause bit was filled. 
*       ERROR - if any argument is invalid or connected cause is already 
*                found in table.
*
*******************************************************************************/
STATUS vxCunitIntConnect(MPSC_NUM mpscNum,
                       CUNIT_CAUSE cause,
                       VOIDFUNCPTR routine,
                       int parameter,
                       int prio)
{
    int i, sysIntOldConfig;

    /* Make sure that this is an atomic operation */
    sysIntOldConfig = intLock();

    /* Check the validity of the parameters */
    if(routine == NULL)
    {
        logMsg("\nvxCunitIntConnect: NULL pointer routine\n",0,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }
    else if(prio < 0)
    {
        logMsg("\nvxCunitIntConnect: Invalid interrupt priority\n",0,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }
    else if(INVALID_CAUSE(cause))
    {
        logMsg("\nvxCunitIntConnect: Invalid cause %d\n",cause,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }

	/* Calculate the cause bit location in the register according to mpscNum */ 
    cause += CAUSE_OFFSET + (mpscNum * 8);

    /* Scan the table to check for double connection to the same cause bit */
    for(i = cunitCauseCount; i >= 0; i--)
        if(cunitCauseArray[i].causeBit == SWAP_CAUSE_BIT(cause))
        {
            logMsg("\nvxCunitIntConnect(cause %d): ERROR\nAn attempt to \
                   reconnect ISR to an existing cause bit.\n", cause,0,0,0,0,0); 
            intUnlock(sysIntOldConfig);
            return ERROR;
        }

    /* Connection phase */
    for(i = cunitCauseCount; i >= 0; i--)
    {
        if(i == 0 || cunitCauseArray[i-1].prio < prio) /* Make connection */
        {
            cunitCauseArray[i].causeBit = SWAP_CAUSE_BIT(cause);
            cunitCauseArray[i].userISR  = routine;
            cunitCauseArray[i].arg      = parameter;
            cunitCauseArray[i].prio     = prio;
            cunitCauseCount++;
            break;
        }
        else
        {
            /* Push the low priority connection down the table */
            cunitCauseArray[i].causeBit = cunitCauseArray[i-1].causeBit;
            cunitCauseArray[i].userISR  = cunitCauseArray[i-1].userISR;
            cunitCauseArray[i].arg      = cunitCauseArray[i-1].arg;
            cunitCauseArray[i].prio     = cunitCauseArray[i-1].prio;    
        }
    }

    intUnlock(sysIntOldConfig);
    return OK;
}

/*******************************************************************************
* vxCunitIntEnable - Enable a C-Unit interrupt
*
* DESCRIPTION:
*       This routine unmasks a specified C-Unit interrupt cause in the   
*       mask register.
*       The routine will preform argument validity check. 
*
* INPUT:
*		MPSC_NUM mpscNum  - MPSC channel mucker. See MPSC_NUM.
*       CUNIT_CAUSE cause - C-Unit interrupt cause as defined in CUNIT_CAUSE.
*
* OUTPUT:
*       The appropriate bit in the C-Unit mask register is set.
*
* RETURN:
*       OK    - If the bit was unmasked
*       ERROR - if the bit was invalid
*
*******************************************************************************/
STATUS vxCunitIntEnable(MPSC_NUM mpscNum, CUNIT_CAUSE cause)
{
    if (INVALID_CAUSE(cause))
    {
        logMsg("\nvxCunitIntEnable: Invalid cause %d\n", cause,0,0,0,0,0);
        return ERROR;
    }
    
	/* Calculate the cause bit location in the register according to mpscNum */ 
    cause += CAUSE_OFFSET + (mpscNum * 8);

    CUNIT_MASK_VALUE |= SWAP_CAUSE_BIT(cause);

    return OK;
}

/*******************************************************************************
* vxCunitIntDisable - Disable a C-Unit interrupt
*
* DESCRIPTION:
*       This routine masks a specified C-Unit interrupt cause in the
*       C-Unit mask register.
*       The routine will preform argument validity check. 
*
* INPUT:
*		MPSC_NUM mpscNum  - MPSC channel number. See MPSC_NUM.
*       CUNIT_CAUSE cause - C-Unit interrupt cause as defined in CUNIT_CAUSE. 		
*
* OUTPUT:
*       The appropriate bit in the C-Unit mask register is reset.
*
* RETURN:
*       OK    - If the bit was masked
*       ERROR - if the bit was invalid
*
*******************************************************************************/
STATUS vxCunitIntDisable(MPSC_NUM mpscNum, CUNIT_CAUSE cause)
{
    if (INVALID_CAUSE(cause))
    {
        logMsg("\nvxCunitIntDisable: Invalid cause %d\n", cause,0,0,0,0,0);
        return ERROR;
    }
    
	/* Calculate the cause bit location in the register according to mpscNum */ 
    cause += CAUSE_OFFSET + (mpscNum * 8);

    CUNIT_MASK_VALUE &= SWAP_CAUSE_BIT(cause);
    
    return OK;
}

/*******************************************************************************
* vxCunitIntClear - Clear a C-Unit interrupt
*
* DESCRIPTION:
*       This routine clears a specified C-Unit interrupt in the cause register.
*       The routine will preform argument validity check. 
*
* INPUT:
*		MPSC_NUM mpscNum  - MPSC channel number. See MPSC_NUM.
*       CUNIT_CAUSE cause - C-Unit interrupt cause as defined in CUNIT_CAUSE. 		
*
* OUTPUT:
*       The appropriate bit in the C-Unit cause register is reset.
*
* RETURN:
*       OK    - If the bit was reset
*       ERROR - if the bit was invalid
*
*******************************************************************************/
STATUS  vxCunitIntClear(MPSC_NUM mpscNum, CUNIT_CAUSE cause)
{
    if (INVALID_CAUSE(cause))
    {
        logMsg("\vxCunitIntClear: Invalid cause %d\n", cause,0,0,0,0,0);
        return ERROR;
    }
    
	/* Calculate the cause bit location in the register according to mpscNum */ 
    cause += CAUSE_OFFSET + (mpscNum * 8);

    /* Reset mask bit to disable interrupt */
	CUNIT_CAUSE_VALUE = ~SWAP_CAUSE_BIT(cause);
    
    return OK;
}

/*******************************************************************************
* cunitIntHandler - interrupt controller handler.
*
* DESCRIPTION:
*       This routine handles the C-Unit error report interrupts. 
*       This routine is hooked to the MV device main interrupt controller.
*		As soon as an C-Unit error report interrupt signal is active in the MV
*		main interrupt cause, the CPU analyzes the C-Unit Interrupt Cause 
*		register in order to locate the originating interrupt event. 
*       Then the routine calls the user specified service routine for that 
*       interrupt cause.
*       The function scans the cunitCauseArray[] (cunitCauseCount valid entries)
*       trying to find a hit in the cunitCauseArray cause table.
*       When found, the ISR in the same entry is executed.
*		The routine will acknowledge the interrupt.
*
* INPUT:
*       None.
*
* OUTPUT:
*       If a cause bit is active and it's connected to an ISR function,
*       the function will be called and interrupt is acknowledge.
*
* RETURN:
*       None.
*
*******************************************************************************/
void cunitIntHandler (void)
{
    int     i; 
    unsigned int causeAndMask;

    /* Cause bit is active if an interrupt occurred and the bit is unmasked. */
    causeAndMask = CUNIT_CAUSE_VALUE & CUNIT_MASK_VALUE ;
#ifdef INCLUDE_WINDVIEW
	WV_EVT_INT_ENT(SERIAL_ERR); 
#endif 


    for(i = 0; i < cunitCauseCount; i++)

        if(causeAndMask & cunitCauseArray[i].causeBit)
        {
            /* Reset the interrupt cause bit in the C-Unit cause register */
            CUNIT_CAUSE_VALUE = ~(cunitCauseArray[i].causeBit);

            /* Perform the ISR */
            (*cunitCauseArray[i].userISR) (cunitCauseArray[i].arg);
        }                                                            
}
