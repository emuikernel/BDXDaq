/******************************************************************************
*              (c), Copyright, MOTOROLA  INC - ECC                  *
*                                                                             *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MOTOROLA , INC.        *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT *
* OF MOTOROLA   OR ANY THIRD PARTY. MOTOROLA   RESERVES THE RIGHT AT ITS SOLE DISCRETION*
* TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MOTOROLA .       *
* THIS CODE IS PROVIDED "AS IS". MOTOROLA  MAKES NO WARRANTIES, EXPRESS,*
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.  *
*******************************************************************************


*******************************************************************************
* gtIntControl.c - Main interrupt controlling library
*
* DESCRIPTION:
*     This driver provides various interface routines to manipulate and connect
*     to external hardware interrupts concerning the GT various interrupt cause
*     Main features:
*       - This controller is generic. It is compatible with all the GT
*         interrupts and maintains a way to handle multiple interrupts.
*       - The controller provides an easy way to hook a C Interrupt Service
*         Routine (ISR) to a specific interrupt caused by the GT.
*       - The controller interrupt mechanism provides a way for the programmer
*         to set the priority of an interrupt.
*       - Full interrupt control over the GT.
*
*						Main Interrupt Cause (High/Low)
*			   |--------------------------------------------|
*			   |   |   |Tmr|   |   |   |  .........         |   STAGE 1
*			   |---------|----------------------------------|
*			   	 		 |
*			   			 |
*			   			 |
*		|------------------------------------|
*		|  Timer/Counter Interrupt cause reg |   STAGE 2
*		|------------------------------------|			   
*			   
*			   
*       Architecture description:
*       The GT handles interrupts in two stages:
*       STAGE 1: Main Cause register that summarize the interrupts generated by
*                each Internal GT unit.
*       STAGE 2: Unit specified cause registers, that distinguish between each
*                specific interrupt event.
*       This Interrupt Controller Driver handles the various interrupts
*       generated by the first stage.
*
*       This architecture restrict each unit driver to support the unit
*       interrupts.
*       For example, for hooking an ISR to Timer/Counter 0 expiration event, the
*     user has to refer to the Timer/Counter unit driver and use its driver API.
*
*       This Interrupt Controller driver supports the CPU Interrupt pin only.
*       For supporting the rest of the GT Interrupts pins modify the driver 
*       as needed.
*
*       All first stage interrupt causes are numbered using the GT_INT_CAUSE
*       enumerator. Thus there are 64 interrupts causes (some of them are
*       Reserved) divided into two groups: The High (cause 0 - 31) and Low
*       (cause 32 - 63). In order for the user to set the interrupt masking
*       configuration as he wish, all he has to do is define the group of
*       interrupt cause he would like to have on the same pin. For example if a
*       user would like to have causes 0 - 15 generating interrupts only on CPI
*       Int0 pin he must define:
*
*       #define CPU_INT_HIGH_CAUSE	cause >= 0 && cause <=15
*
*       This will cause to those causes (enable, disable and handling) to be
*       referred to CPU pin only which means if any of those bits are active and
*       not masked they will generate an interrupt on pin CPU.
*     The macro CPU_INT_HIGH_CAUSE can define interrupt cause only between 0-31.
*     The macro CPU_INT_LOW_CAUSE can define interrupt cause only between 32-63.
*
*       The driver's execution flow has three phases:
*       1) Driver initialization. This initiation includes hooking driver's ISR
*          to System Interrupt Vector. Composed of gtIntCtrlInit() routine.
*       2) User ISR connecting. Here information about user ISR and interrupt 
*          priority is gathered. Composed of gtIntConnect() routine.
*       3) Interrupt handling. Here an interrupt is being handle by the
*          Interrupt Handlers (driver's ISR). Composed of gtIntCpuHigh(), 
*          and gtIntCpuLow(), gtIntCpuSelect(), gtIntCpuInt0(), gtIntCpuInt1().
*
* Full API:
*       gtIntCtrlInit()  - Initiate the interrupt controller.
*       gtIntConnect()   - Connect a user ISR to interrupt cause bit.
*       gtIntDisconnect()- Disconnect a user ISR from the cause bit.
*       gtIntEnable() 	 - Enable a given interrupt cause bit.
*       gtIntDisable() 	 - Disable a given interrupt cause bit.
*       gtIntCpuLow() 	 - Handle the CPU Low cause interrupts.
*       gtIntCpuHigh() 	 - Handle the CPU High cause interrupts.
*       gtIntCpuSelect() - Handle the CPU Select interrupts.
*       gtIntCpuInt0() 	 - Handle the CPU Int0 interrupts.
*       gtIntCpuInt1() 	 - Handle the CPU Int1 interrupts.
*  
*   The controller concept is very simple. When a GT interrupt is pending 
*   the controller scan the cause register ISR array for the cause bit. 
*   For example interrupt pending on CPU High cause register will result 
*   the scan of gtIntCpuHighArray[].
*   On each array entry scanned, a logical AND is preformed with the appropriate 
*   mask register, the cause register and the causeBit field of the user ISR
*   array. If the result is OK, the ISR on the same array entry will be executed.
*
*   The controller interface also includes interrupt control routines which can 
*   enable/disable specific interrupts: gtIntDisable() and gtIntEnable().
*
* NOTE: The First layer Cause registers (HIGH and LOW) bits are read only. To
*       clear an interrupt cause, the user needs to clear (write 0) to the
*       active bit(s) in the sub units cause register.
*
* DEPENDENCIES:
*       None.
*
******************************************************************************/

/* includes */
#include "vxWorks.h"
#include "gtIntControl.h"
#include "arch/ppc/excPpcLib.h"
#ifdef PMC280_DUAL_CPU
#include "gtSmp.h"
#endif /* PMC280_DUAL_CPU */

/* defines */

/* User - Define Cause bit distribution. */
#define CPU_INT_LOW_CAUSE	   (00 <= cause && cause <= 31)
#define CPU_INT_HIGH_CAUSE     (32 <= cause && cause <= 63)

#define CPU_INT0_CAUSE  	    0   /* Multiplexed CPU pin 0 not used */
#define CPU_INT1_CAUSE  	    0   /* Multiplexed CPU pin 1 not used */
#define CPU_INT2_CAUSE  	    0   /* Multiplexed CPU pin 2 not used */
#define CPU_INT3_CAUSE  	    0	/* Multiplexed CPU pin 3 not used */

/* User - Define the Mask selection for the CPU Int 0,1,2,3 pins */
#define CPU_INT0_MASK_SELECT	0   /* Multiplexed CPU pin 0 not used */
#define CPU_INT1_MASK_SELECT	0   /* Multiplexed CPU pin 1 not used */
#define CPU_INT2_MASK_SELECT	0   /* Multiplexed CPU pin 2 not used */
#define CPU_INT3_MASK_SELECT	0   /* Multiplexed CPU pin 3 not used */


#define SELECT_HIGH_CAUSE      0x00000040 /* Select Cause reg bit 30 (swapped)*/
#define SELECT_BOTH_MAIN_HIGH  0x00000080 /* Select Cause reg bit 31 (swapped)*/

#define LOW_CAUSE_REG             REG_CONTENT(MAIN_INTERRUPT_CAUSE_LOW )
#define HIGH_CAUSE_REG            REG_CONTENT(MAIN_INTERRUPT_CAUSE_HIGH)

#define CPU_LOW_MASK_REG(cpu)     \
                           REG_CONTENT(CPU_INTERRUPT0_MASK_LOW     + ((cpu)<<5))
#define CPU_HIGH_MASK_REG(cpu)    \
                           REG_CONTENT(CPU_INTERRUPT0_MASK_HIGH    + ((cpu)<<5))
#define CPU_SELECT_CAUSE_REG(cpu) \
                           REG_CONTENT(CPU_INTERRUPT0_SELECT_CAUSE + ((cpu)<<5))

#define INVALID_CAUSE(cause)    \
                      ((cause) <= MAIN_CAUSE_START || MAIN_CAUSE_END <= (cause))

/* local globals */ 

/*Each GT_ISR_ENTRY array accumulates user ISR information regarding a cause 
  register. For example gtIntCpuHighArray[] will accumulate all user ISR 
  connection done to CPU Main High cause register.*/
LOCAL GT_ISR_ENTRY gtIntCpuLowArray[32];
LOCAL GT_ISR_ENTRY gtIntCpuHighArray[32];

/*Each counter accumulate the number of connection done to the above table.
  For example gtIntCpuHighCount counts the number of connection done to 
  gtIntCpuHighArray. */
LOCAL int gtIntCpuLowCount;  
LOCAL int gtIntCpuHighCount; 

/* Interrupt Controller's ISR */
__inline__ static void gtIntCpuLow   (void);
__inline__ static void gtIntCpuHigh  (void);
__inline__ static void gtIntCpuSelect(void);


/*******************************************************************************
* gtIntCtrlInit - Initiating the GT interrupt controller.
*
* DESCRIPTION:
*       connects the drivers interrupt handlers, according to the HW 
*       wiring of the system, to the system interrupt vector using the VxWorks 
*       excIntConnect() routine. 
*       The possible ISRs are:
*       gtIntCpuHigh()  for using CPU pin which is dedicated to High int causes.
*       gtIntCpuLow() 	for using CPU pin which is dedicated to Low  int causes.
*       gtIntCpuSelect() for using CPU pin which is dedicated to both High and
*                        Low int causes.
*
* INPUT:
*       None.
*
* OUTPUT:
*       Driver's ISR is connected to the CPU's external exception vector.
*
* RETURN:
*       None.
*
*******************************************************************************/
void gtIntCtrlInit(void)
{
    /* connect the interrupt demultiplexer to the PowerPC external exception */
    excIntConnect ((VOIDFUNCPTR *) _EXC_OFF_INTR, gtIntCpuSelect); 
}

/*******************************************************************************
* gtIntConnect - connect a C routine to a specific GT interrupt.
*
* DESCRIPTION:
*       This routine connects a specified user ISR to a specified GT interrupt
*       cause (High or Low). Each ISR handler has its own user ISR array.
*       The connection is done by setting the desired routine and parameter in
*       the corresponding cause array (i.e. gtIntCpuHighArray[]):
*       1) Finding the origin register of the cause bit - High, Low,
*          CPU Int0,1,2,3 (done according to the cause bit number). 
*       2) Check for existing connection of the same cause bit in the ISR table.
*       3) Connecting the user ISR by inserting the given parameters into an
*          entry according to the user ISR given priority.
*
* INPUT:
*       cause    : GT interrupt cause, defined by enum. 
*       routine  : user ISR.
*       parameter: user ISR parameter.
*       prio     : Interrupt handling priority where 0 is highest.    
*
*
* OUTPUT:
*       If succeeded, a C routine connected to a specific GT interrupt.
*
* RETURN:
*       OK    if succeeded 
*       ERROR if cause argument is wrong or connected cause is already found
*             in table.
*
*******************************************************************************/
STATUS gtIntConnect(GT_INT_CAUSE cause, VOIDFUNCPTR routine, int parameter,
                    int prio)
{
    GT_ISR_ENTRY *intCauseArray; /* pointer to the selected cause table    */
    int *intConnectCount;        /* pointer to the table connection counter*/
    int i, sysIntOldConfig;

    sysIntOldConfig = intLock();
    /* check for cause parameter validity */
    if(routine == NULL)
    {
        logMsg("\ngtIntConnect(VOIDFUNCPTR routine): NULL pointer routine\n",
               0,0,0,0,0,0);
	intUnlock(sysIntOldConfig);
        return ERROR;

    }
    else if(prio < 0)
    {
        logMsg("\ngtIntConnect(int prio): Invalid interrupt priority\n",
               0,0,0,0,0,0);
	intUnlock(sysIntOldConfig);
        return ERROR;
    }
    else if(CPU_INT_LOW_CAUSE)
    {
        intCauseArray   = gtIntCpuLowArray;
        intConnectCount = &gtIntCpuLowCount;
    }
    else if(CPU_INT_HIGH_CAUSE) /* Connect cause to CPU interrupt Mask High */
    {
        intCauseArray   = gtIntCpuHighArray;
        intConnectCount = &gtIntCpuHighCount;
    }
    else
    {
        logMsg("\ngtIntConnect(GT_INT_CAUSE %d): Invalid GT cause\n",
               cause,0,0,0,0,0);
	intUnlock(sysIntOldConfig);
        return ERROR;
    }
    /* Scan the table to check for double connection to the same cause bit */
    for(i = *intConnectCount; i >= 0; i--)
        if(intCauseArray[i].causeBit == SWAP_CAUSE_BIT(cause))
        {
            logMsg("\ngtIntConnect(cause %d): ERROR\n",cause,0,0,0,0,0);
            logMsg("   An attempt to reconnect ISR to an existing cause bit.\n",
                   0,0,0,0,0,0);
	    intUnlock(sysIntOldConfig); 
            return ERROR;
        }

    /* Connection phase */
    for(i = *intConnectCount; i>=0; i--)
    {
        if(i == 0 || intCauseArray[i-1].prio < prio) /* Make connection */
        {
            intCauseArray[i].causeBit = SWAP_CAUSE_BIT(cause);
            intCauseArray[i].userISR  = routine;
            intCauseArray[i].arg      = parameter;
            intCauseArray[i].prio     = prio;
            (*intConnectCount)++;
            break;
        }
        else
        {
            /* Push the low priority connection down the table */
            intCauseArray[i].causeBit = intCauseArray[i-1].causeBit;
            intCauseArray[i].userISR  = intCauseArray[i-1].userISR;
            intCauseArray[i].arg      = intCauseArray[i-1].arg;
            intCauseArray[i].prio     = intCauseArray[i-1].prio;    
        }
    }
    intUnlock(sysIntOldConfig);
    return OK;
}

/*******************************************************************************
* gtIntDisconnect - disconnect a C routine from a specific GT interrupt.
*
* DESCRIPTION:
*       This routine disconnects a user ISR from a specified GT interrupt
*       cause (High or Low). Each ISR handler has its own user ISR array.
*       The disconnction is done by:
*       1) Finding the origin register of the cause bit - High, Low,
*          CPU Int0,1,2,3 (done according to the cause bit number). 
*       2) Check for the existens of such connection in the ISR table.
*       3) finding the correct entry in the table (of the desierd cause bit).
*       4) moving all other ISR connections up one place in the array. 
*
* INPUT:
*       GT_INT_CAUSE cause    : GT interrupt cause, defined by enum. 
*
* OUTPUT:
*       If succeeded, a specific GT interrupt is no longer connected to any ISR,
*       that means that a C routine can be connected to that specific GT
*       interrupt.
*
* RETURN:
*       OK    if succeeded 
*       ERROR Invalid GT cause or cause was never connected in the table.
*
*******************************************************************************/
STATUS gtIntDisconnect(GT_INT_CAUSE cause)
{
    GT_ISR_ENTRY *intCauseArray; /* pointer to the selected cause table    */
    int *intConnectCount = 0;    /* pointer to the table connection counter*/
    int i, sysIntOldConfig;
    int oldIndex = -1;

    sysIntOldConfig = intLock();
    /* check for cause parameter validity */
    if(CPU_INT_LOW_CAUSE)
    {
        intCauseArray = gtIntCpuLowArray;
        intConnectCount = &gtIntCpuLowCount;
    }
    else if(CPU_INT_HIGH_CAUSE) /* Connect cause to CPU interrupt Mask High */
    {
        intCauseArray = gtIntCpuHighArray;
        intConnectCount = &gtIntCpuHighCount;
    }
    else if(0 == *intConnectCount)
    {
        logMsg("\ngtIntDisconnect(GT_INT_CAUSE %d): Table is empty\n",
               cause,0,0,0,0,0);
	intUnlock(sysIntOldConfig);
        return ERROR;
    }
    else
    {
        logMsg("\ngtIntDisconnect(GT_INT_CAUSE %d): Invalid GT cause\n",
               cause,0,0,0,0,0);
	intUnlock(sysIntOldConfig);
        return ERROR;
    }
    /* Scan the table to find and remove connection to that cause bit */
    for(i = 0 ; i <= *intConnectCount; i++)
        if(intCauseArray[i].causeBit == SWAP_CAUSE_BIT(cause))
        {
            oldIndex = i;
            break;
        }

    if(-1 == oldIndex)
    {
        logMsg("\ngtIntDisconnect(GT_INT_CAUSE %d): cause not found in table\n",
               cause,0,0,0,0,0);
	intUnlock(sysIntOldConfig);
        return ERROR;
    }

    /* Disonnection phase */
    for(i = oldIndex ; i <= *intConnectCount; i++)
    {
        if(i == *intConnectCount) /* last plase */
        {
            intCauseArray[i].causeBit = 0;
            intCauseArray[i].userISR  = NULL;
            intCauseArray[i].arg      = 0;
            intCauseArray[i].prio     = 0;
            (*intConnectCount)--;
            break;
        }
        else
        {
            /* Push All connection one place up the table */
            intCauseArray[i].causeBit = intCauseArray[i+1].causeBit;
            intCauseArray[i].userISR  = intCauseArray[i+1].userISR;
            intCauseArray[i].arg      = intCauseArray[i+1].arg;
            intCauseArray[i].prio     = intCauseArray[i+1].prio;    
        }
    }
    gtIntDisable(cause);
    intUnlock(sysIntOldConfig);
    return OK;
}
/*******************************************************************************
* gtIntEnable - enable a GT interrupt level (High and Low causes)
*
* DESCRIPTION:
*       This routine unmasks a specified GT interrupt on the appropriate mask 
*       register. Analyzing the correct mask register out of the given cause
*       is done same way as in gtIntConnect(). The routine will preform argument
*       validity check. This routine also helps to avoid the situation where an
*       enabled interrupt has no ISR connected.
*
* INPUT:
*       GT_INT_CAUSE cause    : GT interrupt cause, defined by enum. 
*
* OUTPUT:
*       The appropriate bit in the appropriate mask register is set.
*
* RETURN:
*       The former GT interrupt mask register value.
*
* SEE ALSO:
*       gtIntDisable()
*
*******************************************************************************/
unsigned int gtIntEnable(GT_INT_CAUSE cause)
{
    UINT32 lastMaskReg;               /* The last value of the Mask register */
    volatile UINT32 *maskReg;         /* The issued mask register */
    int cpu = 0;

#ifdef PMC280_DUAL_CPU
    if(frcWhoAmI())
        cpu = 1;
    else
        cpu = 0;
#endif /* PMC280_DUAL_CPU */

    if(CPU_INT_LOW_CAUSE)
        maskReg = &CPU_LOW_MASK_REG(cpu);

    else if(CPU_INT_HIGH_CAUSE)  /* cause origin is Main Interrupt High Cause */
        maskReg = &CPU_HIGH_MASK_REG(cpu);

    else
    {
        logMsg("\ngtIntEnable(GT_INT_CAUSE %d): Invalid GT cause\n",
                cause,0,0,0,0,0);
        return ERROR;
    }
    lastMaskReg = *maskReg;
    *maskReg |= SWAP_CAUSE_BIT(cause);
    return lastMaskReg;
}

/*******************************************************************************
* gtIntDisable - Disable a GT interrupt	( High, and Low causes)
*
* DESCRIPTION:
*       This routine masks a specified GT interrupt out of High and Low causes
*       on the appropriate mask register. Analyzing the correct mask register
*       out of the given cause is done same way as in gtIntConnect().
*       The routine will preform argument validity check. 
*
* INPUT:
*       GT_INT_CAUSE cause    : GT interrupt cause, defined by enum. 
*
* OUTPUT:
*       The appropriate bit in the appropriate mask register is reset.
*
* RETURN:
*       The former GT interrupt mask register value.
*
* SEE ALSO:
*       gtIntEnable()
*
*******************************************************************************/
unsigned int gtIntDisable(GT_INT_CAUSE cause)
{
    UINT32 lastMaskReg;             /* The last value of the Mask register */
    volatile UINT32 *maskReg;       /* The issued mask register */
    int cpu = 0;

#ifdef PMC280_DUAL_CPU
    if(frcWhoAmI())
        cpu = 1;
    else
        cpu = 0;
#endif /* PMC280_DUAL_CPU */

    if(CPU_INT_LOW_CAUSE)
        maskReg = &CPU_LOW_MASK_REG(cpu);

    else if(CPU_INT_HIGH_CAUSE)  /* cause origin is Main Interrupt High Cause */
        maskReg = &CPU_HIGH_MASK_REG(cpu);

    else
    {
        logMsg("\ngtIntDisable(GT_INT_CAUSE %d): Invalid GT cause\n",
                cause,0,0,0,0,0);
        return ERROR;
    }
    lastMaskReg = *maskReg;
    *maskReg &= ~(SWAP_CAUSE_BIT(cause));
    return lastMaskReg;
}

/*******************************************************************************
* gtIntCpuLow - GT Low Main Interrupt controller routine.
*
* DESCRIPTION:
*      This routine handles the GT interrupts from the GT CPU Low Main Interrupt 
*       Cause. As soon as the interrupt signal is active the CPU analyzes the GT 
*       cause register in order to locate the originating interrupt event.
*       Then the routine calls the user specified service routine for that
*       interrupt cause. The function scans the gtIntCpuLowArray[] 
*       (gtIntCpuLowCount valid entries) trying to find a hit in the Low cause
*       table. When found, the ISR in the same entry is executed.
*       Interrupts are acknowledge in the ISR connected to this driver.
*
* INPUT:
*       None.
*
* OUTPUT:
*       Executing the ISR that is connected to the bit of the interrupt in the 
*       Low cause table, if found such bit in the table.
*
* RETURN:
*       None.
*
*******************************************************************************/
__inline__ void gtIntCpuLow (void)
{
    int          i, cpu = 0;
    unsigned int causeAndMask; /* Read relevant cause */

#ifdef PMC280_DUAL_CPU
    if(frcWhoAmI())
        cpu = 1;
    else
        cpu = 0;
#endif /* PMC280_DUAL_CPU */

    causeAndMask = LOW_CAUSE_REG & CPU_LOW_MASK_REG(cpu);

    for(i = 0; i < gtIntCpuLowCount; i++)
        /* Check ISR array hit  */
        if(causeAndMask & gtIntCpuLowArray[i].causeBit)
            (*gtIntCpuLowArray[i].userISR) (gtIntCpuLowArray[i].arg);
}

/*******************************************************************************
* gtIntCpuHigh - GT High Main Interrupt controller routine.
*
* DESCRIPTION:
*       This routine handles the GT interrupts from the GT CPU High Main
*       Interrupt Cause. As soon as the interrupt signal is active the CPU
*       analyzes the GT cause register in order to locate the originating
*       interrupt event. Then the routine calls the user specified service
*       routine for that interrupt cause. The function scans the
*       gtIntCpuHighArray[] (gtIntCpuHighCount valid entries) trying to find a
*       hit in the High cause table. When found, the ISR in the same entry is
*       executed.Interrupts are acknowledge in the ISR connected to this driver.
*
* INPUT:
*       None.
*
* OUTPUT:
*       Executing the ISR that is connected to the bit of the interrupt in the 
*       High cause table, if found such bit in the table.
*
* RETURN:
*       None.
*
*******************************************************************************/
__inline__ void gtIntCpuHigh(void)
{
    int          i, cpu = 0;
    unsigned int causeAndMask; /* Read relevant cause */

#ifdef PMC280_DUAL_CPU
    if(frcWhoAmI())
        cpu = 1;
    else
        cpu = 0;
#endif /* PMC280_DUAL_CPU */

    causeAndMask = HIGH_CAUSE_REG & CPU_HIGH_MASK_REG(cpu);

    for(i = 0; i < gtIntCpuHighCount; i++)
        /* Check ISR array hit  */
        if(causeAndMask & gtIntCpuHighArray[i].causeBit)
            (*gtIntCpuHighArray[i].userISR) (gtIntCpuHighArray[i].arg);
}

/*******************************************************************************
* gtIntCpuSelect - GT Select interrupt controller routine.
*
* DESCRIPTION:
*       If CPU interrupt pin is asserted, in order for the interrupt handler to 
*       identify the exact interrupt, it should read both the Low and High
*       Interrupt Cause registers. In order to minimize this procedure to a
*       single read, the GT contains a Selected Cause register. The interrupt
*       handler can read this register rather than the cause registers.
*       A Select Cause register is a shadow register of the Low or High Cause 
*       register, depending whether the active interrupt bit is in the Low or
*       High Cause register. 
*       Bit[30] of the select Cause register, indicates
*       which of Low or High Cause registers are currently represented by the
*       Select Cause register.
*       Bit[31] of the select Cause Register indicates if there are active
*       interrupts in both High and Low Cause Register or in any of them.
*
* INPUT:
*       None.
*
* OUTPUT:
*       If a cause bit is active (either in Low or High Cause Register)
*       and it's connected to an ISR function,the function will be called.
*
* RETURN:
*       None.
*
*******************************************************************************/
__inline__ void gtIntCpuSelect (void)
{   
    int          cpu = 0; /* support only cpu 0 for now */
    unsigned int selectCause;

#ifdef PMC280_DUAL_CPU
    if(frcWhoAmI())
        cpu = 1;
    else
        cpu = 0;
#endif /* PMC280_DUAL_CPU */

    /* Read the Select Cause Register */
    selectCause = CPU_SELECT_CAUSE_REG(cpu);

    if(selectCause & SELECT_BOTH_MAIN_HIGH)  
    {   
        /* There are interrupts both in High and Low Cause Register. */

        /* The Select Cause Register represent by Defalut the        */
        /* Low Cause Register. so in the case of interrupsts in both */
        /* of the cause registers, read straight from the High Cause */ 
        /* Register and read the Low from the Select Cause Register  */
        gtIntCpuLow();
        gtIntCpuHigh();
    }
    else
    {
        /* There are active Interrups only in the High Cause Register */
        if(selectCause & SELECT_HIGH_CAUSE)
            gtIntCpuHigh();
        else
            gtIntCpuLow();
    }
    return; 
}

