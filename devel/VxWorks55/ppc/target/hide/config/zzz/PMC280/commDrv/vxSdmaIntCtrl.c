/******************************************************************************
*              (c), Copyright, MOTOROLA  INC  - ECC                  *
*                                                                             *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MOTOROLA , INC.        *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT *
* OF MOTOROLA  OR ANY THIRD PARTY. MOTOROLA  RESERVES THE RIGHT AT ITS SOLE DISCRETION*
* TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MOTOROLA .       *
* THIS CODE IS PROVIDED "AS IS". MOTOROLA  MAKES NO WARRANTIES, EXPRESS,*
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.  *
*******************************************************************************

*******************************************************************************
* vxSdmaIntCtrl.c - SDMA interrupt controller library
*
* DESCRIPTION:
*       This driver provides various interface routines to manipulate and
*       connect the hardware interrupts concerning the MV SDMA facility.
*
*       Main features:
*        - The controller provides an easy way to hook a C Interrupt Service
*          Routine (ISR) to a specific interrupt caused by the SDMA channels.
*        - The controller interrupt mechanism provides a way for the programmer
*          to set the priority of an interrupt.
*        - Full interrupt control over the SDMA facility.
*
*       Overall Interrupt Architecture description:
*        The MV handles interrupts in two stages:
*        STAGE 1: Main Cause register that summarize the interrupts generated 
*                 by each Internal MV unit.
*        STAGE 2: Unit specified cause registers, that distinguish between each
*                 specific interrupt event.
*        This SDMA Interrupt Controller Driver handles the various interrupts 
*        generated by the second stage.
*
*       All SDMA various interrupt causes are numbered using the SDMA_CAUSE
*       enumerator. Thus there are 4 interrupts causes used for both SDMA 
*		channels.
*
*       The driver's execution flow has three phases:
*        1) Driver initialization. This initiation includes hooking driver's 
*           ISR to the MV Interrupt controller. Composed of vxSdmaIntCtrlInit() 
*           routine.
*        2) User ISR connecting. Here information about user ISR and interrupt 
*           priority is gathered. Composed of vxSdmaIntConnect() routine.
*        3) Interrupt handler. Here interrupts are being handle by the 
*           Interrupt Handler. Composed of sdmaIntHandler(), 
*
*       Full API:    
*         vxSdmaIntCtrlInit() - Initiate the SDMA interrupt controller driver.
*         vxSdmaIntConnect()  - Connect a user ISR to an SDMA interrupt event.
*         vxSdmaIntEnable()   - Enable a given SDMA interrupt cause.
*         vxSdmaIntDisable()  - Disable a given SDMA interrupt cause.
*         sdmaIntHandler()	  - Handles SDMA interrupts according to user ISR.
*
*       The controller concept is very simple:
*        The Interrupt handler has a table which holds information on 
*        the connected user ISR. An Interrupt generated by one of the SDMA 
*		 channels will result a search through this table in order to allocate 
*		 the generating interrupt cause.
*        After the initiating interrupt cause is identify, the ISR reside in 
*        the same table entry is executed.
*       
*       The controller interface also includes interrupt control routines which
*       can enable/disable specific interrupts: vxSdmaIntDisable() and
*       vxSdmaIntEnable().
*   
* DEPENDENCIES:
*		GT Interrupt Control Driver.
*		SDMA module.
*		VxWorks types and interrupt lib.
*
******************************************************************************/

/* includes */
#include "sdma.h"
#include "vxSdmaIntCtrl.h" 

#ifdef PMC280_DUAL_CPU
#include "gtSmp.h"
#endif /* PMC280_DUAL_CPU */

#ifdef PMC280_DEBUG_UART_VX
#include "dbgprints.h"
#endif /* PMC280_DEBUG_UART_VX */
#include "config.h"

#ifdef INCLUDE_WINDVIEW
#include "private/funcBindP.h"
#include "private/eventP.h"
#include "wvLib.h"
#endif

/* defines  */
#define SDMA_CAUSE_VALUE   REG_CONTENT(SDMA_CAUSE_REG)
#define SDMA_MASK_VALUE    REG_CONTENT(SDMA_MASK_REG)

#define INVALID_CAUSE(cause)    \
                ((cause) <= SDMA_CAUSE_START || SDMA_CAUSE_END <= (cause))


#define SDMA0_RX_BUFF   (1 << 0)
#define SDMA0_RX_ERR    (1 << 1)
#define SDMA0_TX_BUFF   (1 << 2)
#define SDMA0_TX_END    (1 << 3)

#define SDMA1_RX_BUFF   (1 << 8)
#define SDMA1_RX_ERR    (1 << 9)
#define SDMA1_TX_BUFF   (1 << 10)
#define SDMA1_TX_END    (1 << 11)


/* typedefs */


/* locals   */
LOCAL GT_ISR_ENTRY sdmaCauseArray[8]; /* Interrupt connection data storage    */
LOCAL int  sdmaCauseCount = 0; 		  /* Accumulates the number of connection */
LOCAL bool vxSdmaIntCtrlInitialized = false;
LOCAL void sdmaIntHandler(void);      /* SDMA events handler */
LOCAL UINT frcGetIntNumForSdma(UINT causebit);   /* to support for WindView */

/*******************************************************************************
* vxSdmaIntCtrlInit - Initiating the SDMA Interrupt Controller driver.
*
* DESCRIPTION:
*       This routines connects the drivers interrupt handler, to its 
*       corresponding bits in the MV device main Interrupt Controller using the
*       gtIntConnect() routine.
*		It is also cleans and masks interrupts.
*
* INPUT:
*       None.
*
* OUTPUT:
*       The SDMA channel cause & mask register are initiated (set to zero).
*       Driver's ISR are connected to the main cause register. 
*
* RETURN:
*       None.
*
*******************************************************************************/
void vxSdmaIntCtrlInit(void)
{
#ifdef PMC280_DEBUG_UART_VX
#ifdef PMC280_DUAL_CPU
    if(frcWhoAmI())
    {
        dbg_puts1("CPU1: Entering vxSdmaIntCtrlInit\n");
    }
    else
    {
        dbg_puts0("CPU0: Entering vxSdmaIntCtrlInit\n");
    }
#else
    dbg_puts0("Entering vxSdmaIntCtrlInit\n");
#endif /* PMC280_DUAL_CPU */
#endif /* PMC280_DEBUG_UART_VX */

    if(vxSdmaIntCtrlInitialized)
       return;

#ifdef PMC280_DUAL_CPU
    /*
     * There is *no* need to initialize the cause and mask registers
     * again. Hence the fix below.
     */
    if(!frcWhoAmI())
    {
        SDMA_CAUSE_VALUE = 0;  /* Clean Cause register */
        SDMA_MASK_VALUE  = 0;  /* Clean Mask register  */
    }
#else
    SDMA_CAUSE_VALUE = 0;  /* Clean Cause register */
    SDMA_MASK_VALUE  = 0;  /* Clean Mask register  */
#endif /* PMC280_DUAL_CPU */

#ifdef PMC280_DUAL_CPU
    if(frcWhoAmI())
    {
        gtIntConnect(SDMA1  ,sdmaIntHandler, 0, 9);
        gtIntEnable(SDMA1);
    }
    else
    {
        gtIntConnect(SDMA0  ,sdmaIntHandler, 0, 9);
        gtIntEnable(SDMA0);
    }
#else    
    /* Connect the user ISR's to the SDMA bits in the main cause register */
    gtIntConnect(SDMA0  ,sdmaIntHandler, 0, 9);
    gtIntConnect(SDMA1  ,sdmaIntHandler, 0, 9);

    /* Unmask those bits */
    gtIntEnable(SDMA0);
    gtIntEnable(SDMA1);
#endif /* PMC280_DUAL_CPU */

    vxSdmaIntCtrlInitialized = true;

#ifdef PMC280_DEBUG_UART_VX
#ifdef PMC280_DUAL_CPU
    if(frcWhoAmI())
    {
        dbg_puts1("CPU1: Exiting vxSdmaIntCtrlInit\n");
    }
    else
    {
        dbg_puts0("CPU0: Exiting vxSdmaIntCtrlInit\n");
    }
#else
    dbg_puts0("Exiting vxSdmaIntCtrlInit\n");
#endif /* PMC280_DUAL_CPU */
#endif /* PMC280_DEBUG_UART_VX */
}


/*******************************************************************************
* vxSdmaIntConnect - connect a C routine to a specific SDMA interrupt.
*
* DESCRIPTION:
*       This routine connects a specified user ISR to a specified SDMA 
*       interrupt cause.
*       The ISR handler has its own user ISR array. 
*       The connection is done by setting the desired routine and parameter in 
*       the cause array (sdmaCauseArray[]):
*         1) Check for existing connection for the cause bit in the table.
*         2) Connecting the user ISR by inserting the given parameters into 
*           an entry according to the user ISR given priority.
*
* INPUT:
*       SDMA_NUM sdmaNum     - SDMA Channel number. See SDMA_NUM. 
*       SDMA_CAUSE cause     - SDMA interrupt cause. See SDMA_CAUSE. 
*       VOIDFUNCPTR routine  - user ISR.
*       int parameter		 - user ISR parameter.
*       int prio	         - Interrupt handling priority where 0 is highest.
*
* OUTPUT:
*       A table entry is filled.
*
* RETURN:
*       OK    - if the table entry of the cause bit, was filled. 
*       ERROR - if cause argument is invalid or connected cause is already 
*                found in table.
*
*******************************************************************************/
STATUS vxSdmaIntConnect(SDMA_NUM sdmaNum,
                       SDMA_CAUSE cause,
                       VOIDFUNCPTR routine,
                       int parameter,
                       int prio)
{
    int i, sysIntOldConfig;

    /* Make sure that this is an atomic operation */
    sysIntOldConfig = intLock();

    /* Check the validity of the parameters */
    if(routine == NULL)
    {
        logMsg("\nvxSdmaIntConnect: NULL pointer routine\n",0,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }
    else if(prio < 0)
    {
        logMsg("\nvxSdmaIntConnect: Invalid interrupt priority\n",0,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }
    else if(INVALID_CAUSE(cause))
    {
        logMsg("\nvxSdmaIntConnect: Invalid cause %d\n",cause,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }

    /* Calculate the cause bit location in the register according to sdmaNum */ 
    cause = cause + (sdmaNum * 8);

    /* Scan the table to check for double connection to the same cause bit */
    for(i = sdmaCauseCount; i >= 0; i--)
        if(sdmaCauseArray[i].causeBit == SWAP_CAUSE_BIT(cause))
        {
            logMsg("\nvxSdmaIntConnect(cause %d): ERROR\nAn attempt to \
                   reconnect ISR to an existing cause bit.\n", cause,0,0,0,0,0); 
            intUnlock(sysIntOldConfig);
            return ERROR;
        }

    /* Connection phase */
    for(i = sdmaCauseCount; i >= 0; i--)
    {
        if(i == 0 || sdmaCauseArray[i-1].prio < prio) /* Make connection */
        {
            sdmaCauseArray[i].causeBit = SWAP_CAUSE_BIT(cause);
            sdmaCauseArray[i].userISR  = routine;
            sdmaCauseArray[i].arg      = parameter;
            sdmaCauseArray[i].prio     = prio;
            sdmaCauseCount++;
            break;
        }
        else
        {
            /* Push the low priority connection down the table */
            sdmaCauseArray[i].causeBit = sdmaCauseArray[i-1].causeBit;
            sdmaCauseArray[i].userISR  = sdmaCauseArray[i-1].userISR;
            sdmaCauseArray[i].arg      = sdmaCauseArray[i-1].arg;
            sdmaCauseArray[i].prio     = sdmaCauseArray[i-1].prio;    
        }
    }

    intUnlock(sysIntOldConfig);
    return OK;
}

/*******************************************************************************
* vxSdmaIntEnable - Enable an SDMA interrupt
*
* DESCRIPTION:
*       This routine unmasks a specified SDMA cause in the mask register.
*       The routine will preform argument validity check. 
*
* INPUT:
*	SDMA_NUM sdmaNum - SDMA channel number. See SDMA_NUM.
*       SDMA_CAUSE cause - SDMA interrupt cause as defined in SDMA_CAUSE. 		
*
* OUTPUT:
*       The appropriate bit in the SDMA mask register is set.
*
* RETURN:
*       OK    - If the bit was set
*       ERROR - if the bit was invalid
*
*******************************************************************************/
STATUS vxSdmaIntEnable(SDMA_NUM sdmaNum, SDMA_CAUSE cause)
{
    if (INVALID_CAUSE(cause))
    {
        logMsg("\nvxSdmaIntEnable: Invalid cause %d\n", cause,0,0,0,0,0);
        return ERROR;
    }
    
    /* Calculate the cause bit location in the register according to sdmaNum */ 
    cause = cause + (sdmaNum * 8);

    /* Set mask bit to enable interrupt */
    SDMA_MASK_VALUE |= SWAP_CAUSE_BIT(cause);

    return OK;
}

/*******************************************************************************
* vxSdmaIntDisable - Disable an SDMA interrupt
*
* DESCRIPTION:
*       This routine masks a specified SDMA interrupt in the mask register.
*       The routine will preform argument validity check. 
*
* INPUT:
*		SDMA_NUM sdmaNum - SDMA channel number. See SDMA_NUM.
*       SDMA_CAUSE cause - SDMA interrupt cause as defined in SDMA_CAUSE. 		
*
* OUTPUT:
*       The appropriate bit in the SDMA mask register is reset.
*
* RETURN:
*       OK    - If the bit was reset
*       ERROR - if the bit was invalid
*
*******************************************************************************/
STATUS vxSdmaIntDisable(SDMA_NUM sdmaNum, SDMA_CAUSE cause)
{
    if (INVALID_CAUSE(cause))
    {
        logMsg("\nvxSdmaIntDisable: Invalid cause %d\n", cause,0,0,0,0,0);
        return ERROR;
    }
    
    /* Calculate the cause bit location in the register according to sdmaNum */ 
    cause = cause + (sdmaNum * 8);

    /* Reset mask bit to disable interrupt */
    SDMA_MASK_VALUE &= ~SWAP_CAUSE_BIT(cause);
    
    return OK;
}
/*******************************************************************************
* vxSdmaIntClear - Clear an SDMA interrupt
*
* DESCRIPTION:
*       This routine clears a specified SDMA interrupt in the cause register.
*       The routine will preform argument validity check. 
*
* INPUT:
*		SDMA_NUM sdmaNum - SDMA channel number. See SDMA_NUM.
*       SDMA_CAUSE cause - SDMA interrupt cause as defined in SDMA_CAUSE. 		
*
* OUTPUT:
*       The appropriate bit in the SDMA cause register is reset.
*
* RETURN:
*       OK    - If the bit was reset
*       ERROR - if the bit was invalid
*
*******************************************************************************/
STATUS  vxSdmaIntClear(SDMA_NUM sdmaNum, SDMA_CAUSE cause)
{
    if (INVALID_CAUSE(cause))
    {
        logMsg("\nvxSdmaIntDisable: Invalid cause %d\n", cause,0,0,0,0,0);
        return ERROR;
    }
    
    /* Calculate the cause bit location in the register according to sdmaNum */ 
    cause = cause + (sdmaNum * 8);

    /* Reset mask bit to disable interrupt */
    SDMA_CAUSE_VALUE = ~SWAP_CAUSE_BIT(cause);
    
    return OK;
}

/*******************************************************************************
* sdmaIntHandler - SDMA interrupt handler.
*
* DESCRIPTION:
*       This routine handles the SDMA interrupts. 
*       As soon as the interrupt signal is active the CPU analyzes the SDMA 
*       Interrupt Cause register in order to locate the originating 
*       interrupt event. 
*       Then the routine calls the user specified service routine for that 
*       interrupt cause.
*       The function scans the sdmaCauseArray[] (sdmaCauseCount valid entries)
*       trying to find a hit in the sdmaCauseArray cause table.
*       When found, the ISR in the same entry is executed.
*	Note: The handler automatically acknowledges the generating interrupts.
*
* INPUT:
*       None.
*
* OUTPUT:
*       If a cause bit is active and it's connected to an ISR function,
*       the function will be called.
*
* RETURN:
*       None.
*
*******************************************************************************/
void sdmaIntHandler (void)
{
    int     i; 
    unsigned int causeAndMask;
    UINT intNum;
    /* Cause bit is active if an interrupt occurred and the bit is unmasked. */
#ifdef PMC280_DUAL_CPU
    if(frcWhoAmI())
    {
        causeAndMask = (SDMA_CAUSE_VALUE & SDMA_MASK_VALUE) & 0x000F0000;
    }
    else
    {
        causeAndMask = (SDMA_CAUSE_VALUE & SDMA_MASK_VALUE) & 0x0F000000;
    }
#else
    causeAndMask = SDMA_CAUSE_VALUE & SDMA_MASK_VALUE;
#endif /* PMC280_DUAL_CPU */

    for(i = 0; i < sdmaCauseCount; i++)

        if(causeAndMask & sdmaCauseArray[i].causeBit)
        {

	intNum = frcGetIntNumForSdma(sdmaCauseArray[i].causeBit); /* Support for WindView */
	#ifdef INCLUDE_WINDVIEW
	WV_EVT_INT_ENT(intNum);  
	#endif
            /* Acknowledge interrupt */
#ifdef PMC280_DUAL_CPU
            /*
             * We have a single register for both SDMA channels. This
             * means that we need to make use of some kind of locking
             * mechanism for write.
             */
            frcMv64360semTake(0, MV64360_SMP_WAIT_FOREVER);
            if(frcWhoAmI())
            {
                SDMA_CAUSE_VALUE = ~(sdmaCauseArray[i].causeBit);
            }
            else
            {
                SDMA_CAUSE_VALUE = ~(sdmaCauseArray[i].causeBit);
            }
            frcMv64360semGive(0);
#else
            SDMA_CAUSE_VALUE = ~(sdmaCauseArray[i].causeBit);
#endif /* PMC280_DUAL_CPU */

            /* Perform the ISR */
            (*sdmaCauseArray[i].userISR) (sdmaCauseArray[i].arg);
        }                                                            
}


UINT frcGetIntNumForSdma(UINT causebit)
{

	UINT intNum;

	switch(causebit)
	{
		case SDMA0_RX_BUFF:  
		case SDMA0_RX_ERR:
		case SDMA0_TX_BUFF:
		case SDMA0_TX_END:
			intNum = SDMA0; 
		break;

		case SDMA1_RX_BUFF:  
		case SDMA1_RX_ERR:
		case SDMA1_TX_BUFF:
		case SDMA1_TX_END:
			intNum = SDMA1;
		break;
		
		default:
			intNum = SDMA0;
		break;
			
	} /* end of switch statement */

	return intNum;
	
} /* end of frcGetIntNumForSdma */	

