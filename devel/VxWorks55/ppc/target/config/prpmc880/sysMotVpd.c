/* sysMotVpd.c - Board-Specified Vital Product Data Routines. */

/* Copyright 1999-2001 Wind River Systems, Inc. */
/* Copyright 1999-2003 Motorola, Inc., All Rights Reserved */

/*
modification history
--------------------
01a,02apr03,simon  Ported. from ver 01a, mcpm905/sysMotVpd.c.
*/

/*
DESCRIPTION
This file contains the Board-Specific Vital Product Data utility routines.

These routines extract or provide access to various parameters stored in the
board's Vital Product Data (VPD). In general, a board's VPD is stored in a
serial EEPROM device wired to the I2C bus and replaces the functions formerly
provided by system registers. Lower-level access routines provide the basic
VPD read, validate and parse operations while high-level routines extract
and save commonly used VPD parameters for faster access.
*/

#include "vxWorks.h"
#include "config.h"
#include "sysMotVpd.h"

/* defines */

#define ENET_INSTANCE_SIZE  7   /* size of an extended ethernet packet */

#ifndef VPD_READ
    IMPORT STATUS sysMotI2cRead(UINT32, UINT32, UINT32, UCHAR *, UINT32);
    #define VPD_READ(offset, bfr, num) \
        sysMotI2cRead(VPD_BRD_EEPROM_I2C_ADDR, offset, \
 		      VPD_BYTE_ADDR_SZ, bfr, num)
#endif /* VPD_READ */

/* locals */

/* globals */

VPD sysVpd; /* board vital product data */

VPD_PACKET * sysVpdPkts[VPD_PKT_LIMIT] = { 0 }; 	/* board vpd packets */
UCHAR        sysProductStr[25] = DEFAULT_PRODUCT_ID; 	/* product identifier */
UCHAR	     sysCpuStr[25] = DEFAULT_CPU_ID;		/* CPU identifier */
VPD_PACKET * pSysBrdOpts       = NULL;               	/* brd options packet */

/* forward declarations */

STATUS sysMotVpdHdrVld (VPD *);
STATUS sysMotVpdPktParse (VPD *, VPD_PACKET **, UINT32);
STATUS sysMotVpdPktInit (UCHAR, VPD *, VPD_PACKET **, UINT32);
STATUS sysMotVpdPktGet (UCHAR, UINT32, VPD_PACKET **, VPD_PACKET **);
void sysMotVpdReportError (char *);
STATUS sysMotVpdInit (void);
BOOL sysMotProdConfigGet (UINT32);

/* externals */

IMPORT void   sysDebugMsg (char *, UINT32);

/******************************************************************************
*
* sysMotVpdHdrVld - validate a vital product data header
*
* This routine validates the header of a vital product data structure. The
* validation is performed by checking the contents of the "eyecatcher" and size
* fields.
*
* RETURNS: OK, or ERROR if vpd header contents are invalid.
*/

STATUS sysMotVpdHdrVld
    (
    VPD * pVpd   /* pointer to vpd structure */
    )
    {
    UINT32 * pEyecatcher;

    /*
     * verify that the contents of the eyecatcher are correct. this must be
     * done numerically because the string addresses generated by the
     * compiler reference the program data area which is not valid until after
     * the code has been copied to ram.
     */

    pEyecatcher = (UINT32 *)&pVpd->header.eyeCatcher[0];

    if ((*pEyecatcher != 0x4d4f544f) ||     /* MOTO */
        (*(pEyecatcher+1) != 0x524f4c41))   /* ROLA */
            return (ERROR);

    /*
     * make sure the eeprom contents will fit into our vpd structure
     * and that the eeprom size is at least large enough to hold the header and
     * a termination packet.
     */

    if ( (pVpd->header.size > sizeof(VPD)) ||
         (pVpd->header.size < (sizeof(VPD_HEADER) + 1)) )
        return (ERROR);

    return (OK);
    }

/******************************************************************************
*
* sysMotVpdPktParse - parse the vital product data packets
*
* This routine parses a raw VPD data array into an array of VPD packet 
* pointers .  The parser walks through the data area of the vital product 
* data structure and saves the starting address of each packet it finds 
* into an array of packet pointers. When a desired packet is needed at a 
* later time, the packet pointer array can be scanned without having to 
* re-parse the packets for each search.
*
* RETURNS: OK, or ERROR and NULLs the first pointer in the array if an error
*          is encountered while parsing or the size of the pointer array is
*          exceeded.
*/

STATUS sysMotVpdPktParse
    (
    VPD *         pVpd,        /* pointer to vpd structure */
    VPD_PACKET ** pVpdPtr,     /* packet ptr array */
    UINT32        vpdPktLimit  /* number of pointers in the array */
    )
    {
    VPD_PACKET ** p;           /* address of first array element */
    UCHAR type;                /* type of current packet */
    UINT32 limit;              /* end of valid packet data */
    UINT32 index = 0;          /* current position in packet data */
    UINT32 pkt = 0;            /* number of packets found */

    /* verify that the header is correct */

    if (sysMotVpdHdrVld (pVpd) != OK)
        {
        *pVpdPtr = NULL;
        return (ERROR);
        }

    /* save the address of the first element in the pointer array */

    p = pVpdPtr;

    /* calculate the size of the data array */

    limit = (UINT32)pVpd->header.size - sizeof(VPD_HEADER);

    /* walk through the vpd data area parsing each packet */

    do
        {

        /* save the packet type */

        type =  pVpd->packets[index];

        /*
         * save the address of the current packet in the packet pointer array
         * and advance the packet pointer to the next array entry.
         */

        *pVpdPtr++ = (VPD_PACKET *)&pVpd->packets[index++];

        /* increment the packet count and advance to the next packet */

        ++pkt;
        index += pVpd->packets[index] + 1;

        /*
         * check the packet type and bail out of the loop if: 
	 * 1) the termination packet has been found 
	 * 2) the packet type is illegal 
	 * 3) if we've reached or exceeded the end of the data array 
	 *    or the packet pointer array.
         */

        if ( (type == VPD_PID_TERM) ||
             (type == VPD_PID_GI)   ||
             (index >= limit)       ||
             (pkt >= vpdPktLimit) )
            break;

        /* continue until termination packet is found */

        } while (type != VPD_PID_TERM);

    /*
     * if we didn't stop due to finding a termination packet, invalidate the
     * first entry in the pointer array and return an error indication.
     */

    if (type != VPD_PID_TERM)
        {
        *p = NULL;
        return (ERROR);
        }
    else
        return (OK);
    }

/******************************************************************************
*
* sysMotVpdPktGet - search the vital product data for a specific packet
*
* This routine searches the caller-supplied array of vpd packet pointers
* looking for the specified instance of a specific packet type. Instances are
* numbered starting at 0.
*
* NOTE: There are two types of ethernet address packets defined: The base type
* has 6 data bytes and no trailing instance number. The alternate type contains
* 6 bytes of ethernet address plus a trailing instance byte. Instances are
* numbered starting at zero. This routine will handle both packet types. It 
* will also handle multiple instances of the other packet types (except only 
* one termination packet is allowed).
*
* RETURNS: A pointer to the desired packet and OK if the packet was found,
*          otherwise it returns ERROR.
*/

STATUS sysMotVpdPktGet
    (
    UCHAR         vpdType,     /* target packet type */
    UINT32        vpdInstance, /* instance number of desired packet(0-based) */
    VPD_PACKET ** pVpdPtr,     /* address of the array of packet pointers */
    VPD_PACKET ** pVpdPacket   /* address of the return variable */
    )
    {
    UCHAR        type;         /* current packet type */
    VPD_PACKET * p;            /* pointer to current packet */
    UINT32 instance = vpdInstance;

    /* if the first pointer in the array is NULL, return error */

    if (*pVpdPtr == NULL)
        return (ERROR);

    do
        {

        /* get the current packet pointer */

        p = *pVpdPtr;

        /* if the packet type matches the caller's requested type */

        if ( (type = p->type) == vpdType )
            {

            /*
             * see if the type is an ethernet address and has a trailing
             * instance value. if it does, see if the instance number matches
             * the caller's requested instance.
             */

            if ( (vpdType == VPD_PID_EA) &&
                 (p->size == ENET_INSTANCE_SIZE) &&
                 (vpdInstance == p->data[ENET_INSTANCE_SIZE-1]) )
                {
                *pVpdPacket = p;
                return (OK);
                }
            else
                {

                /*
                 * see if this is the instance the caller requested, if not
                 * decrement the instance count and go around again.
                 */

                if (instance-- == 0)
                    {
                    *pVpdPacket = p;
                    return (OK);
                    }
                }
             }

        /* advance to the next packet. */

        pVpdPtr++;

        /* terminate on reaching the termination packet */

        } while ( type != VPD_PID_TERM);

    return (ERROR);
    }

/******************************************************************************
*
* sysMotVpdPktInit - initialize a vital product data structure.
*
* This routine reads the vital product data header from a serial eeprom and
* validates it. If the header is valid, the remainder of the vpd data
* is read from the serial eeprom and parsed into vpd packets for general
* purpose use.
*
* RETURNS: OK, if successful or ERROR if unsuccessful.
*/

STATUS sysMotVpdPktInit
    (
    UCHAR         devOffset, /* offset to vpd within the serial eeprom */
    VPD *         pVpd,      /* address of vpd structure */
    VPD_PACKET ** pVpdPtr,   /* address of packet ptr array */
    UINT32        PktLimit   /* number of entries in the packet ptr array */
    )
    {

    /* mark vpd packet pointer contents invalid. */

    *pVpdPtr = NULL;

    /* read just the header from serial eeprom. */

    if (VPD_READ ((UINT32)devOffset, (UCHAR *)pVpd, sizeof(VPD_HEADER)) != OK)
        return (ERROR);

    /* check for a valid header */

    if (sysMotVpdHdrVld (pVpd) != OK)
        return (ERROR);

    /* read the rest of the vpd from the serial eeprom. */

    if (VPD_READ (((UINT32)(devOffset + sizeof(VPD_HEADER))),
		  (UCHAR *)&pVpd->packets, 
		  ((UINT32)(pVpd->header.size - sizeof(VPD_HEADER)))) != OK)
        return (ERROR);

    /* parse the raw vpd data into vpd packets. */

    return (sysMotVpdPktParse (pVpd, pVpdPtr, PktLimit) );
    }

/******************************************************************************
*
* sysMotVpdReportError - routine to report errors in vpd data.
*
* This routine prints an error message at the system console and optionally
* returns to the boot rom.
*
* RETURNS: N/A
*/

void sysMotVpdReportError
    (
    char * str		/* message string to print */
    )
    {
    sysDebugMsg (str, DEFAULT_BSP_ERROR_BEHAVIOR);
    }

/*******************************************************************************
*
* sysMotVpdInit - initialize the board vital product data structures.
*
* This routine reads the VPD and extracts the commonly used data.
*
* RETURNS: OK, if successful or ERROR if unsuccessful.
*/

STATUS sysMotVpdInit (void) 
{
    VPD_PACKET * pVpdPkt;
    UINT32	 idx;
    
    /* read the vpd and parse data from the serial eeprom. */

    if ( sysMotVpdPktInit (VPD_BRD_OFFSET, &sysVpd, &sysVpdPkts[0], 
			   VPD_PKT_LIMIT) != OK) 
        {
        sysMotVpdReportError (
            "sysMotVpdInit: Unable to read Vital Product Data (VPD).\n\r");
        return (ERROR);
        }
    
    /* get the board type */

    if ((sysMotVpdPktGet (VPD_PID_PID, 0, &sysVpdPkts[0], &pVpdPkt) == OK) &&
        ((pVpdPkt->size + 1) < ((UCHAR)(sizeof (sysProductStr)))) )
        {

        for (idx = 0; idx < pVpdPkt->size; idx++)
            sysProductStr[idx] = pVpdPkt->data[idx];
        sysProductStr[idx] = '\0';

        }
    else
        sysMotVpdReportError ("sysMotVpdInit: Unable to read board type.\n\r");
    
    /* get the CPU type */

    if ((sysMotVpdPktGet (VPD_PID_MT, 0, &sysVpdPkts[0], &pVpdPkt) == OK) &&
	((pVpdPkt->size + 1) < ((UCHAR)(sizeof (sysCpuStr)))))
	{
		for (idx = 0; idx < pVpdPkt->size; idx++)
		    sysCpuStr[idx] = pVpdPkt->data[idx];
		sysCpuStr[idx] = '\0';
	}
  
    return (OK);
}

/*******************************************************************************
*
* sysMotProdConfigGet - initialize the board vital product data structures.
*
* This routine tests the presence of a caller specified product configuration
* option using the contents of the product configuration option vpd packet.
*
* RETURNS: TRUE if the option is present or FALSE if the product configuration
* option is not present or if the product configuration option packet is
* missing.
*/

BOOL sysMotProdConfigGet
    (
    UINT32 optionId	/* option to test */
    )
    {
    UCHAR  mask;
    UINT32 byteIdx;

    /* see if we have a valid board option vpd packet and option id. */

    if (pSysBrdOpts == NULL)
	return (FALSE);

    /* calculate the bit mask and byte index */

    mask = 0x80 >> (optionId % 8);
    byteIdx = optionId / 8;

    /* if byte index is off the end of the data array, return false. */

    if (byteIdx >= pSysBrdOpts->size)
	return (FALSE);

    return ( (pSysBrdOpts->data[byteIdx] & mask) != 0 );
    }
