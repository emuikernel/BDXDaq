/* A lexical scanner generated by flex */

/* scanner skeleton version:
 * Revision-Id: anj@aps.anl.gov-20101005192737-disfz3vs0f3fiixd
 */

/* modified by Jim Kowalkowski to have everything declared static */

#define FLEX_SCANNER

#include <stdio.h>
#include <stdlib.h>

/* amount of stuff to slurp up with each read */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* returned upon end-of-file */
#define YY_END_TOK 0

/* copy whatever the last rule matched to the standard output */

/* cast to (char *) is because for 8-bit chars, yytext is (unsigned char *) */
/* this used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite()
 */
#define ECHO (void) fwrite( (char *) yytext, yyleng, 1, yyout )

/* gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#define YY_INPUT(buf,result,max_size) \
	if ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \
	    YY_FATAL_ERROR( "read() in flex scanner failed" );
#define YY_NULL 0

/* no semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */

/* #define yyterminate() return ( YY_NULL )  replaced by jbk */
static int yyterminate_internal( void );
#define yyterminate() return yyterminate_internal()

/* report a fatal error */

/* The funky do-while is used to turn this macro definition into
 * a single C statement (which needs a semi-colon terminator).
 * This avoids problems with code like:
 *
 * 	if ( something_happens )
 *		YY_FATAL_ERROR( "oops, the something happened" );
 *	else
 *		everything_okay();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the YY_FATAL_ERROR() call.
 */

#define YY_FATAL_ERROR(msg) \
	do \
		{ \
		(void) fputs( msg, stderr ); \
		(void) putc( '\n', stderr ); \
		exit( 1 ); \
		} \
	while ( 0 )

/* default yywrap function - always treat EOF as an EOF */
#define yywrap() 1

/* enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN
 */
#define BEGIN yy_start = 1 + 2 *

/* action number for EOF rule of a given start state */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* special action meaning "start processing a new file" */
#define YY_NEW_FILE \
	do \
		{ \
		yy_init_buffer( yy_current_buffer, yyin ); \
		yy_load_buffer_state(); \
		} \
	while ( 0 )

/* default declaration of generated scanner - a define so the user can
 * easily add parameters - jbk added the static to YY_DECL
 */
#define YY_DECL static int yylex ( void ) 

/* code executed at the end of each rule */
#define YY_BREAK break;

#define YY_END_OF_BUFFER_CHAR 0

#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE (YY_READ_BUF_SIZE * 2) /* size of default input buffer */
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;

#define YY_CHAR unsigned char
# line 1 "../snc_lex.l"
#define INITIAL 0
# line 2 "../snc_lex.l"
/**************************************************************************
			GTA PROJECT   AT division
	Copyright, 1990, The Regents of the University of California.
		         Los Alamos National Laboratory

	snc_lex.l,v 1.2 1995/06/27 15:26:09 wright Exp
	ENVIRONMENT: UNIX
	HISTORY:
20nov91,ajk	Added OPTION token.
15jan92,ajk	Fixed to allow "!" as a unary operator.
17Jul92,rcz	changed warn_flag to warn_opt
17Jul92,rcz	Ported ajk version from lanl
04apr93,ajk	Increased STR_BFR_SIZE from 30000 to 300000
19nov93,ajk	Added definitions for octal and hex numbers.
19nov93,ajk	Removed optional "-" from definition of FPNUM.  This was
		causing problems with statements like "k-1".
27man94,ajk	Implemented dynamic allocation of strings, thus eliminating
		huge string buffer.
31may94,ajk	Changed handling of escaped C code.
17feb95,ajk	Removed includes "parse.h" & "snc.h", because this module
		now gets included in snc.y.
20jul95,ajk	Added unsigned types.
11jul96,ajk	Added character constants
08aug96,wfl	Added SYNCQ token.
23jun97,wfl	Added ^L as white-space char; permitted '"x" "y"' syntax.
01oct98,wfl     Replaced FPNUM with version from Sun lex manual ("E" support)
7sep99,wfl	Added QUESTION token (for ternary operator).
22sep99,grw     Supported ENTRY token (for entry action).
06mar00,wfl	Supported ASYNC and STNC tokens (avoids need for #define).
***************************************************************************/
/* Lexical analyzer for State Notation Compiler (snc).
 *
 * This routine recognizes State Notation Language (SNL) syntax,
 * and passes tokens to yacc().
 * All C code is passed through as a stream, without conversion.
 * Hence, the C compiler may find errors not reported by SNC.
 * Comments are recognized as part of the syntax.
 */

#include	<string.h>
#include	<osiUnistd.h>

#ifndef	TRUE
#define	TRUE	1
#define	FALSE	0
#endif
/*#define	DEBUG 1*/
#ifdef	DEBUG
#define	RETURN(param)	{ fprintf(stderr, "return(" #param ")\n"); \
			  return(param); }
#else
#define	RETURN(param)	return(param)
#endif
#define	STR_BFR_SIZE	1000

extern int	line_num, c_line_num;	/* input line number */
extern int	warn_opt;		/* compiler warning flag */
char		strBfr[STR_BFR_SIZE];	/* holding place for strings */
char		*pStr;			/* current ptr to strBfr */
double		atof();
int		one_line_c_code;	/* TRUE for %%; FALSE for %{...}% */

/* Start conditions (SNL, C code, comment, string, pre-processor, pre-proc. string) */
#define SNL 1
#define C_CODE 2
#define COMMENT 3
#define STR 4
#define PP 5
#define PP_STR 6
/* FPNUM was:
FPNUM   (([0-9]+)(\.[0-9]*)?)|(\.[0-9]+)
   replaced 01-Oct-98 */
# line 81 "../snc_lex.l"

/* done after the current pattern has been matched and before the
 * corresponding action - sets up yytext
 */
#define YY_DO_BEFORE_ACTION \
	yytext = yy_bp; \
	yyleng = yy_cp - yy_bp; \
	yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
	yy_c_buf_p = yy_cp;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* return all but the first 'n' matched characters back to the input stream */
#define yyless(n) \
	do \
		{ \
		/* undo effects of setting up yytext */ \
		*yy_cp = yy_hold_char; \
		yy_c_buf_p = yy_cp = yy_bp + n; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, yytext )


struct yy_buffer_state
    {
    FILE *yy_input_file;

    YY_CHAR *yy_ch_buf;		/* input buffer */
    YY_CHAR *yy_buf_pos;	/* current position in input buffer */

    /* size of input buffer in bytes, not including room for EOB characters */
    int yy_buf_size;	

    /* number of characters read into yy_ch_buf, not including EOB characters */
    int yy_n_chars;

    int yy_eof_status;		/* whether we've seen an EOF on this buffer */
#define EOF_NOT_SEEN 0
    /* "pending" happens when the EOF has been seen but there's still
     * some text process
     */
#define EOF_PENDING 1
#define EOF_DONE 2
    };

static YY_BUFFER_STATE yy_current_buffer;

/* we provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state"
 */
#define YY_CURRENT_BUFFER yy_current_buffer


/* yy_hold_char holds the character lost when yytext is formed */
static YY_CHAR yy_hold_char;

static int yy_n_chars;		/* number of characters read into yy_ch_buf */



#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

#ifndef YY_USER_INIT
#define YY_USER_INIT
#endif

/* jbk update
extern YY_CHAR *yytext;
extern int yyleng;
extern FILE *yyin, *yyout;
*/

static YY_CHAR *yytext; /* jbk added static */
static int yyleng; /* jbk added static */

static FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0; /* jbk added static */

#define YY_END_OF_BUFFER 113
typedef int yy_state_type;
static const short int yy_accept[275] =
    {   0,
        0,    0,  108,  108,    0,    0,    0,    0,    0,    0,
       15,   15,    0,    0,  113,  111,  110,  109,  108,   20,
       81,   25,  109,   89,   87,  109,  101,  102,   92,   79,
      103,   80,  100,   82,  106,  106,   98,   99,   83,   90,
       84,   97,   57,   57,   57,   57,   57,   95,   96,   86,
       57,   57,   57,   57,   57,   57,   57,   57,   57,   57,
       57,   57,   57,   57,   57,   93,   85,   94,   88,   23,
        1,    2,    1,    1,    6,    4,    6,    6,   10,   11,
        9,   10,   10,   16,   15,   14,   13,   16,   16,   12,
       18,   19,   17,   18,  108,   73,   22,   76,   21,   63,

       71,    0,   69,   58,   67,   59,   68,   78,  106,   24,
       70,  106,  105,  106,    0,    0,   74,   75,   66,   65,
       64,   57,   57,   57,   57,   57,   77,   57,   57,   57,
       57,   57,   57,   57,   57,   57,   57,   57,   46,   57,
       57,   57,   57,   57,   57,   26,   57,   57,   39,   57,
       57,   72,   60,    3,    5,    0,    8,    7,   15,   12,
       12,   12,    0,  107,    0,  106,    0,    0,  106,  104,
       61,   62,   57,   57,   57,   57,   57,   57,   57,   57,
       57,   57,   57,   57,   57,   57,   49,   34,   57,   57,
       57,   57,   57,   57,   57,   57,   57,   57,   57,    0,

       12,    0,    0,   12,    0,  106,    0,    0,  106,   57,
       57,   56,   53,   57,   57,   32,   57,   57,   47,   57,
       57,   51,   57,   35,   57,   57,   57,   57,   57,   57,
       44,   57,   28,   57,    0,   12,    0,    0,   12,    0,
      106,   55,   54,   57,   50,   42,   57,   52,   57,   36,
       57,   57,   57,   33,   27,   57,   45,   57,   48,    0,
       12,   30,   37,   43,   57,   41,   57,   38,   57,   29,
       40,   57,   31,    0
    } ;

static const YY_CHAR yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    4,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    5,    6,    7,    1,    8,    9,   10,   11,
       12,   13,   14,   15,   16,   17,   18,   19,   20,   20,
       20,   20,   20,   20,   20,   21,   21,   22,   23,   24,
       25,   26,   27,    1,   28,   29,   30,   31,   32,   33,
       34,   34,   34,   34,   34,   35,   34,   36,   34,   34,
       37,   38,   39,   40,   41,   34,   34,   34,   42,   34,
       43,   44,   45,   46,   47,    1,   48,   49,   50,   51,

       52,   53,   54,   55,   56,   34,   57,   58,   59,   60,
       61,   62,   34,   63,   64,   65,   66,   67,   68,   69,
       70,   34,   71,   72,   73,   74,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static const YY_CHAR yy_meta[75] =
    {   0,
        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    3,    3,
        3,    1,    1,    1,    1,    1,    1,    3,    3,    3,
        3,    3,    3,    4,    4,    4,    4,    4,    4,    4,
        4,    4,    1,    1,    1,    1,    4,    3,    3,    3,
        3,    3,    3,    4,    4,    4,    4,    4,    4,    4,
        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
        1,    1,    1,    1
    } ;

static const short int yy_base[284] =
    {   0,
      478,  477,    0,  476,   72,   73,   74,   75,   83,   88,
       90,   96,   98,  115,  482,  486,  486,  486,   81,  486,
      456,  486,  486,   98,   75,    0,  486,  486,  455,   94,
      486,  104,  105,  115,  116,  122,  486,  486,  125,  454,
      126,  486,  439,    0,  449,  434,  437,  486,  486,  449,
      409,  409,  416,  103,  103,   73,  105,  409,  408,  406,
      404,  111,  405,  405,  409,  486,   87,  486,  486,  486,
      486,  486,  486,  455,  486,  486,  486,  444,  486,  486,
      154,  486,  455,  486,  458,  486,  486,  486,  158,  163,
      486,  486,  486,  486,  184,  486,  486,  486,  486,  486,

      486,  449,  486,  486,  486,  486,  486,  486,  170,  486,
      486,  177,  186,  213,  227,    0,  433,  486,  486,  486,
      432,    0,  414,  420,  418,  412,  486,  388,  399,  402,
      400,  382,  383,  381,  392,  388,  382,  379,    0,  376,
      380,  379,  373,  376,  375,    0,  156,  375,    0,  370,
      160,  486,  486,  486,  486,  221,  486,  486,  431,  230,
      235,  252,  274,  486,  286,  277,  296,  238,  255,    0,
      486,  486,  396,  388,  350,  347,  321,  313,  294,  290,
      305,  289,  274,  278,  269,  279,    0,    0,  272,  266,
      265,  265,  251,  248,  255,  251,  243,  232,  233,  304,

      311,  319,  258,  325,  328,  331,  339,  345,  348,  259,
      253,    0,    0,  226,  213,    0,  214,  205,    0,  190,
      205,    0,  187,    0,  177,  179,  176,  171,  183,  171,
      189,  171,    0,  168,  351,  354,  362,  365,  368,  371,
      374,    0,    0,  153,    0,    0,  159,    0,  156,    0,
      139,  139,  145,    0,    0,  138,    0,  127,    0,  377,
      380,    0,    0,    0,  108,    0,  103,    0,   92,    0,
        0,   87,    0,  486,  401,  405,  409,  413,  417,  421,
      425,  427,  111
    } ;

static const short int yy_def[284] =
    {   0,
      275,  275,  274,    3,  276,  276,  277,  277,  278,  278,
      279,  279,  280,  280,  274,  274,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  281,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
      274,  274,  282,  282,  282,  282,  282,  274,  274,  274,
      282,  282,  282,  282,  282,  282,  282,  282,  282,  282,
      282,  282,  282,  282,  282,  274,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,

      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  283,  274,  274,  274,  274,
      274,  282,  282,  282,  282,  282,  274,  282,  282,  282,
      282,  282,  282,  282,  282,  282,  282,  282,  282,  282,
      282,  282,  282,  282,  282,  282,  282,  282,  282,  282,
      282,  274,  274,  274,  274,  274,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  274,  274,  274,  274,  283,
      274,  274,  282,  282,  282,  282,  282,  282,  282,  282,
      282,  282,  282,  282,  282,  282,  282,  282,  282,  282,
      282,  282,  282,  282,  282,  282,  282,  282,  282,  274,

      274,  274,  274,  274,  274,  274,  274,  274,  274,  282,
      282,  282,  282,  282,  282,  282,  282,  282,  282,  282,
      282,  282,  282,  282,  282,  282,  282,  282,  282,  282,
      282,  282,  282,  282,  274,  274,  274,  274,  274,  274,
      274,  282,  282,  282,  282,  282,  282,  282,  282,  282,
      282,  282,  282,  282,  282,  282,  282,  282,  282,  274,
      274,  282,  282,  282,  282,  282,  282,  282,  282,  282,
      282,  282,  282,    0,  274,  274,  274,  274,  274,  274,
      274,  274,  274
    } ;

static const short int yy_nxt[561] =
    {   0,
       18,   19,   20,   19,   21,   22,   23,   24,   25,   26,
       27,   28,   29,   30,   31,   32,   33,   34,   35,   36,
       36,   37,   38,   39,   40,   41,   42,   43,   44,   44,
       44,   44,   45,   44,   44,   44,   44,   44,   46,   47,
       44,   44,   48,   18,   49,   50,   18,   51,   52,   53,
       54,   55,   56,   44,   44,   57,   44,   58,   59,   44,
       60,   61,   44,   62,   63,   64,   44,   65,   44,   44,
       66,   67,   68,   69,   72,   72,   76,   76,   73,   73,
       77,   77,   95,  100,   95,   80,   78,   78,   81,   82,
       80,   85,   86,   81,   82,   87,   88,   85,   86,  101,

       92,   87,   88,   93,   94,   97,   89,  104,   90,   90,
       90,  152,   89,  170,   90,   90,   90,   92,  105,  106,
       93,   94,   98,  109,  109,  109,   83,  110,  107,  108,
      137,   83,  112,  138,  113,  113,  114,  273,  112,  111,
      114,  114,  114,  272,   74,   74,  115,  115,  117,  118,
      120,  121,  115,  115,  131,  156,  156,  139,  153,  157,
      133,  271,  134,  132,  140,  145,  115,  115,   99,  135,
      270,  136,  115,  115,  146,  147,  160,  160,  160,  161,
      148,  162,  162,  162,  116,   95,  269,   95,  109,  109,
      109,  268,  267,  163,  163,  166,  166,  166,  266,  265,

      165,  165,  112,  194,  113,  113,  114,  167,  167,  264,
      263,  198,  262,  163,  163,  199,  115,  115,  195,  259,
      165,  165,  156,  156,  258,  257,  157,  167,  167,  112,
      256,  114,  114,  114,  255,  254,  115,  115,  253,  252,
      168,  251,  168,  115,  115,  169,  169,  169,  160,  160,
      160,  250,  249,  201,  201,  201,  169,  169,  169,  248,
      200,  200,  247,  115,  115,  202,  202,  246,  161,  245,
      162,  162,  162,  169,  169,  169,  204,  204,  204,  244,
      200,  200,  163,  163,  243,  202,  202,  203,  242,  203,
      234,  233,  204,  204,  204,  166,  166,  166,  232,  205,

      231,  205,  163,  163,  206,  206,  206,  207,  207,  208,
      230,  208,  229,  228,  209,  209,  209,  235,  227,  235,
      226,  225,  236,  236,  236,  224,  223,  207,  207,  201,
      201,  201,  238,  222,  238,  221,  220,  239,  239,  239,
      219,  237,  237,  204,  204,  204,  206,  206,  206,  206,
      206,  206,  240,  218,  240,  217,  216,  241,  241,  241,
      215,  237,  237,  209,  209,  209,  209,  209,  209,  236,
      236,  236,  236,  236,  236,  260,  214,  260,  213,  212,
      261,  261,  261,  239,  239,  239,  239,  239,  239,  241,
      241,  241,  241,  241,  241,  261,  261,  261,  261,  261,

      261,   16,   16,   16,   16,   71,   71,   71,   71,   75,
       75,   75,   75,   79,   79,   79,   79,   84,   84,   84,
       84,   91,   91,   91,   91,  102,  211,  102,  102,  122,
      122,  210,  159,  197,  196,  193,  192,  191,  190,  189,
      188,  187,  186,  185,  184,  183,  182,  181,  180,  179,
      178,  177,  176,  175,  174,  173,  172,  171,  164,  159,
      158,  155,  154,  151,  150,  149,  144,  143,  142,  141,
      130,  129,  128,  127,  126,  125,  124,  123,  119,  103,
       96,  274,   70,   17,   17,   15,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,

      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  274,  274,  274,  274,  274
    } ;

static const short int yy_chk[561] =
    {   0,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    5,    6,    7,    8,    5,    6,
        7,    8,   19,   25,   19,    9,    7,    8,    9,    9,
       10,   11,   11,   10,   10,   11,   11,   12,   12,   25,

       13,   12,   12,   13,   13,   24,   11,   30,   11,   11,
       11,   67,   12,  283,   12,   12,   12,   14,   30,   32,
       14,   14,   24,   33,   33,   33,    9,   34,   32,   32,
       56,   10,   35,   56,   35,   35,   35,  272,   36,   34,
       36,   36,   36,  269,    5,    6,   35,   35,   39,   39,
       41,   41,   36,   36,   54,   81,   81,   57,   67,   81,
       55,  267,   55,   54,   57,   62,   35,   35,   24,   55,
      265,   55,   36,   36,   62,   62,   89,   89,   89,   90,
       62,   90,   90,   90,   35,   95,  258,   95,  109,  109,
      109,  256,  253,   90,   90,  112,  112,  112,  252,  251,

      109,  109,  113,  147,  113,  113,  113,  112,  112,  249,
      247,  151,  244,   90,   90,  151,  113,  113,  147,  234,
      109,  109,  156,  156,  232,  231,  156,  112,  112,  114,
      230,  114,  114,  114,  229,  228,  113,  113,  227,  226,
      115,  225,  115,  114,  114,  115,  115,  115,  160,  160,
      160,  223,  221,  161,  161,  161,  168,  168,  168,  220,
      160,  160,  218,  114,  114,  161,  161,  217,  162,  215,
      162,  162,  162,  169,  169,  169,  203,  203,  203,  214,
      160,  160,  162,  162,  211,  161,  161,  163,  210,  163,
      199,  198,  163,  163,  163,  166,  166,  166,  197,  165,

      196,  165,  162,  162,  165,  165,  165,  166,  166,  167,
      195,  167,  194,  193,  167,  167,  167,  200,  192,  200,
      191,  190,  200,  200,  200,  189,  186,  166,  166,  201,
      201,  201,  202,  185,  202,  184,  183,  202,  202,  202,
      182,  201,  201,  204,  204,  204,  205,  205,  205,  206,
      206,  206,  207,  181,  207,  180,  179,  207,  207,  207,
      178,  201,  201,  208,  208,  208,  209,  209,  209,  235,
      235,  235,  236,  236,  236,  237,  177,  237,  176,  175,
      237,  237,  237,  238,  238,  238,  239,  239,  239,  240,
      240,  240,  241,  241,  241,  260,  260,  260,  261,  261,

      261,  275,  275,  275,  275,  276,  276,  276,  276,  277,
      277,  277,  277,  278,  278,  278,  278,  279,  279,  279,
      279,  280,  280,  280,  280,  281,  174,  281,  281,  282,
      282,  173,  159,  150,  148,  145,  144,  143,  142,  141,
      140,  138,  137,  136,  135,  134,  133,  132,  131,  130,
      129,  128,  126,  125,  124,  123,  121,  117,  102,   85,
       83,   78,   74,   65,   64,   63,   61,   60,   59,   58,
       53,   52,   51,   50,   47,   46,   45,   43,   40,   29,
       21,   15,    4,    2,    1,  274,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,

      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
      274,  274,  274,  274,  274,  274,  274,  274,  274,  274
    } ;

static yy_state_type yy_last_accepting_state;
static YY_CHAR *yy_last_accepting_cpos;

/* the intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0

/* these variables are all declared out here so that section 3 code can
 * manipulate them
 */
/* points to current character in buffer */
static YY_CHAR *yy_c_buf_p = (YY_CHAR *) 0;
static int yy_init = 1;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

static yy_state_type yy_get_previous_state ( void );
static yy_state_type yy_try_NUL_trans ( yy_state_type current_state );
static int yy_get_next_buffer ( void );
static void yyunput ( YY_CHAR c, YY_CHAR *buf_ptr );

/* jbk added static in front all these */
static void yyrestart ( FILE *input_file );
static void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer );
static void yy_load_buffer_state ( void );
static YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size );
static void yy_delete_buffer ( YY_BUFFER_STATE b );
static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file );

#define yy_new_buffer yy_create_buffer

#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

YY_DECL
    {
    register yy_state_type yy_current_state;
    register YY_CHAR *yy_cp, *yy_bp;
    register int yy_act;



    if ( yy_init )
	{
	YY_USER_INIT;

	if ( ! yy_start )
	    yy_start = 1;	/* first start state */

	if ( ! yyin )
	    yyin = stdin;

	if ( ! yyout )
	    yyout = stdout;

	if ( yy_current_buffer )
	    yy_init_buffer( yy_current_buffer, yyin );
	else
	    yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );

	yy_load_buffer_state();

	yy_init = 0;
	}

    while ( 1 )		/* loops until end-of-file is reached */
	{
	yy_cp = yy_c_buf_p;

	/* support of yytext */
	*yy_cp = yy_hold_char;

	/* yy_bp points to the position in yy_ch_buf of the start of the
	 * current run.
	 */
	yy_bp = yy_cp;

	yy_current_state = yy_start;
	if ( yy_bp[-1] == '\n' )
	    ++yy_current_state;
yy_match:
	do
	    {
	    YY_CHAR yy_c = yy_ec[(int)*yy_cp];
	    if ( yy_accept[yy_current_state] )
		{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
		}
	    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = yy_def[yy_current_state];
		if ( yy_current_state >= 275 )
		    yy_c = yy_meta[(int)yy_c];
		}
	    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
	    ++yy_cp;
	    }
	while ( yy_base[yy_current_state] != 486 );

yy_find_action:
	yy_act = yy_accept[yy_current_state];

	YY_DO_BEFORE_ACTION;
	YY_USER_ACTION;

do_action:	/* this label is used only to access EOF actions */


	switch ( yy_act )
	    {
	    case 0: /* must backtrack */
	    /* undo the effects of YY_DO_BEFORE_ACTION */
	    *yy_cp = yy_hold_char;
	    yy_cp = yy_last_accepting_cpos;
	    yy_current_state = yy_last_accepting_state;
	    goto yy_find_action;

case 1:
# line 82 "../snc_lex.l"
*pStr++ = yytext[0];
	YY_BREAK
case 2:
# line 83 "../snc_lex.l"
{
		*pStr++ = 0;
		line_num++;
		c_line_num = line_num;
		yylval.pchar = strdup(strBfr);
		pStr = strBfr;
		if (one_line_c_code)
			BEGIN SNL;
		RETURN(C_STMT);
}
	YY_BREAK
case 3:
# line 93 "../snc_lex.l"
{
		*pStr++ = 0;
		yylval.pchar = strdup(strBfr);
		BEGIN SNL;
		RETURN(C_STMT);
}
	YY_BREAK
case 4:
# line 99 "../snc_lex.l"
line_num++;
	YY_BREAK
case 5:
# line 100 "../snc_lex.l"
BEGIN SNL;
	YY_BREAK
case 6:
# line 101 "../snc_lex.l"
;
	YY_BREAK
case 7:
# line 102 "../snc_lex.l"
{
		*pStr++ = yytext[0];
		*pStr++ = yytext[1];
}
	YY_BREAK
case 8:
# line 106 "../snc_lex.l"
/* ignored */ ;
	YY_BREAK
case 9:
# line 107 "../snc_lex.l"
{
		*pStr++ = 0;
		yylval.pchar = strdup(strBfr);
		BEGIN SNL;
		RETURN(STRING);
}
	YY_BREAK
case 10:
# line 113 "../snc_lex.l"
{ *pStr++ = yytext[0]; }
	YY_BREAK
case 11:
# line 114 "../snc_lex.l"
{	*pStr++ = '?';
		if (warn_opt)
			fprintf(stderr, "Warning:  newline in string, line %d\n",
			 line_num);
		line_num++;
}
	YY_BREAK
case 12:
# line 120 "../snc_lex.l"
{	yylval.pchar = strdup((char *)yytext);
		RETURN(NUMBER);
}
	YY_BREAK
case 13:
# line 123 "../snc_lex.l"
{ pStr = strBfr; BEGIN PP_STR; }
	YY_BREAK
case 14:
# line 124 "../snc_lex.l"
{
		BEGIN SNL;
		RETURN(CR);
}
	YY_BREAK
case 15:
# line 128 "../snc_lex.l"
/* no action */ ;
	YY_BREAK
case 16:
# line 129 "../snc_lex.l"
{
}
	YY_BREAK
case 17:
# line 131 "../snc_lex.l"
{
		*pStr++ = 0;
		yylval.pchar = strdup(strBfr);
		BEGIN PP;
		RETURN(STRING);
}
	YY_BREAK
case 18:
# line 137 "../snc_lex.l"
{ *pStr++ = yytext[0]; }
	YY_BREAK
case 19:
# line 138 "../snc_lex.l"
{ *pStr++ = '?'; line_num++; }
	YY_BREAK
case 20:
# line 139 "../snc_lex.l"
{ line_num++; }
	YY_BREAK
case 21:
# line 140 "../snc_lex.l"
{
		pStr = strBfr;
		one_line_c_code = FALSE;
		c_line_num = line_num;
		BEGIN C_CODE;
}
	YY_BREAK
case 22:
# line 146 "../snc_lex.l"
{
		pStr = strBfr;
		one_line_c_code = TRUE;
		c_line_num = line_num;
		BEGIN C_CODE;
}
	YY_BREAK
case 23:
# line 152 "../snc_lex.l"
{
		BEGIN PP;
		RETURN(PP_SYMBOL);
}
	YY_BREAK
case 24:
# line 156 "../snc_lex.l"
BEGIN COMMENT;
	YY_BREAK
case 25:
# line 157 "../snc_lex.l"
{ pStr = strBfr; BEGIN STR; }
	YY_BREAK
case 26:
# line 158 "../snc_lex.l"
RETURN(STATE_SET);
	YY_BREAK
case 27:
# line 159 "../snc_lex.l"
RETURN(STATE);
	YY_BREAK
case 28:
# line 160 "../snc_lex.l"
RETURN(WHEN);
	YY_BREAK
case 29:
# line 161 "../snc_lex.l"
RETURN(MONITOR);
	YY_BREAK
case 30:
# line 162 "../snc_lex.l"
RETURN(ASSIGN);
	YY_BREAK
case 31:
# line 163 "../snc_lex.l"
RETURN(UNSIGNED);
	YY_BREAK
case 32:
# line 164 "../snc_lex.l"
RETURN(CHAR);
	YY_BREAK
case 33:
# line 165 "../snc_lex.l"
RETURN(SHORT);
	YY_BREAK
case 34:
# line 166 "../snc_lex.l"
RETURN(INT);
	YY_BREAK
case 35:
# line 167 "../snc_lex.l"
RETURN(LONG);
	YY_BREAK
case 36:
# line 168 "../snc_lex.l"
RETURN(FLOAT);
	YY_BREAK
case 37:
# line 169 "../snc_lex.l"
RETURN(DOUBLE);
	YY_BREAK
case 38:
# line 170 "../snc_lex.l"
RETURN(STRING_DECL);
	YY_BREAK
case 39:
# line 171 "../snc_lex.l"
RETURN(TO);
	YY_BREAK
case 40:
# line 172 "../snc_lex.l"
RETURN(PROGRAM);
	YY_BREAK
case 41:
# line 173 "../snc_lex.l"
RETURN(OPTION);
	YY_BREAK
case 42:
# line 174 "../snc_lex.l"
RETURN(DEBUG_PRINT);
	YY_BREAK
case 43:
# line 175 "../snc_lex.l"
RETURN(EVFLAG);
	YY_BREAK
case 44:
# line 176 "../snc_lex.l"
RETURN(SYNC);
	YY_BREAK
case 45:
# line 177 "../snc_lex.l"
RETURN(SYNCQ);
	YY_BREAK
case 46:
# line 178 "../snc_lex.l"
RETURN(IF);
	YY_BREAK
case 47:
# line 179 "../snc_lex.l"
RETURN(ELSE);
	YY_BREAK
case 48:
# line 180 "../snc_lex.l"
RETURN(WHILE);
	YY_BREAK
case 49:
# line 181 "../snc_lex.l"
RETURN(FOR);
	YY_BREAK
case 50:
# line 182 "../snc_lex.l"
RETURN(BREAK);
	YY_BREAK
case 51:
# line 183 "../snc_lex.l"
RETURN(EXIT);
	YY_BREAK
case 52:
# line 184 "../snc_lex.l"
RETURN(ENTRY);
	YY_BREAK
case 53:
# line 185 "../snc_lex.l"
{
		yylval.pchar = "1";
		RETURN(NUMBER);
}
	YY_BREAK
case 54:
# line 189 "../snc_lex.l"
{
		yylval.pchar = "0";
		RETURN(NUMBER);
}
	YY_BREAK
case 55:
# line 193 "../snc_lex.l"
{
		yylval.pchar = "1";
		RETURN(NUMBER);
}
	YY_BREAK
case 56:
# line 197 "../snc_lex.l"
{
		yylval.pchar = "2";
		RETURN(NUMBER);
}
	YY_BREAK
case 57:
# line 201 "../snc_lex.l"
{
		yylval.pchar = strdup((char *)yytext);
		RETURN(NAME);
}
	YY_BREAK
case 58:
# line 205 "../snc_lex.l"
RETURN(AUTO_INCR);
	YY_BREAK
case 59:
# line 206 "../snc_lex.l"
RETURN(AUTO_DECR);
	YY_BREAK
case 60:
# line 207 "../snc_lex.l"
RETURN(OR);
	YY_BREAK
case 61:
# line 208 "../snc_lex.l"
RETURN(LEFT_EQUAL);
	YY_BREAK
case 62:
# line 209 "../snc_lex.l"
RETURN(RIGHT_EQUAL);
	YY_BREAK
case 63:
# line 210 "../snc_lex.l"
RETURN(AND);
	YY_BREAK
case 64:
# line 211 "../snc_lex.l"
RETURN(R_SHIFT);
	YY_BREAK
case 65:
# line 212 "../snc_lex.l"
RETURN(GE);
	YY_BREAK
case 66:
# line 213 "../snc_lex.l"
RETURN(EQ);
	YY_BREAK
case 67:
# line 214 "../snc_lex.l"
RETURN(PLUS_EQUAL);
	YY_BREAK
case 68:
# line 215 "../snc_lex.l"
RETURN(MINUS_EQUAL);
	YY_BREAK
case 69:
# line 216 "../snc_lex.l"
RETURN(MULT_EQUAL);
	YY_BREAK
case 70:
# line 217 "../snc_lex.l"
RETURN(DIV_EQUAL);
	YY_BREAK
case 71:
# line 218 "../snc_lex.l"
RETURN(AND_EQUAL);
	YY_BREAK
case 72:
# line 219 "../snc_lex.l"
RETURN(OR_EQUAL);
	YY_BREAK
case 73:
# line 220 "../snc_lex.l"
RETURN(NE);
	YY_BREAK
case 74:
# line 221 "../snc_lex.l"
RETURN(L_SHIFT);
	YY_BREAK
case 75:
# line 222 "../snc_lex.l"
RETURN(LE);
	YY_BREAK
case 76:
# line 223 "../snc_lex.l"
RETURN(MODULO_EQUAL);
	YY_BREAK
case 77:
# line 224 "../snc_lex.l"
RETURN(CMPL_EQUAL);
	YY_BREAK
case 78:
# line 225 "../snc_lex.l"
RETURN(POINTER);
	YY_BREAK
case 79:
# line 226 "../snc_lex.l"
RETURN(PLUS);
	YY_BREAK
case 80:
# line 227 "../snc_lex.l"
RETURN(MINUS);
	YY_BREAK
case 81:
# line 228 "../snc_lex.l"
RETURN(NOT);
	YY_BREAK
case 82:
# line 229 "../snc_lex.l"
RETURN(SLASH);
	YY_BREAK
case 83:
# line 230 "../snc_lex.l"
RETURN(LT);
	YY_BREAK
case 84:
# line 231 "../snc_lex.l"
RETURN(GT);
	YY_BREAK
case 85:
# line 232 "../snc_lex.l"
RETURN(BIT_OR);
	YY_BREAK
case 86:
# line 233 "../snc_lex.l"
RETURN(BIT_XOR);
	YY_BREAK
case 87:
# line 234 "../snc_lex.l"
RETURN(BIT_AND);
	YY_BREAK
case 88:
# line 235 "../snc_lex.l"
RETURN(COMPLEMENT);
	YY_BREAK
case 89:
# line 236 "../snc_lex.l"
RETURN(MODULO);
	YY_BREAK
case 90:
# line 237 "../snc_lex.l"
RETURN(EQUAL);
	YY_BREAK
case 91:
# line 238 "../snc_lex.l"
RETURN(AMPERSAND);
	YY_BREAK
case 92:
# line 239 "../snc_lex.l"
RETURN(ASTERISK);
	YY_BREAK
case 93:
# line 240 "../snc_lex.l"
RETURN(L_BRACKET);
	YY_BREAK
case 94:
# line 241 "../snc_lex.l"
RETURN(R_BRACKET);
	YY_BREAK
case 95:
# line 242 "../snc_lex.l"
RETURN(L_SQ_BRACKET);
	YY_BREAK
case 96:
# line 243 "../snc_lex.l"
RETURN(R_SQ_BRACKET);
	YY_BREAK
case 97:
# line 244 "../snc_lex.l"
RETURN(QUESTION);
	YY_BREAK
case 98:
# line 245 "../snc_lex.l"
RETURN(COLON);
	YY_BREAK
case 99:
# line 246 "../snc_lex.l"
RETURN(SEMI_COLON);
	YY_BREAK
case 100:
# line 247 "../snc_lex.l"
RETURN(PERIOD);
	YY_BREAK
case 101:
# line 248 "../snc_lex.l"
RETURN(L_PAREN);
	YY_BREAK
case 102:
# line 249 "../snc_lex.l"
RETURN(R_PAREN);
	YY_BREAK
case 103:
# line 250 "../snc_lex.l"
RETURN(COMMA);
	YY_BREAK
case 104:
# line 251 "../snc_lex.l"
{
		yylval.pchar = strdup((char *)yytext);
		RETURN(NUMBER);
}
	YY_BREAK
case 105:
# line 255 "../snc_lex.l"
{
		yylval.pchar = strdup((char *)yytext);
		RETURN(NUMBER);
}
	YY_BREAK
case 106:
# line 259 "../snc_lex.l"
{
		yylval.pchar = strdup((char *)yytext);
		RETURN(NUMBER);
}
	YY_BREAK
case 107:
# line 263 "../snc_lex.l"
{
		yylval.pchar = strdup((char *)yytext);
		RETURN(CHAR_CONST);
}
	YY_BREAK
case 108:
# line 267 "../snc_lex.l"
/* no action */ ;
	YY_BREAK
case 109:
# line 268 "../snc_lex.l"
RETURN(BAD_CHAR);
	YY_BREAK
case 110:
# line 269 "../snc_lex.l"
{		/* somehow "^#" doesn't work if it's first char */
		BEGIN PP;
		RETURN(PP_SYMBOL);
}
	YY_BREAK
case 111:
# line 273 "../snc_lex.l"
{ line_num = 1; BEGIN SNL; yyless(0); }
	YY_BREAK
case 112:
# line 275 "../snc_lex.l"
ECHO;
	YY_BREAK
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(SNL):
case YY_STATE_EOF(C_CODE):
case YY_STATE_EOF(COMMENT):
case YY_STATE_EOF(STR):
case YY_STATE_EOF(PP):
case YY_STATE_EOF(PP_STR):
    yyterminate();

	    case YY_END_OF_BUFFER:
		{
		/* amount of text matched not including the EOB char */
		int yy_amount_of_matched_text = yy_cp - yytext - 1;

		/* undo the effects of YY_DO_BEFORE_ACTION */
		*yy_cp = yy_hold_char;

		/* note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the end-
		 * of-buffer state).  Contrast this with the test in yyinput().
		 */
		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
		    /* this was really a NUL */
		    {
		    yy_state_type yy_next_state;

		    yy_c_buf_p = yytext + yy_amount_of_matched_text;

		    yy_current_state = yy_get_previous_state();

		    /* okay, we're now positioned to make the
		     * NUL transition.  We couldn't have
		     * yy_get_previous_state() go ahead and do it
		     * for us because it doesn't know how to deal
		     * with the possibility of jamming (and we
		     * don't want to build jamming into it because
		     * then it will run more slowly)
		     */

		    yy_next_state = yy_try_NUL_trans( yy_current_state );

		    yy_bp = yytext + YY_MORE_ADJ;

		    if ( yy_next_state )
			{
			/* consume the NUL */
			yy_cp = ++yy_c_buf_p;
			yy_current_state = yy_next_state;
			goto yy_match;
			}

		    else
			{
			goto yy_find_action;
			}
		    }

		else switch ( yy_get_next_buffer() )
		    {
		    case EOB_ACT_END_OF_FILE:
			{
			yy_did_buffer_switch_on_eof = 0;

			if ( yywrap() )
			    {
			    /* note: because we've taken care in
			     * yy_get_next_buffer() to have set up yytext,
			     * we can now set up yy_c_buf_p so that if some
			     * total hoser (like flex itself) wants
			     * to call the scanner after we return the
			     * YY_NULL, it'll still work - another YY_NULL
			     * will get returned.
			     */
			    yy_c_buf_p = yytext + YY_MORE_ADJ;

			    yy_act = YY_STATE_EOF((yy_start - 1) / 2);
			    goto do_action;
			    }

			else
			    {
			    if ( ! yy_did_buffer_switch_on_eof )
				YY_NEW_FILE;
			    }
			}
			break;

		    case EOB_ACT_CONTINUE_SCAN:
			yy_c_buf_p = yytext + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state();

			yy_cp = yy_c_buf_p;
			yy_bp = yytext + YY_MORE_ADJ;
			goto yy_match;

		    case EOB_ACT_LAST_MATCH:
			yy_c_buf_p =
			    &yy_current_buffer->yy_ch_buf[yy_n_chars];

			yy_current_state = yy_get_previous_state();

			yy_cp = yy_c_buf_p;
			yy_bp = yytext + YY_MORE_ADJ;
			goto yy_find_action;
		    }
		break;
		}

	    default:
#ifdef FLEX_DEBUG
		printf( "action # %d\n", yy_act );
#endif
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	    }
	}
    }


/* yy_get_next_buffer - try to read in a new buffer
 *
 * synopsis
 *     int yy_get_next_buffer();
 *     
 * returns a code representing an action
 *     EOB_ACT_LAST_MATCH - 
 *     EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *     EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer( void )

    {
    register YY_CHAR *dest = yy_current_buffer->yy_ch_buf;
    register YY_CHAR *source = yytext - 1; /* copy prev. char, too */
    register int number_to_move, i;
    int ret_val;

    if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
	YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

    /* try to read more data */

    /* first move last chars to start of buffer */
    number_to_move = yy_c_buf_p - yytext;

    for ( i = 0; i < number_to_move; ++i )
	*(dest++) = *(source++);

    if ( yy_current_buffer->yy_eof_status != EOF_NOT_SEEN )
	/* don't do the read, it's not guaranteed to return an EOF,
	 * just force an EOF
	 */
	yy_n_chars = 0;

    else
	{
	int num_to_read = yy_current_buffer->yy_buf_size - number_to_move - 1;

	if ( num_to_read > YY_READ_BUF_SIZE )
	    num_to_read = YY_READ_BUF_SIZE;

	else if ( num_to_read <= 0 )
	    YY_FATAL_ERROR( "fatal error - scanner input buffer overflow" );

	/* read in more data */
	YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
		  yy_n_chars, num_to_read );
	}

    if ( yy_n_chars == 0 )
	{
	if ( number_to_move - YY_MORE_ADJ == 1 )
	    {
	    ret_val = EOB_ACT_END_OF_FILE;
	    yy_current_buffer->yy_eof_status = EOF_DONE;
	    }

	else
	    {
	    ret_val = EOB_ACT_LAST_MATCH;
	    yy_current_buffer->yy_eof_status = EOF_PENDING;
	    }
	}

    else
	ret_val = EOB_ACT_CONTINUE_SCAN;

    yy_n_chars += number_to_move;
    yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
    yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

    /* yytext begins at the second character in yy_ch_buf; the first
     * character is the one which preceded it before reading in the latest
     * buffer; it needs to be kept around in case it's a newline, so
     * yy_get_previous_state() will have with '^' rules active
     */

    yytext = &yy_current_buffer->yy_ch_buf[1];

    return ( ret_val );
    }


/* yy_get_previous_state - get the state just before the EOB char was reached
 *
 * synopsis
 *     yy_state_type yy_get_previous_state();
 */

static yy_state_type yy_get_previous_state( void )

    {
    register yy_state_type yy_current_state;
    register YY_CHAR *yy_cp;

    YY_CHAR *yy_bp = yytext;

    yy_current_state = yy_start;
    if ( yy_bp[-1] == '\n' )
	++yy_current_state;

    for ( yy_cp = yytext + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
	{
	YY_CHAR yy_c = (*yy_cp ? yy_ec[(int)*yy_cp] : 1);
	if ( yy_accept[yy_current_state] )
	    {
	    yy_last_accepting_state = yy_current_state;
	    yy_last_accepting_cpos = yy_cp;
	    }
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
	    {
	    yy_current_state = yy_def[yy_current_state];
	    if ( yy_current_state >= 275 )
		yy_c = yy_meta[(int)yy_c];
	    }
	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
	}

    return ( yy_current_state );
    }


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *     next_state = yy_try_NUL_trans( current_state );
 */

static yy_state_type yy_try_NUL_trans( register yy_state_type yy_current_state )
    {
    register int yy_is_jam;
    YY_CHAR *yy_cp = yy_c_buf_p;

    YY_CHAR yy_c = 1;
    if ( yy_accept[yy_current_state] )
	{
	yy_last_accepting_state = yy_current_state;
	yy_last_accepting_cpos = yy_cp;
	}
    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
	{
	yy_current_state = yy_def[yy_current_state];
	if ( yy_current_state >= 275 )
	    yy_c = yy_meta[(int)yy_c];
	}
    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    yy_is_jam = (yy_base[yy_current_state] == 486);

    return ( yy_is_jam ? 0 : yy_current_state );
    }


static void yyunput( YY_CHAR c, register YY_CHAR *yy_bp )
    {
    register YY_CHAR *yy_cp = yy_c_buf_p;

    /* undo effects of setting up yytext */
    *yy_cp = yy_hold_char;

    if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
	{ /* need to shift things up to make room */
	register int number_to_move = yy_n_chars + 2; /* +2 for EOB chars */
	register YY_CHAR *dest =
	    &yy_current_buffer->yy_ch_buf[yy_current_buffer->yy_buf_size + 2];
	register YY_CHAR *source =
	    &yy_current_buffer->yy_ch_buf[number_to_move];

	while ( source > yy_current_buffer->yy_ch_buf )
	    *--dest = *--source;

	yy_cp += dest - source;
	yy_bp += dest - source;
	yy_n_chars = yy_current_buffer->yy_buf_size;

	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
	    YY_FATAL_ERROR( "flex scanner push-back overflow" );
	}

    if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
	yy_cp[-2] = '\n';

    *--yy_cp = c;

    /* note: the formal parameter *must* be called "yy_bp" for this
     *       macro to now work correctly
     */
    YY_DO_BEFORE_ACTION; /* set up yytext again */
    }


#ifdef __cplusplus
static int yyinput( void )
#else
static int input( void )
#endif

    {
    int c;
    YY_CHAR *yy_cp = yy_c_buf_p;

    *yy_cp = yy_hold_char;

    if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
	{
	/* yy_c_buf_p now points to the character we want to return.
	 * If this occurs *before* the EOB characters, then it's a
	 * valid NUL; if not, then we've hit the end of the buffer.
	 */
	if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
	    /* this was really a NUL */
	    *yy_c_buf_p = '\0';

	else
	    { /* need more input */
	    yytext = yy_c_buf_p;
	    ++yy_c_buf_p;

	    switch ( yy_get_next_buffer() )
		{
		case EOB_ACT_END_OF_FILE:
		    {
		    if ( yywrap() )
			{
			yy_c_buf_p = yytext + YY_MORE_ADJ;
			return ( EOF );
			}

		    YY_NEW_FILE;

#ifdef __cplusplus
		    return ( yyinput() );
#else
		    return ( input() );
#endif
		    }
		    break;

		case EOB_ACT_CONTINUE_SCAN:
		    yy_c_buf_p = yytext + YY_MORE_ADJ;
		    break;

		case EOB_ACT_LAST_MATCH:
#ifdef __cplusplus
		    YY_FATAL_ERROR( "unexpected last match in yyinput()" );
#else
		    YY_FATAL_ERROR( "unexpected last match in input()" );
#endif
		}
	    }
	}

    c = *yy_c_buf_p;
    yy_hold_char = *++yy_c_buf_p;

    return ( c );
    }


/* jbk added static in front of func */
static void yyrestart( FILE *input_file )
    {
    if ( yy_current_buffer )
	yy_init_buffer( yy_current_buffer, input_file );
    else
	yy_current_buffer = yy_create_buffer( input_file, YY_BUF_SIZE );

    yy_load_buffer_state();
    }


/* jbk added static in front of func */
static void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
    {
    if ( yy_current_buffer == new_buffer )
	return;

    if ( yy_current_buffer )
	{
	/* flush out information for old buffer */
	*yy_c_buf_p = yy_hold_char;
	yy_current_buffer->yy_buf_pos = yy_c_buf_p;
	yy_current_buffer->yy_n_chars = yy_n_chars;
	}

    yy_current_buffer = new_buffer;
    yy_load_buffer_state();

    /* we don't actually know whether we did this switch during
     * EOF (yywrap()) processing, but the only time this flag
     * is looked at is after yywrap() is called, so it's safe
     * to go ahead and always set it.
     */
    yy_did_buffer_switch_on_eof = 1;
    }


/* jbk added static in front of func */
static void yy_load_buffer_state( void )
    {
    yy_n_chars = yy_current_buffer->yy_n_chars;
    yytext = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
    yyin = yy_current_buffer->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
    }


/* jbk added static in front of func */
static YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
    {
    YY_BUFFER_STATE b;

    b = (YY_BUFFER_STATE) malloc( sizeof( struct yy_buffer_state ) );

    if ( ! b )
	YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

    b->yy_buf_size = size;

    /* yy_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b->yy_ch_buf = (YY_CHAR *) malloc( (unsigned) (b->yy_buf_size + 2) );

    if ( ! b->yy_ch_buf )
	YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

    yy_init_buffer( b, file );

    return ( b );
    }


/* jbk added static in front of func */
static void yy_delete_buffer( YY_BUFFER_STATE b )
    {
    if ( b == yy_current_buffer )
	yy_current_buffer = (YY_BUFFER_STATE) 0;

    free( (char *) b->yy_ch_buf );
    free( (char *) b );
    }


/* jbk added static in front of func */
static void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
    {
    b->yy_input_file = file;

    /* we put in the '\n' and start reading from [1] so that an
     * initial match-at-newline will be true.
     */

    b->yy_ch_buf[0] = '\n';
    b->yy_n_chars = 1;

    /* we always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
    b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;

    b->yy_buf_pos = &b->yy_ch_buf[1];

    b->yy_eof_status = EOF_NOT_SEEN;
    }

static int yyterminate_internal( void )
{
	/* jbk fix - buffer created by yy_create_buffer needs to be freed */
	yy_delete_buffer(yy_current_buffer);
	yy_current_buffer=NULL;
	return YY_NULL;
}

# line 275 "../snc_lex.l"
