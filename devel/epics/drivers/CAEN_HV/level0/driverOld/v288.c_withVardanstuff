
/* v288.c - provides interface emulating CAENHVWrapper */
/* original Vardan Gurjyan's DCHV control software was used as prototype */

#ifdef vxWorks

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include <vxWorks.h>
#include <taskLib.h>

#include "v288.h"

/* that board controls DC HV */
#define V288ADR1 0xfa100000 /* standard kernel */
/*#define V288ADR1 0xe0100000*/ /* 'EPICS' kernel */


#define QQ (UINT16)0xfffe
#define OK 0
#define MEK (UINT16)1

/* how many times loop before give up */
#define TIMEOUT 1111

/* delay for v288ActiveLoop command */
#define GSORTMONHOP 100000

/* delays for v288Transmit command */
#define MONHOP 1000000
#define SETHOP 3000000
#define ADRMHOP 10000000


#define RESET_ERR 101
#define WAIT_ERROR 102

/* the number of words to be transferred for different opcodes */
static int nwords[96] = {
  0, 1, 1, 1, 0, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, /*opcodes 0x00-0x0f ( 0-15)*/
  2, 2, 2, 2, 2, 2, 2, 2, 2, 7,-1, 7,-1,-1,-1,-1, /*opcodes 0x10-0x1f (16-31)*/
 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, /*opcodes 0x20-0x2f (32-47)*/
 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, /*opcodes 0x30-0x3f (48-63)*/
  1, 1,-1, 1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1, /*opcodes 0x40-0x4f (64-79)*/
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1,-1,-1,-1,-1  /*opcodes 0x50-0x5f (80-95)*/
};

static FILE *m_gpf;

char charname[21];
static int name[800];


/*---------------------------------------------------------*/
/*--------------------- function delay --------------------*/
/*---------------------------------------------------------*/


#define NTICKS 1000 /* the number of ticks per second */

IMPORT  STATUS sysBusToLocalAdrs(int, char *, char **);
int    sysClkRateGet();
STATUS sysClkRateSet(int);

/* sleep() for vxworks - delay n * 10(msec) */
void
ttsleep(int n)
{
  /*taskDelay ((sysClkRateGet() / NTICKS) * n);*/
  taskDelay(n);
}


/*******************************/
/*******************************/
/***** LOW-level functions *****/
/*******************************/
/*******************************/


/*----------------------------------------------------------*/
/*----------------- active loop delay ----------------------*/
/*----------------------------------------------------------*/
void
v288ActiveLoop(int spas)
{
  int jj;

  /*printf("v288ActiveLoop reached\n");*/

  while(spas--) jj++;
}

/*----------------------------------------------------------*/
/*---------- Send commands to caen function ----------------*/
/*----------------------------------------------------------*/
/*
     addr   - base address of v288 board
     offset - register offset (in bytes) we want to access:
                 0 - base reg
                 2 - stat reg
                 4 - trans reg
                 6 - reset reg
     vmedat - data to write into the register
     spas   -  parameter for delay active loop
 */
int
v288Transmit(UINT32 addr, UINT32 offset, UINT16 vmedat, int spas)
{
  volatile UINT16 *vmeaddress = (volatile UINT16 *) (addr+offset);
  volatile UINT16 *statreg = (volatile UINT16 *) (addr+2);
  int i=0;
  UINT16 q=0;

  /*printf("v288Transmit reached\n");*/

  while(q!=QQ && i<=TIMEOUT)
  {
    v288ActiveLoop(spas);
    *vmeaddress = vmedat;
    v288ActiveLoop(spas);
    q = *statreg;
    i++;
  }
  if(i>=TIMEOUT) printf("error code: %d \n",i);
  /*printf("q=0x%08x\n",q);*/

  return((i==TIMEOUT) ? TIMEOUT : OK);
}

/*---------------------------------------------------------*/
/*---- CAEN Wait function -------------------------------- */
/*---------------------------------------------------------*/
int
v288Wait(UINT32 addr, int delay)
{
  volatile UINT16 *v288adr = (volatile UINT16 *) addr;
  volatile UINT16 *statreg = (volatile UINT16 *) (addr+2);
  int i=0;
  UINT16 q=0;
  UINT16 vmedat;

  /*printf("v288Wait reached\n");*/
  while(i<=TIMEOUT && q!=QQ)     
  {
    v288ActiveLoop(delay);
    vmedat = *v288adr;
    v288ActiveLoop(delay);
    if((q=*statreg) == QQ)
    {
      return(vmedat);
    }
    i++;
  }
  printf("v288Wait error: timeout: did not get QQ after %d loops\n",i);

  return(WAIT_ERROR);
}

/*---------------------------------------------------------*/
/*------Reset_restart mod for caenet controller -----------*/ 
/*---------------------------------------------------------*/
int
v288Reset(void)
{
  volatile UINT16 *statreg = (volatile UINT16 *) (V288ADR1+2);
  volatile UINT16 *resetreg = (volatile UINT16 *) (V288ADR1+6);
  int i=0;
  UINT16 q=0;

  /*printf("v288Reset reached\n");*/

  while(q!=QQ && i<=11)
  {
	v288ActiveLoop(ADRMHOP);
    *resetreg = MEK;
    v288ActiveLoop(ADRMHOP);
    q = *statreg;
    /*printf("q=0x%08x\n",q);*/
    i++;
  }
  if(i>11) printf("error code: %d, q=0x%08x\n",i,q);

  return((i==11) ? 11 : OK);
}




/*******************************/
/*******************************/
/***** MID-level functions *****/
/*******************************/
/*******************************/

/* first stage of command sending */
int
v288Send1(UINT32 addr, UINT16 crate, UINT16 code, int delay)
{
  int res = 0;

  if(( res = v288Transmit(addr,0,1,delay))== TIMEOUT )
  {
    printf("v288Send1: set_fatal error: controller identifier code\n");
    return(res);
  }

  if(( res = v288Transmit(addr,0,crate,delay))== TIMEOUT )
  {
    printf("v288Send1: set_fatal error: can't see CAEN crate\n");
    return(res);
  }

  if(( res = v288Transmit(addr,0,code,delay))== TIMEOUT )
  {
    printf("v288Send1: set_error: operation code failed\n");
    return(res);
  }

  return(res);
}

/* second stage of command sending */
int
v288Send2(UINT32 addr, UINT16 value, int delay)
{
  int res = 0;

  if(( res = v288Transmit(addr,0,value,delay))== TIMEOUT )
  {
    printf("v288Send2: error: !!!\n");
    return(res);
  }

  return(res);
}

/* third stage of command sending */
int
v288Send3(UINT32 addr, int delay)
{
  int res = 0;

  if(( res = v288Transmit(addr, 4, MEK, delay)) == TIMEOUT)
  {
    printf("v288Send3: error: transmission register access failed %d \n",res);
  }

  return(res);
}

/* full sending command */
int
v288Send(UINT32 addr, UINT16 crate, UINT16 code, UINT16 *value)
{
  int i, res = 0;
  int delay = 1000/*1000000*/;

  if(code>95)
  {
    printf("v288Send: ERROR: illegal opcode %d(0x%x)\n",code,code);
    return(-1);
  }

  if(nwords[code]==-1)
  {
    printf("v288Send: ERROR: opcode %d(0x%x) does not exist or was not implemented\n",code,code);
    return(-2);
  }

  res = v288Send1(V288ADR1, crate, code, delay);
  for(i=0; i<nwords[code]; i++)
  {
    res = v288Send2(V288ADR1, value[i], delay);
  }
  res = v288Send3(V288ADR1, delay);
  res = v288Wait(V288ADR1, delay);

  return(res);
}

/* get data */
int
v288Get(UINT32 addr, int nw, UINT16 *buffer)
{
  volatile UINT16 *v288adr = (volatile UINT16 *) addr;
  volatile UINT16 *statreg = (volatile UINT16 *) (addr+2);
  int k=0;
  UINT16 q=0;
  UINT16 vmedat;
  int delay = 10000/*100000*/;

  for(;;)
  {
    v288ActiveLoop(delay);
    vmedat = *v288adr;
    v288ActiveLoop(delay);
    if( (q=*statreg) != QQ )
    {
      /*printf("q=0x%08x - break\n",q);*/
      break;
    }

    if(k<nw)
    {
      buffer[k++] = vmedat;
	}
    else
    {
      printf("v288Get: ERROR: buffer size %d is not enough !\n",nw);
	}
  }

  return(k);
}



/* VARDAN's functions */


/*---------------------------------------------------------*/ 
/*-Set and monitor entier conf  file ----------------------*/
/*-----sintax :--------------------------------------------*/ 
/*-setmon( conf_file_name, set=111/mon=333, code, value)---*/
/* mode=111 code=24 (0x18) */
/* mode=333 code=1 (0x1) */
/* mode=333 code=2 (0x2) */
/*---------------------------------------------------------*/
int
set_mon(char *group_file, int mode, UINT16 code, UINT16 com_value)
{
  FILE *gpf_adr;
  char charname[21];
  int memb_ind = 0;
  static int name[800]; 
  static int crate_num[800], board_chan[800];
  int board, channel;
  int ch,i,tmp=0;

  /*printf("set_mon reached\n");*/

  puts("START");
/*------ read the config file for the group ---------------*/
  if((gpf_adr = fopen(group_file,"r")) == NULL)
  {
    printf("Can't open file %s \n",group_file);
    return(0);
  }
  else
  {
    while((ch=getc(gpf_adr)) != EOF)
    {
      memb_ind++;
      fscanf(gpf_adr,"%s %d %d %d %d", charname, 
        &name[memb_ind], &crate_num[memb_ind], &board, &channel);
      board_chan[memb_ind] = ((UINT16)board << 8) | (UINT16)channel;
    }
  }
  fclose(gpf_adr);

  if(mode==111) 
  {
    /*---------- setting --------------------------------------*/
    for(i=1;i<=memb_ind;i++) 
    {
      tmp = v288Send1(V288ADR1, crate_num[i], code, SETHOP);
      tmp = v288Send2(V288ADR1, board_chan[i], SETHOP);
      tmp = v288Send2(V288ADR1, com_value, SETHOP);
      tmp = v288Send3(V288ADR1, SETHOP);
      if((tmp=v288Wait(V288ADR1, SETHOP)) == WAIT_ERROR)
        printf("set_error: error code from slave = %x  %d\n",tmp,i);
    }
  }
  else /*mode==333*/ 
  {
    /*------------------ monitoring --------------------------*/
    if((m_gpf=fopen("mondat/dc_mon.dat","w"))==NULL)
    {
      puts("Can't open dc_mon.dat");
    }
    else
    {
      printf("DEBUG: %d \n",memb_ind); 
    }

    for(i=1;i<=memb_ind;i++) 
    {
      tmp = v288Send1(V288ADR1, crate_num[i], code, MONHOP);
      tmp = v288Send2(V288ADR1, board_chan[i], MONHOP);
      tmp = v288Send3(V288ADR1, MONHOP);
      if((tmp=v288Wait(V288ADR1, MONHOP)) == WAIT_ERROR)
        printf("set_error: error code from slave = %x  %d\n",tmp,i);

      fprintf(m_gpf,"%3d ",name[i]);
      /* printf("%d %3d \n",i,name[i]);*/

      {
        volatile UINT16 *v288adr = (volatile UINT16 *) V288ADR1;
        volatile UINT16 *statreg = (volatile UINT16 *) (V288ADR1+2);
        UINT16 q=0;
        UINT16 vmedat;
        vmedat = tmp; /*returned by v288Wait*/
        fprintf(m_gpf," %5d",vmedat);
        /*printf(" %5d",vmedat);*/
        /*------- read all valid  data ----------------------------*/
        for(;;)                      
        {
          v288ActiveLoop(MONHOP);
          vmedat = *v288adr;
          v288ActiveLoop(MONHOP);
          if((q=*statreg)!=QQ) break;
          fprintf(m_gpf," %5d",vmedat);
          /*printf(" %5d",vmedat);*/
        }
        fprintf(m_gpf,"\n");
      }
    }

    fclose(m_gpf);
  }
  puts("STOP");

  return(0);
}






/*---------------------------------------------------------*/
/*-------------- Group statusmon function -----------------*/
/*------ it works only for one CAEN crate -----------------*/
/*---------------------------------------------------------*/
/*
code=65(0x41)
exec grp_read("test.iconf",1,9,65)
*/
int
grp_read(char *group_file, UINT16 crate_num, UINT16 group, UINT16 code)
{
  volatile UINT16 *v288adr = (volatile UINT16 *) V288ADR1;
  volatile UINT16 *statreg = (volatile UINT16 *) (V288ADR1+2);
  int tmp=0;
  FILE *gpf_adr;
  UINT16 vmedat;
  int ch,loop;
  int i=0, j=1, k=0, memb_ind=0;
  UINT16 q=0;
  int z;
/*
  char charname[21];
  static int name[800]; 
*/

  /*printf("grp_read reached\n");*/

  for(loop=0; loop<=20; loop++) charname[loop] = ' ';
  for(loop=0; loop<=799; loop++) name[loop] = 0;

  /*-------- read the config file for the group --------------*/
  if((gpf_adr = fopen(group_file,"r")) == NULL)
  {
    printf("Can't open file %s %d\n",group_file, errno);
    return(0);
  }
  else
  {
    while ((ch=getc(gpf_adr)) != EOF)
    {
      memb_ind++;
      fscanf(gpf_adr,"%s %d %d %d %d", charname,&name[memb_ind],&z,&z,&z);
    }
  }
  fclose(gpf_adr);

  /*----------organize the reading-----------------------------*/
  if((m_gpf=fopen("mondat/dc_mon.dat","w"))==NULL)
  {
    puts("Can't open dc_mon.dat");
  }
  else
  {
    printf("Open 'dc_mon.dat' file for 'organize the reading'\n"); 
  }

  tmp = v288Send1(V288ADR1, crate_num, code, MONHOP);
  tmp = v288Send2(V288ADR1, group, MONHOP);
  tmp = v288Send3(V288ADR1, MONHOP);
  if((tmp=v288Wait(V288ADR1, GSORTMONHOP)) == WAIT_ERROR)
    printf("set_error: error code from slave = %x  %d\n",tmp,i);

  /*printf("vmedat=0x%08x q=0x%08x ! (name[1]=%3d)\n",vmedat,q,name[1]);*/
  fprintf(m_gpf,"%3d",name[1]);
  /*--------- to be the same output as for set_mon -----------*/
  fprintf(m_gpf,"%5d",0);


  /*----------------- read all valid  data -------------------*/
  for(;;)
  {

    /* */
	v288ActiveLoop(GSORTMONHOP);
    vmedat = *v288adr;
    v288ActiveLoop(GSORTMONHOP);
    if( (q=*statreg) != QQ )
    {
      /*printf("q=0x%08x - break\n",q);*/
      break;
    }

    /* */
    k++;
    if(k>5) 
    {
      k=1; 
      j++;
      fprintf(m_gpf,"\n");
      fprintf(m_gpf,"%3d",name[j]);

      /*---------- to be the same output as for set_mon ----------*/
      fprintf(m_gpf,"%5d",0);        
      fprintf(m_gpf," %5d",vmedat);
    }
    else
    {
      fprintf(m_gpf," %5d",vmedat);
    }

  }
  fprintf(m_gpf,"\n");

  fclose(m_gpf);

  return(0);
}

/*---------------------------------------------------------*/
/*------ Add or remove channel from the group -------------*/
/*------NOT IN USE ???-------------------------------------*/
int
grp_adrm(char *group_file,UINT16 code, UINT16 group)
{
  FILE *gpf_adr;
  char charname[21];
  int memb_ind = 0;
  static int name[800];
  static int gcrate_num, gboard_chan[800];
  int board, channel;
  int ch,i,tmp=0;

  /*printf("grp_adrm reached\n");*/

  if((gpf_adr = fopen(group_file,"r")) == NULL)
  {
    printf("Can't open file %s \n",group_file);
    return(0);
  }
  else 
  {
    while((ch=getc(gpf_adr)) != EOF)
    {
      memb_ind++;
      fscanf(gpf_adr,"%s %d %d %d %d",
        charname, &name[memb_ind], &gcrate_num, &board, &channel);
      gboard_chan[memb_ind] = ((UINT16)board << 8) | (UINT16)channel;
    }
  }
  fclose(gpf_adr);

  for(i=1;i<=memb_ind;i++) 
  {
    tmp = v288Send1(V288ADR1, gcrate_num, code, ADRMHOP);
    tmp = v288Send2(V288ADR1, group, ADRMHOP);
    tmp = v288Send2(V288ADR1, gboard_chan[i], ADRMHOP);
    tmp = v288Send3(V288ADR1, ADRMHOP);
    if((tmp=v288Wait(V288ADR1, ADRMHOP)) == WAIT_ERROR)
      printf("grp_adrm: error code from slave = %x  %d\n",tmp,i);
  }

  return(0);  
}

/*---------------------------------------------------------*/
/*------------ group set operations -----------------------*/
/*--------- works for 1 crate -----------------------------*/
/*--- code: 83-91 (0x53-0x5b) -----------------------------*/
int
grp_set(int crate_num, UINT16 group, UINT16 code, UINT16 value)
{
  int tmp=0;

  /*printf("grp_set reached\n");*/
  tmp = v288Send1(V288ADR1, crate_num, code, SETHOP);
  tmp = v288Send2(V288ADR1, group, SETHOP);
  if(value>0) 
    tmp = v288Send2(V288ADR1, value, SETHOP);
  tmp = v288Send3(V288ADR1, SETHOP);
  if((tmp=v288Wait(V288ADR1, SETHOP)) == WAIT_ERROR)
    printf("grp_set: error code from slave = %x \n",tmp);

  return(0);  
}

/*---------------------------------------------------------*/
/*- Function will set parameters on the conf_file members,-*/ 
/*- taking the current values from setdat.txt. ------------*/
/*- Function will find in the group file the "as" and will-*/
/*- set on current as his corresponding value.-------------*/
/*---- code=16-23 (0x10-0x17) -----------------------------*/
int
set_par(char *group_file, UINT16 code)
{
  FILE *gpf_name, *gpf_value;
  char charname[21],*setname;
  int tmp = 0;
  int name; 
  int crate_num, board, channel, board_chan;
  int ch;
  int vfa, vfs, vsa, vss, vga, vgs;
  int valueas = 0;
  int region, sector, teta, as;

  /*printf("set_par reached\n");*/

  /*---------- read the parameters file ---------------------*/
  if(code == 16)       setname = "setdat/v0dat.txt";
  else if (code == 17) setname = "setdat/v1dat.txt";
  else if (code == 18) setname = "setdat/i0dat.txt";
  else if (code == 19) setname = "setdat/i1dat.txt";
  else if (code == 20) setname = "setdat/vmaxdat.txt";
  else if (code == 21) setname = "setdat/rupdat.txt";
  else if (code == 22) setname = "setdat/rdwndat.txt";
  else if (code == 23) setname = "setdat/tripdat.txt";
  else return(0);

  if((gpf_value = fopen(setname,"r"))==NULL)
  {
    printf("Can't open file %s \n",setname);
    return(0);
  }
  else 
  {
    while((ch=getc(gpf_value)) != EOF)
    {
      fscanf(gpf_value," %d %d %d %d %d %d \n", 
        &vfa,&vfs,&vsa,&vss,&vga,&vgs);
    }
  }
  fclose(gpf_value);

  /*-------- read the config file -------------- ------------*/
  if((gpf_name = fopen(group_file,"r")) == NULL)
  {
    printf("Can't open file %s \n",group_file);
    return(0);
  }
  while((ch=getc(gpf_name)) != EOF)
  {
    fscanf(gpf_name,"%s %d %d %d %d", 
      charname,&name,&crate_num, &board, &channel);
    board_chan = ((UINT16)board << 8) | (UINT16)channel;

    /*---- decoding the code_names ----------------------------*/
    region = name/10000;
    sector = (name/1000) - (region*10);
    teta = (name/100) - (region*100) - (sector*10);
    as = (name/10) - (region*1000) - (sector*100) - (teta*10);
    if (as == 1)      valueas = vfa;
    else if (as == 2) valueas = vfs;
    else if (as == 3) valueas = vsa;
    else if (as == 4) valueas = vss;
    else if (as == 5) valueas = vga;
    else if (as == 6) valueas = vgs;
    else return(0);
    printf("name = %d as = %d value = %d \n",name,as, valueas);

    tmp = v288Send1(V288ADR1, crate_num, code, SETHOP);
    tmp = v288Send2(V288ADR1, board_chan, SETHOP);
    tmp = v288Send2(V288ADR1, valueas, SETHOP);
    tmp = v288Send3(V288ADR1, SETHOP);
    if((tmp=v288Wait(V288ADR1, SETHOP)) == WAIT_ERROR)
      printf("set_error: error code from slave = %x \n",tmp);

    valueas = 0;
  }

  return(0);
}

/*----------------------------------------------------------*/
/*---function of reding the parameters in grouping mode-----*/
/*-----------works for groups in 1 crate -------------------*/
/*---- code=67-70 (0x43-0x46) ------------------------------*/
int
grp_paread(char *group_file, UINT16 crate_num, UINT16 group, UINT16 code)
{
  volatile UINT16 *v288adr = (volatile UINT16 *) V288ADR1;
  volatile UINT16 *statreg = (volatile UINT16 *) (V288ADR1+2);
  FILE *gpf_adr;
  UINT16 vmedat;
  int ch;
  int i=0, j=1, k=0, memb_ind=0, tmp=0;
  UINT16 q=0;
  int z, k_step,loop;

  /*printf("grp_paread reached\n");*/

  /*-----------total number of the channels in DC ------------*/

  for(loop=0; loop<=20; loop++) charname[loop] = ' ';
  for(loop=0; loop<=799; loop++) name[loop]=0;

  /*------------find the k_step according to the code --------*/
  /*-----Group mode readings for parameters-------------------*/ 
  /*--- have as usual 3 words. Only code 70 have 2 words-------*/
  if(code == 70) k_step = 2;
  else           k_step = 3;

  /*-------- read the config file for the group --------------*/
  if((gpf_adr = fopen(group_file,"r")) == NULL)
  {
    printf("Can't open file %s \n",group_file);
    return(0);
  }
  else
  {
    while((ch=getc(gpf_adr)) != EOF)
    {
      memb_ind++;
      fscanf(gpf_adr,"%s %d %d %d %d", charname,&name[memb_ind],&z,&z,&z);
    } 
    fclose(gpf_adr);
  }

  /*----- open the file for keeping the monitored data --------*/
  if((m_gpf=fopen("mondat/dc_mon.dat","w"))==NULL)
  {
    puts("Can't open dc_mon.dat");
  }
  else
  {
    printf("DEBUG: open file for 'keeping the monitored data'\n"); 
  }

  tmp = v288Send1(V288ADR1, crate_num, code, MONHOP);
  tmp = v288Send2(V288ADR1, group, MONHOP);
  tmp = v288Send3(V288ADR1, MONHOP);
  if((tmp=v288Wait(V288ADR1, GSORTMONHOP)) == WAIT_ERROR)
    printf("set_error: error code from slave = %x  %d\n",tmp,i);

  fprintf(m_gpf,"%3d",name[1]);
  /*--------- to be the same output as for set_mon -----------*/
  fprintf(m_gpf,"%5d",0); 

  /*----------------- read all valid  data -------------------*/
  for(;;)                      
  {
    v288ActiveLoop(GSORTMONHOP);
    vmedat = *v288adr;
    v288ActiveLoop(GSORTMONHOP);
    if((q=*statreg)!=QQ) break;
    k++;
    if(k>k_step) 
    {
      k=1; 
      j++;
      fprintf(m_gpf,"\n");
      fprintf(m_gpf,"%3d",name[j]);
      /*---------- to be the same output as for set_mon ----------*/
      fprintf(m_gpf,"%5d",0);        
      fprintf(m_gpf," %5d",vmedat);
    }
    else
	{
      fprintf(m_gpf," %5d",vmedat);
    }
  }
  fprintf(m_gpf,"\n");
  fclose(m_gpf);

  return(0);
}









/*
  65: 0      2(Vmon)     0     0    67 <- Vmon is different for diff. channels
  66: nothing
  67: 3500(I0set)     0(???)  7750(V0set) <- all channels 
  68: 0   100  3000  <- all channels

  69:
   900(SVmax)     1  1242
   900     1   200
   900     1  1206
   900     1   164
   900     1  1170
   900     1   128
   900     1  1134
   900     1    92
   900     1    74
   900     1  1080
   900     1    38
   900     1  1044
   900     1     2
   900     1   240
   900     1   222
   900     1  1228
   900     1  1210
   900     1   168
   900     1  1174
   900     1   132
   900     1  1138
   900     1    96
   900     1  1102
   900     1    60

  70:
   25(Rup)    50(Rdwn) 
   25    50 
   25    50 
   ........

  71: nothing
  72: nothing
  73: nothing
  74: nothing

*/

int
test(UINT16 code)
{
  char *group_file = "test.iconf";
  UINT16 crate_num = 9;
  UINT16 group = 0; /*9;*/
  UINT16 value[20], buffer[1024];
  int tmp=0;
  FILE *gpf_adr;
  int ch,loop;
  int i=0, j=1, k=0, memb_ind=0;
  int z, offset;
  UINT32 addr;

  char charnam[21];
  int nam[800]; 

  printf("test reached\n");
  printf("code=%d\n",code);

  /* get base address */
  sysBusToLocalAdrs(0x39, 0, (char **)&offset);
  addr = (V288ADR1&0xffffff) | offset;
  printf("addr=0x%08x (offset=0x%08x)\n",addr,offset);

  for(loop=0; loop<21; loop++) charnam[loop] = ' ';
  for(loop=0; loop<800; loop++) nam[loop] = 0;


  /*-------- read the config file for the group --------------*/
  if((gpf_adr = fopen(group_file,"r")) == NULL)
  {
    printf("Can't open file %s \n",group_file);
    return(0);
  }
  else
  {
    while ((ch=getc(gpf_adr)) != EOF)
    {
      memb_ind++;
      fscanf(gpf_adr,"%s %d %d %d %d",charnam,&nam[memb_ind],&z,&z,&z);
      /*printf(">%s< %d\n",charnam,nam[memb_ind]);*/
    }
  }
  fclose(gpf_adr);

  /* open output file*/
  if((m_gpf=fopen("test_mon.dat","w"))==NULL)
  {
    puts("Can't open test_mon.dat");
  }
  else
  {
    printf("Open 'test_mon.dat' file for 'organize the reading'\n"); 
  }

  /* send command */
  value[0] = group;
  v288Send(addr, crate_num, code, value);

  /* get data */
  tmp = v288Get(addr, 1024, buffer);
  printf("v288Get returns %d\n",tmp);

  /* print results */
  fprintf(m_gpf,"%3d",nam[1]);
  fprintf(m_gpf,"%5d",0); /* to be the same output as for set_mon */
  for(i=0; i<tmp; i++)
  {
    k++;
    if(k>5) 
    {
      k=1; 
      j++;
      fprintf(m_gpf,"\n");
      fprintf(m_gpf,"%3d",nam[j]);
      fprintf(m_gpf,"%5d",0); /* to be the same output as for set_mon */      
      fprintf(m_gpf," %5d",buffer[i]);
    }
    else
    {
      fprintf(m_gpf," %5d",buffer[i]);
    }
  }
  fprintf(m_gpf,"\n");

  /* close output file */
  fclose(m_gpf);

  return(0);


}


void
mytest()
{
  printf("mytest reached\n");
}



/********************************/
/********************************/
/* CAEN1527-style API functions */
/********************************/
/********************************/


#define MAX_NAME  81
#define MAX_SLOT  16 /* sy527 has 10 slots, but 16 should be fine for memory allocation */
#define MAX_CHAN  48
#define MAX_PARAM 100

#define MAX_HVPS        256
#define CAENHV_OK       0
#define CAENHV_SYSERR   1

#define LINKTYPE_TCPIP              0
#define LINKTYPE_RS232              1
#define LINKTYPE_CAENET             2

#define PARAM_TYPE_NUMERIC          0
#define PARAM_TYPE_ONOFF            1
#define PARAM_TYPE_CHSTATUS         2
#define PARAM_TYPE_BDSTATUS         3

#define MAX_V288GET 50
#define V288SENDANDGET \
    semTake(v288_mutex, WAIT_FOREVER); \
    v288Send(addr, crate, code, value); \
    tmp = v288Get(addr, 1024, buffer); \
    semGive(v288_mutex)

static SEM_ID v288_mutex;

/*structure to hold mainframe attributes*/
typedef struct hv527
{
  int   id; /* */
  char  name[MAX_NAME];
  char  type[MAX_NAME];
  unsigned long vmeaddr;
  unsigned long CrNum;
  int crnum;
  float scalev[MAX_SLOT];
  float scalei[MAX_SLOT];
} HV527;

static HV527 sy527[MAX_HVPS];

/* input: SystemName - name we assigned to mainframe (arbitrary)
          LinkType - LINKTYPE_CAENET for sy527
          Arg - sy527_VMEADDRESS_CRATE#
          UserName - irrelevant here
          Passwd - irrelevant here
 */
int
CAENHVInitSystem(const char *SystemName, int LinkType, void *Arg,
                 const char *UserName, const char *Passwd)
{
  int i, addr;
  char arg1[256], arg2[256], arg3[256];
  char *ch1, *ch2;

  if(LinkType != LINKTYPE_CAENET) return(CAENHV_SYSERR);

  /* search for empty slot */
  for(i=0; i<MAX_HVPS; i++)
  {
    if(sy527[i].vmeaddr == 0) /* empty, will use it */
	{
      sy527[i].id = i;
      strcpy(sy527[i].name,SystemName);

      ch1 = (char *)Arg;
      ch2 = arg1;
      while(*ch1 != '_') *ch2++ = *ch1++;
      *ch2 = '\0';

      ch1++;
      ch2 = arg2;
      while(*ch1 != '_') *ch2++ = *ch1++;
      *ch2 = '\0';

      ch1++;
      ch2 = arg3;
      while(*ch1 != '\0') *ch2++ = *ch1++;
      *ch2 = '\0';

      /*printf("CAENHVInitSystem: arg's    -> >%s< >%s< >%s<\n",arg1,arg2,arg3);*/

      strcpy(sy527[i].type,arg1);

      addr = strtol(arg2, (char **)NULL, 0); /*0x7fffffff max!!??*/
      sysBusToLocalAdrs(0x39, addr, (char **)&sy527[i].vmeaddr);

      sy527[i].CrNum = strtol(arg3, (char **)NULL, 0);
	  /*
      printf("CAENHVInitSystem: decode's -> >%s< 0x%08x %d\n",
        sy527[i].type,sy527[i].vmeaddr,sy527[i].CrNum);
	  */
      return(CAENHV_OK);
	}
  }

  return(CAENHV_SYSERR); /* no empty slots */
}


#define GET_SYSTEM_ID(myname) \
{ \
  int i; \
  for(i=0; i<MAX_HVPS; i++) \
  { \
    if( !strcmp(myname,sy527[i].name) ) \
    { \
      id = i; \
      crate = sy527[id].CrNum; \
      addr = sy527[id].vmeaddr; \
      /*printf("SYSTEM_ID: name >%s<, id=%d, addr=0x%08x, crate=%d\n", \
		myname,id,addr,crate);*/ \
      break; \
	} \
  } \
}


/* input: SystemName - the same name used in CAENHVInitSystem() call
 */
int
CAENHVDeinitSystem(const char *SystemName)
{
  int i;

  /* search for SystemName and release it if found */
  for(i=0; i<MAX_HVPS; i++)
  {
    if( !strcmp(SystemName,sy527[i].name) )
	{
      sy527[i].vmeaddr = 0;
      strcpy(sy527[i].name,"");

      return(CAENHV_OK);
	}
  }

  return(CAENHV_SYSERR);
}

/* input: SystemName - the same name used in CAENHVDeinitSystem() call
 */
char *
CAENHVGetError(const char *SystemName)
{
  return(CAENHV_OK);
}

/* input: SystemName
   output: NrOfSlot - the number of slots
           NrofChList - the number of channels
           ModelList - 
           DescriptionList - 
           SerNumList - 
           FmwRelMinList - 
           FmwRelMaxList - 
 */
int
CAENHVGetCrateMap(const char *SystemName, unsigned short *NrOfSlot,
                  unsigned short **NrofChList, char **ModelList,
                  char **DescriptionList, unsigned short **SerNumList,
                  unsigned char **FmwRelMinList, unsigned char **FmwRelMaxList)
{
  int id;
  UINT16 crate, code, value[20], buffer[1024];
  int tmp=0;
  int i;
  UINT32 addr, Vmax;
  UINT16 bitmap, Imax, Rampmin, Rampmax, Vres, Ires, Vdec, Idec;
  unsigned short  *u1, *u2;
  char *bname, Iunits[3];
  UINT8 *b8 = (UINT8 *)buffer, *c1, *c2;
  char *m, *d;
  float paw_10[] = {1., 10., 100.};

  GET_SYSTEM_ID(SystemName);

  code = 4; /*returns crate occupation (bitmap)*/
  V288SENDANDGET;
  bitmap = buffer[0];
  /*printf("v288Get returns %d\n",tmp);*/

  *NrOfSlot = 10; /* sy527 has 10 slots */
  /*printf("\nCrate bitmap 0x%04x, NrOfSlot=%d\n\n",bitmap,*NrOfSlot);*/



  /* allocate memory for output parameters */
  *NrofChList = calloc(*NrOfSlot,sizeof(unsigned short));
  *SerNumList = calloc(*NrOfSlot,sizeof(unsigned short));
  *FmwRelMinList = calloc(*NrOfSlot,sizeof(unsigned char));
  *FmwRelMaxList = calloc(*NrOfSlot,sizeof(unsigned char));

  *ModelList = calloc((*NrOfSlot)*256,sizeof(char));
  *DescriptionList = calloc((*NrOfSlot)*256,sizeof(char));

  u1 = *NrofChList;
  u2 = *SerNumList;
  c1 = *FmwRelMinList;
  c2 = *FmwRelMaxList;
  m = *ModelList;
  d = *DescriptionList;

  /* get crate information */
  code = 3;
  for(i=0; i<(*NrOfSlot); i++, m+=strlen(m)+1, d+=strlen(d)+1)
  {
    if( !((bitmap>>i)&0x1) )
    {
      strcpy(m,"");
      continue; /*skip empty slots*/
	}
    /*printf("Slot number %d ==================== (bitmap=0x%08x)\n",i,bitmap);*/
    value[0] = i; /*slot number(from 0)*/

    /* send command and get data */
    V288SENDANDGET;
    /*printf("v288Get returns %d\n",tmp);*/
    if(tmp<=0) continue;

    /* print results 
    for(i=0; i<tmp; i++) printf("[%3d] %5d   0x%04x\n",i,buffer[i],buffer[i]);
    */

    bname = (char *)&buffer[0];
    strncpy(m,bname,5); /* max 5 characters */
    m[5] = '\0'; /* in case of 5-char name 'm' will not be null-terminated, so do it */
    /*printf("Board name: >%s< (len=%d)\n",bname,strlen(m));*/

    strcpy(d,"n/a");

    tmp = b8[5];
    if(tmp==0) strcpy(Iunits,"A ");
    else if(tmp==1) strcpy(Iunits,"mA");
    else if(tmp==2) strcpy(Iunits,"uA");
    else if(tmp==3) strcpy(Iunits,"nA");
    /*printf("[%2d] Current units: %s\n",i,Iunits);*/

    u2[i] = buffer[3];
    /*printf("Serial number %d\n",buffer[3]);*/

    c2[i] = b8[8];
    c1[i] = b8[9];
    /*printf("Software version %2d.%02d\n",b8[8],b8[9]);*/

    u1[i] = (unsigned short)b8[30];
    /*printf("Num. of Channels %d (%d 0x%08x)\n",b8[30],u1[i],&u1[i]);*/


    Vmax = (b8[35]<<24)+(b8[36]<<16)+(b8[37]<<8)+b8[38];
    Imax = (b8[39]<<8)+b8[40];
    Rampmin = (b8[41]<<8)+b8[42];
    Rampmax = (b8[43]<<8)+b8[44];
    Vres = (b8[45]<<8)+b8[46];
    Ires = (b8[47]<<8)+b8[48];
    Vdec = (b8[49]<<8)+b8[50];
    Idec = (b8[51]<<8)+b8[52];

    sy527[id].scalev[i] = paw_10[Vdec];
    sy527[id].scalei[i] = paw_10[Idec];

    /*
    printf("Vmax=%d V\n",Vmax);
    printf("Imax=%d %s\n",Imax,Iunits);
    printf("Rampmin=%d V/sec\n",Rampmin);
    printf("Rampmax=%d V/sec\n",Rampmax);
	*/
	/*
    printf("\n");
    printf("[%2d] Vres=%d*0.01 V\n",i,Vres);
    printf("[%2d] Ires=%d*0.01 %s\n",i,Ires,Iunits);
    printf("[%2d] Vdec=%d significant figures after the decimal point\n",i,Vdec);
    printf("[%2d] Idec=%d significant figures after the decimal point\n",i,Idec);
    printf("\n");
	*/
  }

  return(CAENHV_OK);
}

/*
   input:
      ChNum - the number of channels
      ChList - list of channels (length=ChNum)

   output:
      ParValList - list of values (length=ChNum)
 */
int
CAENHVGetChParam(const char *SystemName, ushort slot, const char *ParName,
                 ushort ChNum, const ushort *ChList, void *ParValList)
{
  int id;
  UINT16 crate, code, value[20];
  UINT16 buffer[1024], buffer1[MAX_CHAN][MAX_V288GET], buffer2[MAX_CHAN][MAX_V288GET];
  int i, ich, tmp=0;
  UINT32 addr;
  char *ch;
  int V0set, V1set, I0set, I1set, SVmax, Rup, Rdwn, Trip, Flag;
  int Vmon, HVmax, Imon, Status;
  float *fval = ParValList;
  int *ival = ParValList;

  GET_SYSTEM_ID(SystemName);

  /*printf("CAENHVGetChParam reached\n");*/

  /* loop over 'ChNum' channels */
  for(ich=0; ich<ChNum; ich++)
  {

	/* hack to speed things up: read hardware ONLY if 'V0Set' is requested;
	   we assume that parameters are requested in the same order starting from 'V0Set' */
    if( !strcmp(ParName,"V0Set") )
    {
      value[0] = (slot<<8) + ChList[ich];

      /* gets preseted channel parameters */
      code = 2;
      V288SENDANDGET;
      if(tmp > MAX_V288GET)
      {
        printf("WARN: v288Get(1) returned %d, cut to %d\n",tmp,MAX_V288GET);
        tmp = MAX_V288GET;
	  }
      for(i=0; i<tmp; i++) buffer1[ich][i] = buffer[i];
      /*printf("v288Get returns %d\n",tmp);*/
      /*for(i=0; i<tmp; i++) printf("[%3d] %5d   0x%04x\n",i,buffer1[ich][i],buffer1[ich][i]);*/
      /*printf("\n");*/

      /* gets status channel parameters */
      code = 1;
      V288SENDANDGET;
      if(tmp > MAX_V288GET)
      {
        printf("WARN: v288Get(2) returned %d, cut to %d\n",tmp,MAX_V288GET);
        tmp = MAX_V288GET;
	  }
      for(i=0; i<tmp; i++) buffer2[ich][i] = buffer[i];
      /*printf("v288Get returns %d\n",tmp);*/
      /*for(i=0; i<tmp; i++) printf("[%3d] %5d   0x%04x\n",i,buffer2[ich][i],buffer2[ich][i]);*/
      /*printf("\n");*/
	}

    ch = (char *)&buffer1[ich][0];
    /*printf("Channel name >%s<\n",ch);*/

    V0set = (buffer1[ich][6]<<16) + buffer1[ich][7];
    V1set = (buffer1[ich][8]<<16) + buffer1[ich][9];
    I0set = buffer1[ich][10];
    I1set = buffer1[ich][11];
    SVmax = buffer1[ich][12];
    Rup = buffer1[ich][13];
    Rdwn = buffer1[ich][14];
    Trip = buffer1[ich][15];
    Flag = buffer1[ich][17]; /*what about 16 ??*/

    Vmon = (buffer2[ich][0]<<16) + buffer2[ich][1];
    HVmax = buffer2[ich][2];
    Imon = buffer2[ich][3];
    Status = buffer2[ich][4];

    /*
    printf("V0set=%d\n",V0set);
    printf("V1set=%d\n",V1set);
    printf("I0set=%d\n",I0set);
    printf("I1set=%d\n",I1set);
    printf("SVmax=%d\n",SVmax);
    printf("Rup=%d\n",Rup);
    printf("Rdwn=%d\n",Rdwn);
    printf("Trip=%d\n",Trip);
    printf("Flag=%d\n",Flag);
    printf("Vmon=%d\n",Vmon);
    printf("HVmax=%d\n",HVmax);
    printf("Imon=%d\n",Imon);
    */

    /* HAVE TO REPORT SOME OF FOLLOWING !!!
    printf("Status=%d\n",Status);
    if(Status&0x0001) printf("Status: Channel Present\n");
    else              printf("Status: Channel not Present\n");
    if(Status&0x0020) printf("Status: Internal Trip\n");
    if(Status&0x0040) printf("Status: Kill\n");
    if(Status&0x0100) printf("Status: Vmax\n");
    if(Status&0x0200) printf("Status: External Trip\n");
    if(Status&0x0400) printf("Status: Overvoltage\n");
    if(Status&0x0800) printf("Status: Undervoltage\n");
    if(Status&0x1000) printf("Status: Overcurrent\n");
    if(Status&0x2000) printf("Status: Down\n");
    if(Status&0x4000) printf("Status: Up\n");
    if(Status&0x8000) printf("Status: Channel On\n");
    else              printf("Status: Channel Off\n");
	*/

    if(      !strcmp(ParName,"V0Set") )  fval[ich] = ((float)V0set)/sy527[id].scalev[slot];
    else if( !strcmp(ParName,"I0Set") )  fval[ich] = ((float)I0set)/sy527[id].scalei[slot];
    else if( !strcmp(ParName,"V1Set") )  fval[ich] = ((float)V1set)/sy527[id].scalev[slot];
    else if( !strcmp(ParName,"I1Set") )  fval[ich] = ((float)I1set)/sy527[id].scalei[slot];
    else if( !strcmp(ParName,"Rup") )    fval[ich] = (float)Rup;
    else if( !strcmp(ParName,"Rdwn") )   fval[ich] = (float)Rdwn;
    else if( !strcmp(ParName,"Trip") )   fval[ich] = (float)Trip;
    else if( !strcmp(ParName,"SVMax") )  fval[ich] = (float)SVmax;
    else if( !strcmp(ParName,"VMon") )   fval[ich] = ((float)Vmon)/sy527[id].scalev[slot];
    else if( !strcmp(ParName,"IMon") )   fval[ich] = ((float)Imon)/sy527[id].scalei[slot];
    else if( !strcmp(ParName,"Status") ) ival[ich] = (int)Status;
    else if( !strcmp(ParName,"Pw") )     ival[ich] = 0;
    else if( !strcmp(ParName,"PrOn") )   ival[ich] = 0;
    else if( !strcmp(ParName,"PrOff") )  ival[ich] = 0;
    else if( !strcmp(ParName,"Pon") )    ival[ich] = 0;
    else if( !strcmp(ParName,"Pdwn") )   fval[ich] = 0.0;
    else                                 fval[ich] = 0.0;
  }



  return(CAENHV_OK);
}


int
CAENHVSetChParam(const char *SystemName, ushort slot, const char *ParName,
                 ushort ChNum, const ushort *ChList, void *ParValue)
{
  int id;
  int ich, bit, tmp=0;
  UINT16 crate, code, value[20], buffer[1024];
  UINT32 addr;
  float *fval = ParValue;
  int *ival = ParValue;

  GET_SYSTEM_ID(SystemName);
  /*printf("CAENHVSetChParam reached\n");*/

  /* loop over 'ChNum' channels */
  for(ich=0; ich<ChNum; ich++)
  {
    value[0] = (slot<<8) + ChList[ich];

    if(      !strcmp(ParName,"V0Set") )
    {
      code = 0x10;
      value[1] = (int)(fval[ich]*sy527[id].scalev[slot]);
	}
    else if( !strcmp(ParName,"I0Set") )
    {
      code = 0x12;
      value[1] = (int)(fval[ich]*sy527[id].scalei[slot]);
    }
    else if( !strcmp(ParName,"V1Set") )
    {
      code = 0x11;
      value[1] = (int)(fval[ich]*sy527[id].scalev[slot]);
	}
    else if( !strcmp(ParName,"I1Set") )
    {
      code = 0x13;
      value[1] = (int)(fval[ich]*sy527[id].scalei[slot]);
	}
    else if( !strcmp(ParName,"Rup") )
    {
      code = 0x15;
      value[1] = (int)(fval[ich]);
	}
    else if( !strcmp(ParName,"Rdwn") )
    {
      code = 0x16;
      value[1] = (int)(fval[ich]);
	}
    else if( !strcmp(ParName,"Trip") )
    {
      code = 0x17;
      value[1] = (int)(fval[ich]);
	}
    else if( !strcmp(ParName,"SVMax") )
    {
      code = 0x14;
      value[1] = (int)(fval[ich]);
	}
    /*else if( !strcmp(ParName,"VMon") )
    {
      ;
	}*/
    /*else if( !strcmp(ParName,"IMon") )
    {
      ;
	}*/
    /*else if( !strcmp(ParName,"Status") )
    {
      ;
	}*/
    /* NOTE: few following parameters are set using 'Flag' bits (code=0x18) */
    /* flag bit 3 (mask bit 11) (Pw) - Power,
       flag bit 6 (mask bit 14) (on/off) - enable,
       flag bit 7 (mask bit 15) (Pwon) -
     (if mask bit=0, parameter maintain old value, if =1, parameter take value from flag)
     */
    else if( !strcmp(ParName,"Pw") ) /* bit 'Power' ??? */
    {
      code = 0x18;
      bit = ival[ich] & 0x1; /* can be 0 or 1 */
      value[1] = ((bit<<3) | (1<<11));
      /*printf("Pw: 0x%04x\n",value[1]);*/
	}
    /*else if( !strcmp(ParName,"PrOn") )
    {
      ;
	}*/
    /*else if( !strcmp(ParName,"PrOff") )
    {
      ;
	}*/
    else if( !strcmp(ParName,"Pon") ) /* bit 'Power-on enable' ??? */
    {
      code = 0x18;
      bit = ival[ich] & 0x1; /* can be 0 or 1 */
      value[1] = ((bit<<6) | (1<<14));
      /*printf("Pon: 0x%04x\n",value[1]);*/
	}
    /*else if( !strcmp(ParName,"Pdwn") )
    {
      ;
	}*/
    else
	{
      printf("CAENHVSetChParam: ERROR: unknown ParName >%s<\n",ParName);
      continue;
    }

    V288SENDANDGET;
    /*printf("v288Get returns %d\n",tmp);*/
  }

  return(CAENHV_OK);
}

/* here only PropName='Type' is supported; for input 'ParName' it will
return one of four values through 'retval' */

int
CAENHVGetChParamProp(const char *SystemName, ushort slot, ushort ChNum,
                     const char *ParName, const char *PropName, void *retVal)
{
  int id, crate;
  unsigned int addr;
  unsigned long *retval = retVal;

  /* expecting 'Type' only */
  if(strncmp(PropName,"Type",4))
  {
    printf("Only PropName 'Type' currently supported\n");
    return(CAENHV_SYSERR);
  }

  GET_SYSTEM_ID(SystemName);
  /*printf("CAENHVGetChParamProp reached\n");*/

  /*A944*/
  if(!strncmp(ParName,"V0Set",5))       *retval = PARAM_TYPE_NUMERIC;
  else if(!strncmp(ParName,"I0Set",5))  *retval = PARAM_TYPE_NUMERIC;
  else if(!strncmp(ParName,"V1Set",5))  *retval = PARAM_TYPE_NUMERIC;
  else if(!strncmp(ParName,"I1Set",5))  *retval = PARAM_TYPE_NUMERIC;
  else if(!strncmp(ParName,"Rup",3))    *retval = PARAM_TYPE_NUMERIC;
  else if(!strncmp(ParName,"Rdwn",4))   *retval = PARAM_TYPE_NUMERIC;
  else if(!strncmp(ParName,"Trip",4))   *retval = PARAM_TYPE_NUMERIC;
  else if(!strncmp(ParName,"SVMax",5))  *retval = PARAM_TYPE_NUMERIC;
  else if(!strncmp(ParName,"VMon",4))   *retval = PARAM_TYPE_NUMERIC;
  else if(!strncmp(ParName,"IMon",4))   *retval = PARAM_TYPE_NUMERIC;
  else if(!strncmp(ParName,"Status",6)) *retval = PARAM_TYPE_CHSTATUS;
  else if(!strncmp(ParName,"Pw",2))     *retval = PARAM_TYPE_ONOFF;
  else if(!strncmp(ParName,"PrOn",4))   *retval = PARAM_TYPE_ONOFF;
  else if(!strncmp(ParName,"PrOff",5))  *retval = PARAM_TYPE_ONOFF;
  else if(!strncmp(ParName,"Pon",3))    *retval = PARAM_TYPE_ONOFF;
  else if(!strncmp(ParName,"Pdwn",4))   *retval = PARAM_TYPE_NUMERIC;
  else
  {
    *retval = PARAM_TYPE_NUMERIC;
    return(CAENHV_SYSERR);
  }

  return(CAENHV_OK);
}



/**************************************************************************/
/**************************************************************************/
/**************************************************************************/
/**************************************************************************/
/**************************************************************************/




static int nA944param = 16;
static char A944param[MAX_PARAM][MAX_NAME] = {
                "V0Set","I0Set","V1Set","I1Set","Rup","Rdwn","Trip","SVMax",
                "VMon","IMon","Status","Pw","PrOn","PrOff","Pon","Pdwn"};

void
test1()
{
  unsigned short NrOfSl, *SerNumList, *NrOfCh, ChList[MAX_CHAN];
  char *ModelList, *DescriptionList;
  unsigned char	*FmwRelMinList, *FmwRelMaxList;
  char name[MAX_NAME];
  int i, ret;
  unsigned short Slot, ChNum;
  float fParValList[MAX_CHAN];
  unsigned long	lParValList[MAX_CHAN];
  char ParName[MAX_NAME];
  unsigned long retval;


  ret = CAENHVInitSystem("TestSetup", LINKTYPE_CAENET, "sy527_0x100000_9","","");


  ret = CAENHVGetCrateMap("TestSetup",&NrOfSl, &NrOfCh, &ModelList,
                          &DescriptionList, &SerNumList,
                          &FmwRelMinList, &FmwRelMaxList );
  if(ret != CAENHV_OK)
  {
    printf("ERROR(sy527): %s (num. %d)\n\n", CAENHVGetError(name), ret);
  }
  else
  {
    char *m = ModelList, *d = DescriptionList;

    printf("The number of slots = %d\n",NrOfSl);
    for(i=0; i<NrOfSl; i++, m+=strlen(m)+1, d+=strlen(d)+1)
    {
      if(*m == '\0')
      {
        printf("Board %2d: Not Present\n", i);
      }
      else
      {
        printf("Board %2d: %s %s  Nr. Ch: %d  Ser. %d   Rel. %d.%d\n",
                i, m, d, NrOfCh[i], SerNumList[i], FmwRelMaxList[i], 
                FmwRelMinList[i]);
      }
    }
  }

  
  free(SerNumList);
  free(ModelList);
  free(DescriptionList);
  free(FmwRelMinList);
  free(FmwRelMaxList);
  free(NrOfCh);
  



  /* get params info 
  ret = CAENHVGetChParamProp("TestSetup", 3, 1, "VMon", "Type", &retval);
  printf("retval(VMon)=%d\n",retval);
  ret = CAENHVGetChParamProp("TestSetup", 3, 1, "Status", "Type", &retval);
  printf("retval(Status)=%d\n",retval);
  ret = CAENHVGetChParamProp("TestSetup", 3, 1, "Pw", "Type", &retval);
  printf("retval(Pw)=%d\n",retval);
  */


  ChNum = 24; /* # of channels */
  for(i = 0; i<ChNum; i++)
  {
    ChList[i] = (unsigned short)i;
  }


  Slot = 3;
  ChNum = 1;
  for(i=0; i<nA944param; i++)
  {
    ret = CAENHVGetChParamProp("TestSetup", Slot, ChNum, A944param[i], "Type", &retval);
    if(retval == PARAM_TYPE_NUMERIC)
    {
      ret = CAENHVGetChParam("TestSetup", Slot, A944param[i], ChNum, ChList, fParValList);
      printf("CAENHVGetChParam(float): %s = %7.3f\n",A944param[i],fParValList[0]);
    }
    else
    {
      ret = CAENHVGetChParam("TestSetup", Slot, A944param[i], ChNum, ChList, lParValList);
      printf("CAENHVGetChParam(int): %s = %d\n",A944param[i],lParValList[0]);
    }
  }


  strcpy(ParName,"SVMax");
  ChNum = 1;
  fParValList[0] = 1100.0;
  ret = CAENHVSetChParam("TestSetup", Slot, ParName, ChNum, ChList, fParValList);

  strcpy(ParName,"Pon");
  ChNum = 1;
  lParValList[0] = 1;
  ret = CAENHVSetChParam("TestSetup", Slot, ParName, ChNum, ChList, lParValList);

  strcpy(ParName,"Pw");
  ChNum = 1;
  lParValList[0] = 1;
  ret = CAENHVSetChParam("TestSetup", Slot, ParName, ChNum, ChList, lParValList);

  return;
}




#else /* vxWorks */

void
v288_dummy()
{
  return;
}

#endif
