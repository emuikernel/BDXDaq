
/* rol.h */

#ifndef _ROLDEFINED
#define _ROLDEFINED

#define EIEIO    __asm__ volatile ("eieio")
#define SYNC     __asm__ volatile ("sync")

typedef struct semaphore *SEM_ID;

static void __download ();
static void __prestart ();
static void __end ();
static void __pause ();
static void __go ();
static void __done ();
static void __status ();

static int theIntHandler ();

/* Include the memory partition structures and routines */
#include "libpart.h"

/* The following structure is used per readout list to store it's global data */
#include "rolInt.h"     

/* Define external variables and internal rol structures */
extern ROLPARAMS rolP;
static rolParam rol;

#ifdef VXWORKSPPC
extern int cacheInvalidate();
extern int cacheFlush();
#endif

static int syncFlag;
static int lateFail;

/* Event type source */
static int EVENT_type;
static int *StartOfEvent;


/* Macros */

#define BT_UI4_ty  0x01

#define RUN_NUMBER rol->runNumber
#define RUN_TYPE   rol->runType
#define EVENT_NUMBER *(rol->nevents)

#ifdef VXWORKS
#define LOGIT logMsg
#else
#define LOGIT printf
#endif

/* moved here from 'mempart.h' */
#define partGetItem1(p,i) \
{ \
  listGet1(&(p->list),i); /* returns 'i' */ \
}

#define partGetItem(p,i) \
{ \
  listGet(&(p->list),i); /* returns 'i' */ \
}

#define partFreeItem(pItem) \
{ \
  listAdd(&pItem->owner->list, pItem); \
}



/* - cbopen ---------------------------------------------------------- 
   crl	: open bank <bank_name> of <bank_type>
   - <bank_name> : converted in bnum through Bank_Dic_ID 
   - <bank_type> : UI2 , UI4, UB1 
   
   example	: open bank 0x1234 of UI2 
   
   call	: cbopen (int bnum, int btype); 
   
   Function: 
   open a CODA bank with CODA Bank Header Format 
   leaves (rol->dabufp) pointing to ready next address 
   keep pointer to length of bank in GblTopBp for length adjustment 
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

#define CEOPEN(bnum, btype) \
{ \
  if(__the_event__ == (DANODE *) 0 && rol->dabufp == NULL) \
  { \
    partGetItem1(rol->pool,__the_event__); \
    if(__the_event__ == (DANODE *) 0) \
    { \
      LOGIT("TRIG ERROR: no pool buffer available\n"); \
      return; \
    } \
    rol->dabufp = (int *) &__the_event__->length; \
    if(input_event__) \
    { \
      __the_event__->nevent = input_event__->nevent; \
    } \
    else \
    { \
      __the_event__->nevent = *(rol->nevents); \
    } \
  } \
  StartOfEvent = (rol->dabufp); \
  if(input_event__) \
  { \
    *(++(rol->dabufp)) = ((bnum) << 16) | ((btype##_ty) << 8) | (0xff & (input_event__->nevent));\
  } \
  else \
  { \
    *(++(rol->dabufp)) = (syncFlag<<24) | ((bnum) << 16) | ((btype##_ty) << 8) | (0xff & *(rol->nevents));\
  } \
  ((rol->dabufp))++; \
}

		     
/* - cbclose --------------------------------------------------------- 
 crl	: close bank <buff_len> of <bank_type> 
  - <bank_type> : UI2 , UI4, UB1 
  - <buff_len>  : number of "bank_type" word written 

 example	: close bank

  Call	: cbclose (btype, &buflen); 

  Function: 
    Close a CODA bank created by "cbopen" 
    leaves the (rol->dabufp) pointing to next empty int after bank 
    returns the actual length of that bank 
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


#define CECLOSE \
{ \
  *StartOfEvent = \
  (int) (((char *) (rol->dabufp)) - ((char *) StartOfEvent)); \
  if((*StartOfEvent & 1) != 0) \
  { \
    (rol->dabufp) = ((int *)((char *) (rol->dabufp))+1); \
    *StartOfEvent += 1; \
  } \
  if((*StartOfEvent & 2) !=0) \
  { \
    *StartOfEvent = *StartOfEvent + 2; \
    (rol->dabufp) = ((int *)((short *) (rol->dabufp))+1); \
  } \
  *StartOfEvent = ( (*StartOfEvent) >> 2) - 1; \
}


/* private global */

static unsigned char dispatch_busy; 
static int poolEmpty;

#ifdef VXWORKS
static int intLockKey;

static FUNCPTR trigRtns;
static FUNCPTR syncTRtns;
static FUNCPTR doneRtns;
static FUNCPTR ttypeRtns;

#else

static FUNCPTR1 trigRtns;
static FUNCPTR2 syncTRtns;
static FUNCPTR3 doneRtns;
static FUNCPTR4 ttypeRtns;

#endif

static unsigned int Tcode;
static DANODE *__the_event__, *input_event__, *__user_event__;

/* 
   Clear some global variables etc for a clean start.
   Should be done at Prestart.
*/

#define CTRIGINIT \
{ \
    dispatch_busy = 0; \
    syncTRtns = NULL; \
    ttypeRtns = NULL; \
    Tcode = 0; \
    poolEmpty = 0; \
    input_event__ = (DANODE *) 0; /* input events pool */ \
    __the_event__ = (DANODE *) 0; /* output events pool */ \
}


#ifdef VXWORKS

/* Register an async trigger source */

#define CTRIGRSA(source,code,handler,done) \
{ \
  void handler(); \
  void done(); \
  trigRtns  = (FUNCPTR) (handler) ; \
  doneRtns  = (FUNCPTR) (done) ; \
  Tcode     = (code); /*TIR_SOURCE or TS_SOURCE*/ \
  ttypeRtns = (FUNCPTR) source##_TTYPE ; \
  source##_ASYNC(code); \
  LOGIT("CTRIGRSA: set handler and done, code=%d\n",code); \
  LOGIT("CTRIGRSA: 0x%08x 0x%08x 0x%08x 0x%08x\n", \
    doneRtns,trigRtns,Tcode,ttypeRtns); \
}

/* Register an sync trigger source */

#define CTRIGRSS(source,code,handler,done) \
{ \
  void handler(); \
  void done(); \
  trigRtns  = (FUNCPTR) (handler) ; \
  doneRtns  = (FUNCPTR) (done) ; \
  syncTRtns = (FUNCPTR) source##_TEST ; \
  Tcode     = (code) ; \
  ttypeRtns = (FUNCPTR) source##_TTYPE ; \
  source##_SYNC(code); \
  LOGIT("CTRIGRSS: set handler and done, code=%d\n",code); \
  LOGIT("CTRIGRSS: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", \
    doneRtns,trigRtns,syncTRtns,Tcode,ttypeRtns); \
}

#else

#define CTRIGRSA(source,code,handler,done) \
{ \
  trigRtns  = (FUNCPTR1) (handler); \
  doneRtns  = (FUNCPTR3) (done); \
  Tcode     = (code); \
  ttypeRtns = (FUNCPTR4) source##_TTYPE; \
  source##_ASYNC(code); \
  LOGIT("CTRIGRSA: set handler and done, code=%d\n",code); \
  LOGIT("CTRIGRSA: 0x%08x 0x%08x 0x%08x 0x%08x\n", \
    doneRtns,trigRtns,Tcode,ttypeRtns); \
}

#define CTRIGRSS(source,code,handler,done) \
{ \
  trigRtns  = (FUNCPTR1) (handler) ; \
  doneRtns  = (FUNCPTR3) (done) ; \
  syncTRtns = (FUNCPTR2) source##_TEST ; \
  Tcode     = (code) ; \
  ttypeRtns = (FUNCPTR4) source##_TTYPE ; \
  source##_SYNC(code); \
  LOGIT("CTRIGRSS_##source: set handler and done, code=%d\n",code); \
  LOGIT("CTRIGRSS_##source: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", \
    doneRtns,trigRtns,syncTRtns,Tcode,ttypeRtns); \
}

#endif


#ifdef VXWORKS
#define LOCKINTS intLockKey = intLock();
#else
#define LOCKINTS
#endif

#ifdef VXWORKS
#define UNLOCKINTS intUnlock(intLockKey);
#else
#define UNLOCKINTS
#endif

#define CDOPOLL {cdopolldispatch();}

/*to do: make vxworks as unix */
#ifdef VXWORKS
#define CDOINIT(source) source##_INIT
#else
#define CDOINIT(source,code) source##_INIT(code)
#endif

#define CDOENABLE(source,code,val) source##_ENA(code,val)
#define CDODISABLE(source,code,val) source##_DIS(code,val)
#define CDOACK(source,code,val) source##_ACK(code,val)
#define CDOSTART(source,val) source##_START(val)
#define CDOSTOP(source,val) source##_STOP(val)

#define WRITE_EVENT_ \
  rol->dabufp = NULL; \
  /* if there is output, add event '__the_event__' to the pool */ \
  if(__the_event__) \
  { \
    if(rol->output) \
    { \
      listAdd(&(rol->output->list), __the_event__); \
	} \
    else \
	{ \
      partFreeItem(__the_event__); \
	} \
	__the_event__ = (DANODE *) 0; \
  } \
  /* if there is input, add event 'input_event__' to the pool */ \
  if(input_event__) \
  { \
    partFreeItem(input_event__); \
    input_event__ = (DANODE *) 0; \
  } \
  /* call done routine */ \
  (*doneRtns)(); \
  if (rol->pool->list.c) \
  { \
    __done(); \
    rol->doDone = 0; \
  } \
  else /* sergey: remember that we have event(s) to process ??? cdopolldispatch() will check it .. */ \
  { \
    poolEmpty = 1; \
    rol->doDone = 1; \
  }


/* Actually dispatch the triggers to the correct routines */

static void
cdodispatch(unsigned int theType)
{
  DANODE *theNode;

  dispatch_busy = 1;
  (*(rol->nevents))++;
  UNLOCKINTS;
  (*trigRtns)(theType, Tcode);
  LOCKINTS;
  WRITE_EVENT_;
  dispatch_busy = 0;
}



/* Generic interrupt handler.
This routine looks to see if the dispatcher is already running.
If dispatcher is busy the trigger is queued, this code is protected
by INTLOCK so we know the flag dispatch_busy can't change behind our backs */

static int
theIntHandler(int theSource)
{
  unsigned int theType;
  DANODE *theNode;

  if(theSource == 0) return(0);

  LOCKINTS;

  theType = (*ttypeRtns)(Tcode); 
  if(!dispatch_busy) cdodispatch(theType);

  UNLOCKINTS;
}



/* polling handler: if running in polling mode, called instead of interrupt
   handler */

static int
cdopolldispatch()
{
  unsigned int theType;
  int stat = 0;
  DANODE *theNode;

#ifdef EVENT_MODE

  (*trigRtns)(0,0);

#else

  if(!poolEmpty)
  {
    if(syncTRtns)
    {
      theNode = (DANODE *)(*syncTRtns)(Tcode);
      if(theNode)
      {
        stat = 1;
 
        LOCKINTS;

        if(!dispatch_busy)
        {
          theType = (*ttypeRtns)(Tcode);  
          cdodispatch(theType);
        }

        UNLOCKINTS;
      }
    }   
  }
  else
  {
    stat = -1;
  }

#endif

  return(stat);
}


/************************************************************************/
/************************************************************************/


static char rol_name__[40];
static char temp_string__[132];


static void
__poll()
{
  CDOPOLL;
}


#ifdef	__cplusplus
extern "C"
#endif
/*static-error in dlsym*/ void
INIT_NAME(rolParam rolp)
{
  if( (rolp->daproc != DA_DONE_PROC) && (rolp->daproc != DA_POLL_PROC) )
  {
    LOGIT("INIT_NAME: rolp->daproc = %d\n",rolp->daproc);
  }

  switch(rolp->daproc)
  {
    case DA_INIT_PROC:
	{
	  char name[40];
	  rol = rolp;
	  rolp->inited = 1;
	  strcpy(rol_name__, ROL_NAME__);
	  rolp->listName = rol_name__;
	  LOGIT("INIT_NAME: Initializing new rol structures for %s\n",rol_name__);
	  LOGIT("INIT_NAME: MAX_EVENT_LENGTH = %d bytes, MAX_EVENT_POOL = %d\n",
        MAX_EVENT_LENGTH, MAX_EVENT_POOL);
	  strcpy(name, rolp->listName);
	  strcat(name, ":pool");
      LOGIT("INIT_NAME: name >%s<\n",name);

	  rolp->inited = 1;
	  LOGIT("Init - Done\n");
	  break;
	}

    case DA_FREE_PROC:
      rolp->inited = 0;
      break;
    case DA_DOWNLOAD_PROC:
	  __download();
	  break;
    case DA_PRESTART_PROC:
	  __prestart();
	  break;
    case DA_PAUSE_PROC:
	  __pause();
	  break;
    case DA_END_PROC:
	  __end();
	  break;
    case DA_GO_PROC:
	  __go();
	  break;
    case DA_POLL_PROC:
	  __poll();
	  break;
    case DA_DONE_PROC:
	  __done();
	  break;
    default:
	  LOGIT("WARN: unsupported rol action = %d\n",rolp->daproc);
	  break;
  }
}

#endif

