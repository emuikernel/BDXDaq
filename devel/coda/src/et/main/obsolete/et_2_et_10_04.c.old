/*----------------------------------------------------------------------------*
 *  Copyright (c) 1998        Southeastern Universities Research Association, *
 *                            Thomas Jefferson National Accelerator Facility  *
 *                                                                            *
 *    This software was developed under a United States Government license    *
 *    described in the NOTICE file included as part of this distribution.     *
 *                                                                            *
 * TJNAF Data Acquisition Group, 12000 Jefferson Ave., Newport News, VA 23606 *
 *      heyes@cebaf.gov   Tel: (757) 269-7030    Fax: (757) 269-5800          *
 *----------------------------------------------------------------------------*
 * Description:
 *      ET system sample event client
 *
 * Author:
 *	Carl Timmer
 *	TJNAF Data Acquisition Group
 *
 * Revision History:
 *
 *----------------------------------------------------------------------------*/

/*

clon10:

et_start -f /tmp/et_sys_sertest -n 500 -s 100000
fpack2et /tmp/et_sys_sertest
et_2_et /tmp/et_sys_sertest /tmp/et_sys_sertest ET2ET

clon00:

et_start -f /tmp/et_sys_sertest -n 500 -s 100000
et2bos_test /tmp/et_sys_sertest TEST

*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/types.h>
#include <unistd.h>
#include <time.h>
#ifdef sun
#include <thread.h>
#endif
#include "et.h"

#ifdef CODASSIPC
#include "cinclude/codassipc.c"
#endif

#define NUMEVENTS 100
#define CHUNK 100

/* signal handler prototype */
static void *signal_thread (void *arg);

#ifdef CODASSIPC
char  project[1000];
char  session[1000];
char  unique_name[1000];

/*mutex-protected event counter*/
static int nevents;
pthread_mutex_t mutex_nevents;
#define SSTIMEINTERVAL 10.0 /* # seconds to sleep between smartsocket transactions */

/* ssipc thread */
static int force_exit;
static void *
ssipc_thread (void *arg)
{
  SSTHREAD *ssarg, ssargin;
  ssarg = (SSTHREAD *)arg;
  while(1)
  {
    pthread_mutex_lock(&mutex_nevents);
    ssarg->rate_rec = ssarg->rate_proc = ((float)nevents)/SSTIMEINTERVAL;
    nevents = 0;
    /*printf("2: rec = %f %f\n",ssarg->rate_rec,ssarg->rate_proc);*/
    /*printf("2: nev = %d %d\n\n",ssarg->nev_rec,ssarg->nev_proc);*/
    pthread_mutex_unlock(&mutex_nevents);

    ssipc_put_args(ssarg);
    ipc_check(SSTIMEINTERVAL);
    ssipc_get_args(&ssargin);
    if(force_exit)
    {
      printf("ssipc_thread: force_exit\n");
      break;
    }
  }
  force_exit = 0;
  return(0);
}

#endif

int
main(int argc,char **argv)
{
#ifdef CODASSIPC
  SSTHREAD ssarg;
  pthread_t       sid;
#endif
  sigset_t        sigblock;
  pthread_t       tid;

  int             i, j, status, numread, chunk, totalread=0, loops=0;
  int		  con[ET_STATION_SELECT_INTS], ntransferred=0;
  et_statconfig   sconfig;
  et_openconfig   openconfig;
  et_bridgeconfig bconfig;
  struct timespec timeout;
  et_att_id       att_from, att_to;
  et_stat_id      stat_from, stat_to;
  et_sys_id       id_from, id_to;
  int             selections[] = {17,15,-1,-1}; /* 17,15 are arbitrary */

  char ch[100];

 
  if (argc != 4) {
    printf("Usage: %s <from etname> <to etname> <station_name>\n",
            argv[0]);
    exit(1);
  }
  
  timeout.tv_sec  = 0;
  timeout.tv_nsec = 1;
  
#ifdef CODASSIPC
  strcpy(project,"clasprod");
  strcpy(session,"clasprod");
#endif
  /*************************/
  /* setup signal handling */
  /*************************/
  /* block all signals */
  sigfillset(&sigblock);
  status = pthread_sigmask(SIG_BLOCK, &sigblock, NULL);
  if (status != 0) {
    printf("%s: pthread_sigmask failure\n", argv[0]);
    exit(1);
  }
#ifdef sun
  /* prepare to run signal handling thread concurrently */
  thr_setconcurrency(thr_getconcurrency() + 1);
#endif
  /* spawn signal handling thread */
  pthread_create(&tid, NULL, signal_thread, (void *)NULL);

  /* init ET configuration will be used for both ET systems */
  et_open_config_init(&openconfig);

  /* open local ET */
  /* clon10: 129.57.167.14 */
  /* clon10-daq1: 129.57.68.21 */
  /* clon10-daq2: 129.57.68.22 */
  /*et_open_config_sethost(openconfig, ET_HOST_LOCAL);*/
  /*et_open_config_sethost(openconfig, "clon10-daq1");*/
  et_open_config_sethost(openconfig, "clon10");
  et_open_config_gethost(openconfig, ch);
  printf("local host >%s<\n",ch);
  if (et_open(&id_from, argv[1], openconfig) != ET_OK) {
    printf("%s: et_open 'from' problems\n", argv[1]);
    exit(1);
  }

  /* open remote ET */
  /* clon00: 129.57.167.5 */
  /* clon00-daq1: 129.57.68.1 */
  /*et_open_config_sethost(openconfig, "clon00-daq1");*/
  /*et_open_config_sethost(openconfig, "clon00-daq1");*/
  et_open_config_sethost(openconfig, "clon04");
	/*et_open_config_sethost(openconfig, "129.57.167.4");*/
  et_open_config_gethost(openconfig, ch);
  printf("remote host >%s<\n",ch);
  if (et_open(&id_to, argv[2], openconfig) != ET_OK) {
    printf("%s: et_open 'to' problems\n", argv[2]);
    exit(1);
  }

  /* destroy configuration */
  et_open_config_destroy(openconfig);








  if(0)
  {
    /* ET2ET04 station for Data Transfer */
    et_station_config_init(&openconfig);
    et_station_config_setselect(openconfig,   ET_STATION_SELECT_USER);
/*et_station_config_setblock(openconfig,    ET_STATION_BLOCKING);*/
et_station_config_setblock(openconfig,    ET_STATION_NONBLOCKING);
    et_station_config_setuser(openconfig,     ET_STATION_USER_SINGLE);
    et_station_config_setrestore(openconfig,  ET_STATION_RESTORE_OUT);
	/*
    et_station_config_setprescale(openconfig, 1);
    et_station_config_setcue(openconfig,      100);
    et_station_config_setlib(openconfig,      et_user_library);
    et_station_config_setfunction(openconfig, "et2et_function");
	*/
    if((status = et_station_create(id_from, &stat_from, "ET2ET041", openconfig)) < 0)
    {
      if(status == ET_ERROR_EXISTS)
      {
        printf("et_start: \"ET2ET041\" station exists\n");
      }
      else
      {
        printf("et_start: cannot create \"ET2ET041\" station, error=%d\n",status);
        goto error;
      }
    }
    et_station_config_destroy(openconfig);
  }
  else
  {
    /* get id and attach to existing station (must be created by 'et_start' */
    if((status = et_station_name_to_id(id_from, &stat_from, argv[3])) < ET_OK)
    {
      printf("%s: error in station_name_to_id\n", argv[0]);
      goto error;
    }
  }



  if (et_station_attach(id_from, stat_from, &att_from) < 0) {
    printf("%s: error in station attach\n", argv[0]);
    goto error;
  }

  if (et_station_attach(id_to, ET_GRANDCENTRAL, &att_to) < 0) {
    printf("%s: error in station attach\n", argv[0]);
    goto error;
  }

  et_bridge_config_init(&bconfig);
  /*et_bridge_config_setfunc(bconfig, et_bridge_CODAswap);*/




#ifdef CODASSIPC

  ssarg.project    = project;
  ssarg.session    = session;
  ssarg.rate_rec   = 0.0; 
  ssarg.rate_proc  = 0.0; 
  ssarg.nev_rec    = 0;
  ssarg.nev_proc   = 0;
  ssarg.et_ok      = 1; /* 1 if connected, 0 if not; we'll always set it 1 */
  ssarg.force_exit = 0;
  ssarg.last_time  = time(NULL);

  /*  set ipc parameters, connect to server, etc. */
  ipc_set_application(ssarg.project);
  ipc_set_quit_callback(ssipc_quit_callback);
  ipc_set_user_status_poll_callback(ssipc_status_poll_callback);
  ipc_set_control_message_callback(ssipc_control_message_callback);

  /*set unique name*/
  ssarg.data_flow = (char *)"et:ET2ETMON2->et";
  /*set unique name*/
  strcpy((char *)unique_name,(char *)"et2et_daq_mon2");

  /*add session name to the end of unique name*/
  strcat((char *)unique_name,(char *)"_");
  strcat((char *)unique_name,(char *)session);
  ssarg.unique_name = unique_name;

  /*set unique name*/
  status = ipc_init(ssarg.unique_name,"et2et from DAQ to MON2"); /* <=21 char */

  if(status < 0)
  {
    printf("\net_2_et_10_04: Unable to connect to server...probably duplicate unique name\n"
	 "   ...check for another %s connected using ipc_info\n\n",ssarg.unique_name);
    exit(1);
  }
  TipcSrvSubjectSetSubscribe((T_STR)"evt_system",TRUE);
  TipcSrvFlush();

  /* start ssipc_thread */
  nevents = 0;
  if(pthread_create(&sid, NULL, ssipc_thread, (void *)&ssarg) != 0)
  {
    printf("et_2_et: pthread_create(0x%08x,...) failure\n",sid);
    return(-1);
  }
  else
  {
    printf("et_2_et: pthread_create(0x%08x,...) done\n",sid);
  }
#endif






  /* infinite loop */
  while(status == ET_OK)
  {
    status = et_events_bridge(id_from, id_to, att_from, att_to,
			      bconfig, NUMEVENTS, &ntransferred);

#ifdef CODASSIPC
    /* fill 'ssarg' structure */
    ssarg.nev_rec   += ntransferred;
    ssarg.nev_proc  += ntransferred;

    pthread_mutex_lock(&mutex_nevents);

    /* just sum here, will normalize to time interval before sending it out */
    nevents += ntransferred;
    /*printf("1: nevents = %d\n",nevents);*/

    pthread_mutex_unlock(&mutex_nevents);

    if(ssarg.force_exit) break;
#endif
  }

#ifdef CODASSIPC
  ipc_close();
#endif

/*was:
  et_bridge_config_destroy(bconfig);

  et_forcedclose(id_from);
  et_forcedclose(id_to);
  return 0;
error:
  return -1;
*/
printf("111: status=%d\n",status);fflush(stdout);
  status = et_bridge_config_destroy(bconfig);

printf("222: status=%d\n",status);fflush(stdout);
  status = et_forcedclose(id_from);
printf("333: status=%d\n",status);fflush(stdout);
  status = et_forcedclose(id_to);
printf("444: status=%d\n",status);fflush(stdout);
  exit(1);
error:
  exit(1);
}


/************************************************************/
/*              separate thread to handle signals           */
static void * signal_thread (void *arg)
{
  sigset_t   signal_set;
  int        sig_number;
 
  sigemptyset(&signal_set);
  sigaddset(&signal_set, SIGINT);
  
  /* Not necessary to clean up as ET system will do it */
  sigwait(&signal_set, &sig_number);
  printf("et_2_et: got a control-C, exiting\n");

#ifdef CODASSIPC
  force_exit = 1; /* tell smartsocket thread to exit */
  while(force_exit) sleep(1); /* wait for smartsocket thread to exit */
#endif

  exit(1);
}




