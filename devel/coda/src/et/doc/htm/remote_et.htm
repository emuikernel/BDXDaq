<html>

<head>
<title>Remote ET</title>
<meta name="author" content="Carl Timmer">
<meta name="description" content="Chapter for ET system manual">
<meta name="copyright" content="Copyright 1999, SURA, TJNAF">
<link rel="stylesheet" href="etmanual.css" type="text/css">
<style><!--
-->
</style>
</head>

<body bgcolor="#ffffff" background="FlowBack.gif">
<h1> <a href="modifying_system.htm"><img src="left.gif" alt="Previous" width="31" height="31"></a><a href="useful_macros.htm" target="_self"><img src="right.gif" alt="Next" width="31" height="31"></a></h1>
<h1>Remote ET</h1>
<h3><a name="Remote">Remote Node Operation Overview</a></h3>
<p> It is possible to have an ET system on one machine and its consumers on another 
  (called remote consumers). Remote consumers can call all the routines that local 
  ones can. Of course, the speed of transferring events over the network is quite 
  a bit slower than the speed of accessing shared memory.</p>
<p> The way this is done is that each ET system has a server &quot;built in&quot; 
  as it were. That is, there are multiple threads in the ET system's process which 
  facilitate accessing that system from another computer. One or more of these 
  threads respond to the UDP packets from remote consumers trying to find an ET 
  system of a particular name somewhere on the network usually by broadcasting 
  or multicasting. There is one thread listening on each local subnet broadcast 
  address, one thread on each multicast address used, and one thread on each local 
  network interface address. The response is simply to send back the port number 
  of the socket that the TCP server thread is listening on and its host's name(and 
  a couple other things). This TCP server thread, when connected with a consumer, 
  is the one which handles all the receiving and sending of events and other information 
  with the consumer.</p>
<p> It is this arrangement that makes it possible to run an ET system on Linux. 
  At this point, Linux does not allow the sharing of pthread mutexes and condition 
  variables between processes. This makes it impossible to access the shared memory 
  of the ET system safely between processes. However, this problem can be circumvented 
  by treating local Linux consumers as remote consumers. The server built into 
  the ET system handles all ET routines that require handling these mutexes and 
  sends this consumer pointers to events which the consumer can then access in 
  shared memory. This makes running ET systems on Linux slower than those running 
  on Solaris. However, on the author's Linux dual 200MHz pentium pro machine, 
  an ET system which consists of a single producer and does no data copying can 
  handle events at 200kHz</p>
<p>When an ET system is started up, it's configuration can be set by using the 
  <em>et_system_config_...</em> set of routines. A call to <em><a href="user_routines.htm#et_system_config_setserverport">et_system_config_setserverport</a></em> 
  sets the port number of the ET system's tcp server thread in that particular 
  configuration. If the port is unavailable when actually starting the ET system 
  by a call to <em><a href="user_routines.htm#et_system_start">et_system_start</a></em> 
  using that same configuration, the process will exit with an error message. 
  Thus, using this routine guarantees that the ET system will have its server 
  thread at that port. Note that if the server port is NOT explicitly set in this 
  way, then by default <strong> ET_SERVER_PORT</strong> (defined as 11111 in <em>et.h</em>) 
  is used as the port number. If this port is busy, it's incremented by one and 
  tried again and so on until there is success. If it has tried 2000 port numbers 
  with no success, the process exits with an error message. Similarly, a call 
  to <a href="user_routines.htm#et_system_config_setport"><em>et_system_config_setport</em></a> 
  sets the port number of the threads listening for the UDP packets.</p>
<h3><a name="System">System Discovery</a></h3>
<p> In order to have things work seamlessly, the user needs to make some decisions. 
  First of all, the decision needs to be made whether consumers connect to ET 
  systems using a direct TCP connection by specifying host and port, or possibly 
  by using broadcasting and/or multicasting. When a consumer does not know the 
  host, broadcasting and/or multicasting is a must. If a consumer knows the name 
  of the host, however, this is forgone in favor of unicasting or directly sending 
  a UDP packet to that host and port. The response to the UDP packet contains 
  the port number and host name of the TCP server thread to which a connection 
  may be made.</p>
<h4> <a name="Direct">Direct Connection</a></h4>
<p> There are times when using either broadcasting or multicasting is inconvenient 
  or impossible. For example, if an ET system and a consumer are on different 
  subnets, broadcasting from one to the other is stopped by any routers unless 
  such are reprogrammed to allow broadcasting to get through - a hassle in any 
  case. In situations such as these, a direct connection can be made.</p>
<p>Remote consumers need to know the TCP server's port number and the host name 
  that the ET system resides on. Then using <em><a href="user_routines.htm#et_open_config_setserverport">et_open_config_setserverport</a></em> 
  the port can be set, using <em><a href="user_routines.htm#et_open_config_sethost">et_open_config_sethost</a></em> 
  the host can be set, and using <em><a href="user_routines.htm#et_open_config_setcast">et_open_config_setcast</a></em> 
  a direct connection can be specified with <strong>ET_DIRECT</strong>.</p>
<h4><a name="Broadcasting">Broadcasting</a></h4>
<p> Broadcasting is done to IP addresses which in dotted-decimal form (e.g. 128.7.6.35) 
  can be represented as {netid, subnetid, hostid}. The only type of broadcast 
  address used in ET systems is subnet-directed and is of the form {netid, subnetid,-1} 
  where -1 simply means that that part of the address is composed of all 1's in 
  binary. For example, if 128.7.6 is the subnet with a mask of 255.255.255.0, 
  then 128.6.7.255 is the broadcast address for that subnet. A broadcast will 
  be received by all machines on that particular subnet. You may find the broadcast 
  address(es) of your subnet(s) by using the command &quot;ifconfig -a&quot;.</p>
<p> An ET system automatically responds to broadcasts on all its local subnets 
  and no configuration is necessary or possible.</p>
<p>An ET consumer, by default, broadcasts on all its local subnets to find ET 
  systems. Otherwise, one can use the <em><a href="user_routines.htm#et_open_config_setcast">et_open_config_setcast</a></em> 
  routine to set the configuration to a setting of <strong> ET_BROADCAST</strong> 
  or <strong>ET_BROADANDMULTICAST</strong> to do so. Call <em><a href="user_routines.htm#et_open_config_addbroadcast">et_open_config_addbroadcast</a></em> 
  to add a specific broadcast address to the list of active broadcast addresses. 
  Use it with a value of <strong>ET_SUBNET_ALL</strong> to add all the local broadcast 
  addresses to the list (the default remember), and use it with the value <strong>ET_SUBNET_DEFAULT</strong> 
  to add the broadcast address associated with the hostname returned as a result 
  of&nbsp; executing &quot;uname&quot;. Likewise, call <em><a href="user_routines.htm#et_open_config_removebroadcast">et_open_config_removebroadcast</a></em> 
  to remove addresses from the active list.</p>
<h4><a name="Multicasting">Multicasting</a></h4>
<p> In multicasting a consumer sends out a packet to a special multicast IP address. 
  The listeners (ET systems) sign up to receive any packets send to that address 
  and only computers hosting such listeners will receive the packets - not all 
  machines on the subnet as is the case in broadcasting. Multicasting has the 
  ability to go beyond the local subnet and thus is more flexible than broadcasting. 
  The following table lists all available multicast addresses as well as &quot;TTL&quot; 
  values (reproduced from <u> Unix Network Programming</u>, Volume 1 by Richard 
  Stevens):</p>
<div align="center"> 
  <center>
    <table border="3" bordercolor="#0000FF" cellpadding="5" cellspacing="1">
      <tr> 
        <td width="108" height="70" rowspan="2" align="center"><strong>Scope</strong></td>
        <td width="60" height="70" rowspan="2" align="center"><strong>IPv6 Scope</strong></td>
        <td width="314" height="34" colspan="2" align="center"><strong>IPv4</strong></td>
      </tr>
      <tr> 
        <td width="88" height="28" align="center"><strong>TTL Scope</strong></td>
        <td width="220" height="28" align="center"><strong>Administrative Scope</strong></td>
      </tr>
      <tr> 
        <td width="108" height="29">node-local</td>
        <td width="60" height="29">1</td>
        <td width="88" height="29">0</td>
        <td width="220" height="29">&nbsp;</td>
      </tr>
      <tr> 
        <td width="108" height="29">link-local</td>
        <td width="60" height="29">2</td>
        <td width="88" height="29">1</td>
        <td width="220" height="29"> 224.0.0.0 to 224.0.0.225</td>
      </tr>
      <tr> 
        <td width="108" height="28">site-local</td>
        <td width="60" height="28">5</td>
        <td width="88" height="28">&lt;32</td>
        <td width="220" height="28">239.255.0.0 to 239.255.255.255</td>
      </tr>
      <tr> 
        <td width="108" height="32">organization-local</td>
        <td width="60" height="32">8</td>
        <td width="88" height="32">&nbsp;</td>
        <td width="220" height="32"> 239.192.0.0 to 239.195.255.255</td>
      </tr>
      <tr> 
        <td width="108" height="28">global</td>
        <td width="60" height="28">14</td>
        <td width="88" height="28">&lt;255</td>
        <td width="220" height="28"> 224.0.1.0 to 238.255.255.255</td>
      </tr>
    </table>
  </center>
</div>
<p> Although this author is NOT an expert ..., the use of TTL values and ranges 
  of addresses is meant to set the range or the scope of the multicasts. The use 
  of setting the TTL value for scoping is accepted and even recommended practice 
  with a default value of one meaning the local subnet only. However, administrative 
  scoping is preferred when possible. The range 239.0.0.0 to 239.25.255.255 is 
  the administratively scoped IPv4 multicast space. &quot;Addresses in this range 
  are assigned locally by an organization but are not guaranteed to be unique 
  across organizational boundaries. An organization must configure its boundary 
  routers (multicast routers at the boundary of the organization) not to forward 
  multicast packets destined to any of these addresses&quot;.</p>
<p> In short, pick an address between 239.0.0.0 and 239.25.255.255 for use at 
  one particular site. If this is confusing, talk to your system administrator 
  and ask for a safe multicast address for your use.</p>
<p> According to Harold in <u>Java Network Programming</u>, the Internet Assigned 
  Numbers Authority (IANA) is responsible for handing out permanent multicast 
  addresses as needed and do so manually as demand is still small. The following 
  is a table, taken from the mentioned book, showing some of the taken multicast 
  addresses:&nbsp;</p>
<div align="center"> 
  <center>
    <table border="3" bordercolor="#0000FF" width="602" cellpadding="5" cellspacing="1">
      <tr> 
        <td width="269" height="35" valign="middle" align="center"><strong>Domain 
          Name</strong></td>
        <td width="93" height="35" valign="middle" align="center"><strong>IP Address</strong></td>
        <td width="214" height="35" valign="middle" align="center"><strong>Purpose</strong></td>
      </tr>
      <tr> 
        <td width="269" height="35" valign="middle">BASE-ADDRESS.MCAST.NET</td>
        <td width="93" height="35" valign="middle">224.0.0.0</td>
        <td width="214" height="35" valign="middle">Reserved base address - never 
          assigned</td>
      </tr>
      <tr> 
        <td width="269" height="35" valign="middle">ALL-SYSTEMS.MCAST.NET</td>
        <td width="93" height="35" valign="middle">224.0.0.1</td>
        <td width="214" height="35" valign="middle">All systems on the local subnet</td>
      </tr>
      <tr> 
        <td width="269" height="35" valign="middle">ALL-ROUTERS.MCAST.NET</td>
        <td width="93" height="35" valign="middle">224.0.0.2</td>
        <td width="214" height="35" valign="middle">All routers on the local subnet</td>
      </tr>
      <tr> 
        <td width="269" height="35" valign="middle">DVMRP.MCAST.NET</td>
        <td width="93" height="35" valign="middle">224.0.0.4</td>
        <td width="214" height="35" valign="middle">All Distance Vector Multicast 
          Routing Protocol routers on this subnet</td>
      </tr>
      <tr> 
        <td width="269" height="35" valign="middle">MOBILE-AGENTS.MCAST.NET</td>
        <td width="93" height="35" valign="middle">224.0.0.11</td>
        <td width="214" height="35" valign="middle">Mobile-Agents on the local 
          subnet</td>
      </tr>
      <tr> 
        <td width="269" height="35" valign="middle">DHCP-AGENTS.MCAST.NET</td>
        <td width="93" height="35" valign="middle">224.0.0.12</td>
        <td width="214" height="35" valign="middle">Allows client to locate DHCP 
          server on local subnet</td>
      </tr>
      <tr> 
        <td width="269" height="36" valign="middle">PIM-ROUTERS.MCAST.NET</td>
        <td width="93" height="36" valign="middle">224.0.0.13</td>
        <td width="214" height="36" valign="middle">All Protocol Independent Multicasting 
          routers on this subnet</td>
      </tr>
      <tr> 
        <td width="269" height="36" valign="middle">RSVP-ENCAPSULATION.MCAST.NET</td>
        <td width="93" height="36" valign="middle">224.0.0.14</td>
        <td width="214" height="36" valign="middle">RSVP-ENCAPSULATION on this 
          subnet</td>
      </tr>
      <tr> 
        <td width="269" height="36" valign="middle">NTP.MCAST.NET</td>
        <td width="93" height="36" valign="middle">224.0.1.1</td>
        <td width="214" height="36" valign="middle">Network Time Protocol</td>
      </tr>
      <tr> 
        <td width="269" height="36" valign="middle">SGI-DOG.MCAST.NET</td>
        <td width="93" height="36" valign="middle">224.0.1.2</td>
        <td width="214" height="36" valign="middle">Silicon Graphics Dogfight 
          game</td>
      </tr>
      <tr> 
        <td width="269" height="36" valign="middle">NSS.MCAST.NET</td>
        <td width="93" height="36" valign="middle">224.0.1.6</td>
        <td width="214" height="36" valign="middle">Name Service Center</td>
      </tr>
      <tr> 
        <td width="269" height="36" valign="middle">AUDIONEWS.MCAST.NET</td>
        <td width="93" height="36" valign="middle">224.0.1.7</td>
        <td width="214" height="36" valign="middle">Audio News multicast</td>
      </tr>
      <tr> 
        <td width="269" height="36" valign="middle">SUB-NIS.MCAST.NET</td>
        <td width="93" height="36" valign="middle">224.0.1.8</td>
        <td width="214" height="36" valign="middle">Sun's NIS+ Information Service</td>
      </tr>
      <tr> 
        <td width="269" height="36" valign="middle">MTP.MCAST.NET</td>
        <td width="93" height="36" valign="middle">224.0.1.9</td>
        <td width="214" height="36" valign="middle">Multicast Transport Protocol</td>
      </tr>
      <tr> 
        <td width="269" height="36" valign="middle">&nbsp;</td>
        <td width="93" height="36" valign="middle">224.0.1.10 -<br>
          224.0.1.19</td>
        <td width="214" height="36" valign="middle">Stuff</td>
      </tr>
      <tr> 
        <td width="269" height="36" valign="middle">EXPERIMENT.MCAST.NET</td>
        <td width="93" height="36" valign="middle">224.0.1.20</td>
        <td width="214" height="36" valign="middle">Experiments that do NOT go 
          beyond the local subnet.</td>
      </tr>
      <tr> 
        <td width="269" height="36" valign="middle"></td>
        <td width="93" height="36" valign="middle">224.0.1.23 -<br>
          224.0.1.32</td>
        <td width="214" height="36" valign="middle">Stuff</td>
      </tr>
      <tr> 
        <td width="269" height="36" valign="middle"></td>
        <td width="93" height="36" valign="middle">224.0.6.000 -<br>
          224.0.6.127</td>
        <td width="214" height="36" valign="middle">ISIS project for robust software 
          development</td>
      </tr>
      <tr> 
        <td width="269" height="36" valign="middle"></td>
        <td width="93" height="36" valign="middle">224.0.9.000 -<br>
          224.0.9.255</td>
        <td width="214" height="36" valign="middle">Internet Railroad project 
          - 45Mbit/sec backbone</td>
      </tr>
      <tr> 
        <td width="269" height="36" valign="middle"></td>
        <td width="93" height="36" valign="middle">224.2.0.0 -<br>
          224.2.255.255</td>
        <td width="214" height="36" valign="middle">MBONE</td>
      </tr>
    </table>
  </center>
</div>
<p> An ET system can respond to multicasts on up to <strong>ET_MAXADDRESSES</strong> 
  (defined in <em>et_private.h</em> as 10) multicast addresses. Add an address 
  with <em><a href="user_routines.htm#et_system_config_addmulticast">et_system_config_addmulticast</a></em> 
  and remove it with <em><a href="user_routines.htm#et_system_config_removemulticast">et_system_config_removemulticast</a></em>.</p>
<p>An ET consumer can multicast by using the <em><a href="user_routines.htm#et_open_config_setcast">et_open_config_setcast</a></em> 
  routine to set the configuration to a setting of <strong>ET_MULTICAST</strong> 
  or ET_BROADANDMULTICAST. Call <em><a href="user_routines.htm#et_open_config_addmulticast">et_open_config_addmulticast</a></em> 
  to add a specific multicast address to the list of active addresses. Likewise, 
  call <em><a href="user_routines.htm#et_open_config_removemulticast">et_open_config_removemulticast</a></em> 
  to remove addresses from the list. Use <em><a href="user_routines.htm#et_open_config_setTTL">et_open_config_setTTL</a></em> 
  to set the TTL value of the multicast.</p>
<p>Both broadcasting and multicasting may be done simultaneously by specifying 
  ET_BROADANDMULTICAST as an argument for <em>et_open_config_setcast</em>.</p>
<h4><a name="Port">Port Selection for Broad/Multicasting</a></h4>
<p> In addition to choosing broadcasting and/or multicasting and choosing the 
  address, the user must also choose the port number for these communications. 
  The Internet Assigned Numbers Authority (IANA) states that the range of port 
  numbers from 0 to 1023 are controlled and assigned by the IANA. Thus, these 
  are unavailable. The ports 1024 to 49151 are NOT controlled by the IANA and 
  are available for use, but the IANA registers and lists the uses of these ports 
  as a convenience to the internet community. For example, ports 6000 to 6063 
  are assigned for an X window server for both TCP and UDP. Generally, the higher 
  numbered ports are less likely to be used. Finally, ports 49152 to 65535 are 
  called dynamic or private or ephemeral ports. The IANA says nothing about these.</p>
<p> Use the routine <em><a href="user_routines.htm#et_system_config_setport">et_system_config_setport</a></em> 
  to configure an ET system to listen for broad/multicasts on a particular port. 
  Use <em><a href="user_routines.htm#et_open_config_setport">et_open_config_setport</a></em> 
  to configure a consumer to send broadcasts and <em><a href="user_routines.htm#et_open_config_setmultiport">et_open_config_setmultiport</a></em> 
  to send multicasts on a particular port. The port numbers used by the consumer 
  must be the same as those used by the ET system for things to work. By default, 
  if not set explicitly, they are set to <strong> ET_BROADCAST_PORT</strong> and 
  <strong>ET_MULTICAST_PORT</strong> respectively (both defined as 11111 in <em>et.h</em>).</p>
<h4><a name="Defaults">Defaults &amp; Macros</a></h4>
<p> When defining a configuration to use in opening an ET system, the defaults 
  are to use broadcasting only to port ET_BROADCAST_PORT (defined as 11111 in 
  <em>et.h</em>) on all local subnet addresses. If the automatic finding of subnets 
  fails, a value of <strong> ET_BROADCAST_ADDR</strong> is used (defined as &quot;129.57.35.255&quot; 
  in <em>et.h</em> - the author's personal subnet). The macro <strong> ET_MULTICAST_PORT</strong> 
  is also similarly defined to be 11111, while the macro <strong> ET_MULTICAST_ADDR</strong> 
  is defined to be &quot;239.200.0.0&quot;. The value of <strong> ET_MULTICAST_TTL</strong> 
  is one. All of these macros are only defined for the users' convenience.</p>
<h4><a name="Examples">Examples</a></h4>
<p> <strong> When setting up an ET system, very little needs to be done to allow 
  it to be discovered by broadcasting consumers:</strong></p>
<p><code>et_sys_id id;<br>
  et_sysconfig config;<br>
  <br>
  /* initialize configuration */<br>
  et_system_config_init(&amp;config);<br>
  /* listen to broadcasts by default */<br>
  /* start ET system */<br>
  et_system_start(&amp;id, config);<br>
  /* release configuration's allocated memory */<br>
  et_system_config_destroy(config);</code></p>
<p> <strong> When setting up an ET system for both broadcasting and multicasting, 
  try the following:</strong></p>
<p><code> et_sys_id id;<br>
  et_sysconfig config;<br>
  <br>
  /* initialize configuration */<br>
  et_system_config_init(&amp;config);<br>
  /* already listening for broadcasts */<br>
  /* listen for multicasts to these 2 addresses */<br>
  et_system_config_addmulticast(config, ET_MULTICAST_ADDR);<br>
  et_system_config_addmulticast(config, &quot;239.111.222.0&quot;);<br>
  /* start ET system */<br>
  et_system_start(&amp;id, config);<br>
  /* release configuration's allocated memory */<br>
  et_system_config_destroy(config);</code></p>
<p> <strong> When setting up an ET system with specified ports, try the following:</strong></p>
<p><code> et_sys_id id;<br>
  et_sysconfig config;<br>
  <br>
  /* initialize configuration */<br>
  et_system_config_init(&amp;config);<br>
  /* remote users broad/multicast to this port */<br>
  et_system_config_setport(config, ET_BROADCAST_PORT);<br>
  /* set port of tcp server thread */<br>
  et_system_config_setserverport(config, 11222);<br>
  /* start ET system */<br>
  et_system_start(&amp;id, config);<br>
  /* release configuration's allocated memory */<br>
  et_system_config_destroy(config);</code></p>
<p> <strong> When setting up a consumer to open an ET system on an unknown host 
  which may be anywhere (local or remote), and it's trying to find that system 
  using broadcasting, then include the following code:</strong></p>
<p><code> et_sys_id id;<br>
  et_openconfig config;<br>
  <br>
  /* initialize configuration */<br>
  et_open_config_init(&amp;config);<br>
  /* broadcast</code>ing by default<code> */<br>
  /* ET is on an unknown host */<br>
  et_open_config_sethost(config, ET_HOST_ANYWHERE);<br>
  /* open the ET system */<br>
  et_open(&amp;id, &quot;et_name&quot;, config);<br>
  /* release configuration's allocated memory */<br>
  et_open_config_destroy(config);&nbsp;</code></p>
<p> <strong> When setting up a consumer that knows the ET system is on a different 
  host, and is trying to find it using multicasting on port ET_MULTICAST_PORT 
  at address ET_MULTICAST_ADDR, then include the following code:</strong>&nbsp;</p>
<p><code> et_sys_id id;<br>
  et_openconfig config;<br>
  <br>
  /* initialize configuration */<br>
  et_open_config_init(&amp;config);<br>
  /* ET is remote */<br>
  et_open_config_sethost(config, ET_HOST_REMOTE);<br>
  /* use multicast to find ET system */<br>
  et_open_config_setcast(config, ET_MULTICAST);<br>
  /* remote users multicast to this port */<br>
  et_open_config_setmultiport(config, ET_MULTICAST_PORT);<br>
  /* remote users multicast to this address */<br>
  et_open_config_addmulticast(config, ET_MULTICAST_ADDR);<br>
  /* open the ET system */<br>
  et_open(&amp;id, &quot;et_name&quot;, config);<br>
  /* release configuration's allocated memory */<br>
  et_open_config_destroy(config);</code></p>
<p> <strong> When setting up a consumer that knows the name of the host running 
  the ET system (ethost.mylab.org) but nothing else, and is trying to find that 
  system using both broadcasting and multicasting at address 239.235.89.12, then 
  include the following code:</strong>&nbsp;</p>
<p><code> et_sys_id id;<br>
  et_openconfig config;<br>
  <br>
  /* initialize configuration */<br>
  et_open_config_init(&amp;config);<br>
  /* ET is running on ethost.mylab.org */<br>
  et_open_config_sethost(config, &quot;ethost.mylab.org&quot;);<br>
  /* use broad and multicasting to find ET system */<br>
  et_open_config_setcast(config, ET_BROADANDMULTICAST);<br>
  /* remote users multicast to this address */<br>
  et_open_config_addmulticast(config, &quot;239.235.89.12&quot;);<br>
  /* open the ET system */<br>
  et_open(&amp;id, &quot;et_name&quot;, config);<br>
  /* release configuration's allocated memory */<br>
  et_open_config_destroy(config);</code></p>
<p> <strong> When setting up a consumer to open an ET system on a known host (129.182.54.67), 
  and trying to directly connect to it on server port 12345 (bypassing all UDP 
  communications), then include the following code:</strong></p>
<p><code> et_sys_id id;<br>
  et_openconfig config;<br>
  <br>
  /* initialize configuration */<br>
  et_open_config_init(&amp;config);<br>
  /* ET is on 129.182.54.67 */<br>
  et_open_config_sethost(config, &quot;129.182.54.67&quot;);<br>
  /* use a direct connection to the ET system */<br>
  et_open_config_setcast(config, ET_DIRECT);<br>
  /* ET system's server is on this port */<br>
  et_open_config_setserverport(config, 12345);<br>
  /* open the ET system */<br>
  et_open(&amp;id, &quot;et_name&quot;, config);<br>
  /* release configuration's allocated memory */<br>
  et_open_config_destroy(config);&nbsp;</code></p>
<h3><a name="Details">Remote Programming Details</a></h3>
<h4><a name="Errors">Errors</a></h4>
<p>As mentioned previously, <strong>ET_ERROR_NOREMOTE</strong> is the error returned 
  when calling a routine which is not supported for remote use. Currently, however, 
  there are no routines which return this error. Some remote user errors are given 
  by <strong>ET_ERROR_REMOTE</strong> - those errors which are unique to a remote 
  user and do not occur locally. In practice, this error is returned when memory 
  cannot be allocated by the remote user. If there are errors in reading or writing 
  over the network, the errors generated will be <strong>ET_ERROR_READ</strong> 
  or <strong>ET_ERROR_WRITE</strong>.</p>
<h4><a name="Behavior">Remote Behavior on a Local Host</a></h4>
<p>It is possible to tell consumers to run the code that a remote consumer runs 
  even if it is running on the same computer as the ET system. In this case, all 
  communication with the ET system is done through sockets with no usage of the 
  shared memory. This is done by calling <em><a href="user_routines.htm#et_open_config_setmode">et_open_config_setmode</a></em> 
  with the <strong> ET_HOST_AS_REMOTE</strong> option. The default mode is <strong>ET_HOST_AS_LOCAL</strong>.</p>
<h4><a name="Modifying">Modifying Events</a></h4>
<p>After opening an ET system, creating a station, and attaching to it, users 
  are ready to start reading events. There are a few details to keep in mind when 
  doing so remotely.</p>
<p>Remote users can gain quite a bit of efficiency by minimizing communication 
  with the ET system. The minimizing of communication is done transparently and 
  is the default mode of operation. That is, when a remote user calls <em>et_event(s)_get</em>, 
  the ET system copies the events and sends them over the network to the user 
  but also immediately puts them back into the ET system with a call to <em>et_event(s)_put</em>. 
  There may be times, however, when a user first wishes to modify the events and 
  then send them back over the network to the ET system. To aid in this effort 
  an extra flag is introduced, <strong>ET_MODIFY</strong>. By ORing this flag 
  to ET_SLEEP, ET_TIMED, or ET_ASYNC, the user announces an intention to modify 
  the requested event. Thus, when the ET server initially gets the event for the 
  remote user, it does NOT put it back into the ET system immediately afterwards. 
  It waits until the user has called <em>et_event(s)_put</em> before doing that. 
  Without this flag, the server puts the events back into the ET system immediately.</p>
<p>There may be occasions when the remote user doesn't want to modify the data 
  but only the header information such as the priority, control words, and such. 
  In that case it makes no sense to send all the data back to the ET system when 
  putting the event back. By using the flag <strong>ET_MODIFY_HEADER</strong> 
  instead of ET_MODIFY, only the header information will be sent back - speeding 
  up communication greatly.</p>
<h4><a name="Multi-Threading">Multi-Threading</a></h4>
<p>If a remote consumer is a multi-threaded program, no special precautions are 
  necessary as the ET library is thread-safe. However, if more than one thread 
  uses the same ET system id (<em>et_open</em> called only once), there will be 
  a bottle neck as only one remote ET library function call at at time can be 
  made. To avoid this problem, each thread that wants access to the ET system 
  needs to do its own <i>et_open</i> and thus communicate on its own socket to 
  its own server thread. This should speed things up.</p>
<h3><a name="Swapping">Swapping Data</a></h3>
<p>Transferring data between machines where one is big endian (the most significant 
  byte is placed in the lowest memory address) and the other is little endian 
  (the least significant byte is placed in the lowest memory address), requires 
  the data to be &quot;swapped&quot;. Since in general a user may not be knowledgeable 
  about the machine on which a particular event was originally produced, a simple 
  call to the function <em><a href="user_routines.htm#et_event_needtoswap">et_event_needtoswap</a>(et_event 
  *pe, int *swap)</em> will reveal whether the data needs to be swapped or not. 
  If the return value placed in <em>swap</em> is <strong>ET_NOSWAP</strong>, no 
  swapping is necessary; however, if the return value is <strong> ET_SWAP</strong>, 
  then the opposite is true.</p>
<p>The ET system automatically keeps track of the endianness of an event's data. 
  However, the user may want to forcibly set the data's endianness for some reason. 
  In that case, a call to <em><a href="user_routines.htm#et_event_setendian">et_event_setendian</a>(et_event 
  *pe, int endian)</em> can be made. The endianness can be set to <strong>ET_ENDIAN_BIG</strong>, 
  <strong>ET_ENDIAN_LITTLE</strong>, <strong>ET_ENDIAN_LOCAL</strong> (same endian 
  as local host), <strong>ET_ENDIAN_NOTLOCAL</strong> (opposite endian as local 
  host), or <strong>ET_ENDIAN_SWITCH</strong> (switch the endian from whatever 
  it is). This routine does NOT swap the data but simply keeps track of the data's 
  endianness in the event's header. A user may also read the endianness of an 
  event's data by a call to <em><a href="user_routines.htm#et_event_getendian">et_event_getendian</a>(et_event 
  *pe, int *endian)</em>. It returns either ET_ENDIAN_BIG or ET_ENDIAN_LITTLE.</p>
<p>The routine <em><a href="user_routines.htm#et_event_CODAswap">et_event_CODAswap</a>(et_event 
  *pe)</em> is provided for those who need to swap data in CODA format. The data 
  is manipulated in the existing event's data buffer so that the function irreversibly 
  mangles the data.</p>
<p><strong>Users of data formats other than CODA format must provide their own 
  swapping routines.</strong></p>
<p>Another routine of interest is <em><a href="user_routines.htm#et_system_getlocality">et_system_getlocality</a>(et_sys_id 
  id, int *locality)</em>. This returns the value <strong> ET_REMOTE</strong> 
  in the variable <em>locality</em> if the ET system is remote, <strong> ET_LOCAL</strong> 
  if it is local, and <strong> ET_LOCAL_NOSHARE</strong> is it is local but is 
  using an operating system which does not allow sharing of pthread mutexes across 
  processes (e.g. Linux).</p>
<h3><a name="Transferring">Transferring Events Between Two ET Systems</a></h3>
<p>While it is certainly possible for a user to copy events from one ET system 
  and place them in another with &quot;normal&quot; ET function calls, the ET 
  system provides a more efficient way to do this. By using ET's bridging software, 
  unnecessary coping of the data may be eliminated from the procedure. Regardless 
  of whether the ET systems are on the same or different computers or if the process 
  running the bridging routine is on one or the other or on yet a third machine, 
  the transfer should take place smoothly. It will save time except perhaps when 
  both ET systems and the bridging process are on the same machine in which case 
  only a single copy of the data is made - no different than when using the &quot;normal&quot; 
  ET function calls. A call to the following function will take care of all the 
  details:</p>
<p><em><a href="user_routines.htm#et_events_bridge">et_events_bridge</a>(et_sys_id 
  id_from, et_sys_id id_to, et_att_id att_from, et_att_id att_to, int num, int 
  *ntransferred, et_bridgeconfig bconfig)</em>.</p>
<p>The arguments are respectively: the ID of the ET system from which the events 
  are copied, the ID of the ET system to which the events are going, the attachment 
  to a station on the &quot;from&quot; ET system, the attachment to a station 
  on the &quot;to&quot; ET system (usually an attachment to GrandCentral), the 
  total number of events desired to be transferred, the total number of events 
  that were actually transferred at the routine's return, and a configuration 
  argument that will be described shortly. The configuration argument may be NULL 
  in which case defaults are used.</p>
<p>The configuration for bridging events is very similar to the configuration 
  for opening a system or creating a system. There are a number of functions used 
  to create and define the <i>config</i> argument. It is initialized by a call 
  to <em><a href="user_routines.htm#et_bridge_config_init">et_bridge_config_init</a> 
  (et_bridgeconfig *config)</em>. When the user is finished using the configuration, 
  <i><a href="user_routines.htm#et_bridge_config_destroy">et_bridge_config_destroy</a> 
  (et_bridgeconfig config)</i> must be called in order to properly release all 
  memory used.</p>
<p>After initialization, calls can be made to functions which set various properties 
  of the specific configuration. Calls to these setting functions will fail unless 
  the configuration is first initialized. The functions used to SET these properties 
  are listed below along with an explanation for each:</p>
<ol>
  <li><em><a href="user_routines.htm#et_bridge_config_setmodefrom">et_bridge_config_setmodefrom</a>(et_bridgeconfig 
    config, int val)</em> : setting <em>val</em> to ET_SLEEP, ET_TIMED, or ET_ASYNC 
    determines the mode of getting events from the &quot;from&quot; ET system. 
    The default is ET_SLEEP.</li>
  <li><em><a href="user_routines.htm#et_bridge_config_setmodeto">et_bridge_config_setmodeto</a>(et_bridgeconfig 
    config, int val)</em> :&nbsp; setting <em>val</em> to ET_SLEEP, ET_TIMED, 
    or ET_ASYNC determines the mode of getting new events from the &quot;to&quot; 
    ET system. The default is ET_SLEEP.</li>
  <li><em><a href="user_routines.htm#et_bridge_config_setchunkfrom">et_bridge_config_setchunkfrom</a>(et_bridgeconfig 
    config, int val)</em> : setting <em>val</em> sets the maximum number of events 
    to get from the &quot;from&quot; ET system in a single call to et_events_get 
    - the chunk size if you will. The default is 100.</li>
  <li><em><a href="user_routines.htm#et_bridge_config_setchunkto">et_bridge_config_setchunkto</a>(et_bridgeconfig 
    config, int val)</em> : setting <em>val</em> sets the maximum number of new 
    events to get from the &quot;to&quot; ET system in a single call to et_events_new 
    - the chunk size if you will. The default is 100.</li>
  <li><em><a href="user_routines.htm#et_bridge_config_settimeoutfrom">et_bridge_config_settimeoutfrom</a>(et_bridgeconfig 
    config, struct timespec val)</em> : setting <em>val</em> sets the time to 
    wait for the &quot;from&quot; ET system when the mode is set to ET_TIMED. 
    The default is 0 sec.</li>
  <li><em><a href="user_routines.htm#et_bridge_config_settimeoutto">et_bridge_config_settimeoutto</a>(et_bridgeconfig 
    config, struct timespec val)</em> : setting <em>val</em> sets the time to 
    wait for the &quot;to&quot; ET system when the mode is set to ET_TIMED. The 
    default is 0 sec.</li>
  <li><em><a href="user_routines.htm#et_bridge_config_setfunc">et_bridge_config_setfunc</a>(et_bridgeconfig 
    config, ET_SWAP_FUNCPTR func)</em> : setting <em>func</em> to a function pointer 
    (function name) means that the function will be called to swap data whenever 
    it's determined to be necessary. Using this feature is a convenient way of 
    swapping data while it's being moved from one ET system to another with no 
    intervention from the user needed. The function must be of the form: <strong>int 
    func(et_event *src, et_event *dest, int bytes, int same_endian)</strong> . 
    It returns ET_OK if successful otherwise ET_ERROR. The arguments consists 
    of: <em>src</em> which is a pointer to the event whose data is to be swapped, 
    <em>dest</em> which is a pointer to the event where the swapped data goes, 
    <em>bytes</em> which tells the length of the data in bytes, and <em>same_endian</em> 
    which is a flag equalling one if the machine and the data are of the same 
    endian and zero otherwise. This function must be able to work with <em>src</em> 
    and <em>dest </em>being the same event. With this as a prototype, the user 
    can write a routine which swaps data in the appropriate manner. Notice that 
    the first two arguments are pointers to events and not data buffers. This 
    allows the writer of such a routine to have access to any of the event's header 
    information. In general, such functions should NOT call <em>et_event_setendian</em> 
    in order to change the registered endian value of the data. This is already 
    taken care of&nbsp; in <em>et_events_bridge</em>. The default is NULL which 
    means no swapping is done.</li>
  <li><em><a href="user_routines.htm#et_bridge_CODAswap">et_bridge_CODAswap</a>(et_event 
    *src, et_event *dest, int bytes, int same_endian)</em> : this is a function 
    that can be used in <em> et_bridge_config_setfunc</em> if the user wants to 
    swap CODA format data.</li>
</ol>
<p>There are corresponding <em>et_bridge_config_get...</em> functions to get the 
  configuration values of everything except the swapping function.</p>
<p><a href="modifying_system.htm"><img src="left.gif" alt="Previous" width="31" height="31"></a><a href="useful_macros.htm"><img src="right.gif" alt="Next" width="31" height="31"></a></p>
</body>
</html>
