

/* tcpServer.c - TCP server example */ 
/* DESCRIPTION This file contains the server-side of the VxWorks TCP example code. 
   The example code demonstrates the usage of several BSD 4.4-style socket routine calls. */ 

#ifdef VXWORKS

#include <vxWorks.h>
#include <sockLib.h>
#include <inetLib.h>
#include <taskLib.h>
#include <stdioLib.h>
#include <strLib.h>
#include <ioLib.h>
#include <sys/types.h>
#include <sys/socket.h>

#else

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#include <fcntl.h>
#include <assert.h>
#include <errno.h>
#include <limits.h>

#ifdef Linux
#include <linux/prctl.h>
#endif

#endif

#include "libtcp.h" 
#include "libdb.h" 

/* readiness flag */
static int request_in_progress;

/* task flag */
static int iTaskTCP;

/* function declarations */ 
char *targetName(); /* from roc_component.c */
void tcpServerWorkTask(TWORK *targ); 
int TcpServer(void);

#ifdef VXWORKS

extern int execute();

#else

#include <dlfcn.h>
#include "mempart.h"

/* currently processed message */
static char current_message[REQUEST_MSG_SIZE];

char localname[128];

int
linux_execute(char *command)
{
  int res;
  void *handler;
  VOIDFUNCPTR command_ptr;

  /* open symbol table */
  handler = dlopen(NULL, RTLD_NOW | RTLD_GLOBAL);
  if(handler == 0)
  {
	printf("linux_execute ERROR: dlopen failed on >%s<\n",dlerror());
    return(-1);
  }

  /* find symbol */
  res = dlsym(handler, command);
  command_ptr = (VOIDFUNCPTR) res;
  if((res != (-1)) && (res != 0))
  {
    printf("INFO: >%s()< routine found\n",command);
  }
  else
  {
    printf("ERROR: dlsym returned %d\n",res);
    printf("ERROR: >%s()< routine not found\n",command);
    return(-1);
  }

  printf("linux_execute: Executing >%s<\n",command);
  /* execute command */
  (*(command_ptr)) ();


  /* close symbol table */
  if(dlclose((void *)handler) != 0)
  {
    printf("ERROR: failed to unload >%s<\n",command);
    return(-1);
  }

  return(0);
}
#endif

/**************************************************************************** 
* * tcpServer - accept and process requests over a TCP socket 
* * This routine creates a TCP socket, and accepts connections over the socket 
* from clients. Each client connection is handled by spawning a separate 
* task to handle client requests. 
* * This routine may be invoked as follows: 
* -> sp tcpServer
* task spawned: id = 0x3a6f1c, name = t1 
* value = 3829532 = 0x3a6f1c 
* -> MESSAGE FROM CLIENT (Internet Address 150.12.0.10, port 1027): 
* Hello out there 
* * RETURNS: Never, or ERROR if a resources could not be allocated. */ 


#ifdef VXWORKS
int
tcpServer(void)
{
  int iii;

  /* enter infinite loop */
  while(1)
  {
    taskDelay(sysClkRateGet()); /* 1 sec sleep */

    /* check if TCPSERVER task exist; if it does, check it health and kill
     if it is suspended */
    iii = taskIdVerify(iTaskTCP);
    /*printf("taskIdVerify returns %d\n",iii);*/
    if(iii==OK) /* check task status */
    {
      /* if task suspended, delete it */
      iii = taskIsSuspended(iTaskTCP); /* returns TRUE if suspended */
  	  if(iii==TRUE)
      {
        printf("INFO(tcpServer): task is suspended, calling taskDelete(%d)\n",iTaskTCP);
        iii = taskDelete(iTaskTCP);
        printf("taskDelete() returns %d\n",iii);
        iTaskTCP = 0;
        taskDelay(5*sysClkRateGet());
	  }
      else
	  {
        /*printf("INFO(tcpServer): task is Ok\n")*/;
	  }
    }
    else
    {
      iTaskTCP = taskSpawn("TCPSERVER", 251, 0, 100000, TcpServer,
                          0, 0, 0,0,0,0,0,0,0,0);
      printf("taskSpawn(\"TCPSERVER\") returns %d\n",iTaskTCP);
    }
  }
}
#else
int
tcpServer(char *name)
{
  int id;

  strcpy(localname,name);

  pthread_attr_t attr;
  pthread_attr_init(&attr); /* initialize attr with default attributes */
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
  pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
  pthread_create(&id, &attr, TcpServer, NULL);
}
#endif

#ifndef VXWORKS
#define TRUE  1
#define FALSE 0
#define OK 0
#define ERROR (-1)
#define STATUS int
#endif


int
TcpServer(void)
{ 
  struct sockaddr_in serverAddr; 
  struct sockaddr_in clientAddr; 
  int sockAddrSize;              /* size of socket address structure */ 
  int sFd;                       /* socket file descriptor */ 
  int newFd;                     /* socket descriptor from accept */ 
  int ix = 0;                    /* counter for work task names */ 
  int portnum = SERVER_PORT_NUM; /* desired port number; can be changed if that number in use enc */
  char workName[16];             /* name of work task */ 
  int on = TRUE;  /* non-blocking */
  int off = FALSE; /* blocking */
  int status;
  static TWORK targ;
  MYSQL *dbsock = NULL;
  MYSQL_RES *result;
  int numRows;
  char tmp[256], *myname;

#ifdef Linux
  prctl(PR_SET_NAME,"tcpServer");
#endif

  /* some cleanup */
  sockAddrSize = sizeof(struct sockaddr_in); 
  memset((char *)&serverAddr, 0, sockAddrSize); 
  memset((char *)&clientAddr, 0, sockAddrSize); 


  /* creates an endpoint for communication and returns a socket file descriptor */
  if((sFd = socket(AF_INET, SOCK_STREAM, 0)) == ERROR)
  {
    perror("socket"); 
    return(ERROR); 
  } 

  /* set up the local address */ 
  serverAddr.sin_family = AF_INET; 
  serverAddr.sin_port = htons(portnum); 
  serverAddr.sin_addr.s_addr = htonl(INADDR_ANY); /* create a TCP-based socket */ 

  /* bind socket to local address */
  while(bind(sFd, (struct sockaddr *)&serverAddr, sockAddrSize) == ERROR)
  {
    perror("bind");

    /* try another port (just increment on one) */
    portnum ++;
    if((portnum-SERVER_PORT_NUM) > 50)
    {
      close(sFd); 
      return(ERROR);
    }

    serverAddr.sin_port = htons(portnum);
  }
  printf("bind on port %d\n",portnum);

  /* create queue for client connection requests */ 
  if(listen (sFd, SERVER_MAX_CONNECTIONS) == ERROR)
  {
    perror ("listen"); 
    close (sFd); 
    return (ERROR);
  }

#ifdef VXWORKS
  myname = targetName();
#else
  myname = localname;
#endif
  printf("myname >%s<\n",myname);

  /* update daq database 'Ports' table with port number and host name */
  dbsock = dbConnect(getenv("MYSQL_HOST"), "daq");

  /* trying to select our name from 'Ports' table */
  sprintf(tmp,"SELECT Name FROM Ports WHERE Name='%s'",myname);
  if(mysql_query(dbsock, tmp) != 0)
  {
	printf("mysql error (%s)\n",mysql_error(dbsock));
    return(ERROR);
  }

  /* gets results from previous query */
  /* we assume that numRows=0 if our Name does not exist,
     or numRows=1 if it does exist */
  if( !(result = mysql_store_result(dbsock)) )
  {
    printf("ERROR in mysql_store_result (%)\n",mysql_error(dbsock));
    return(ERROR);
  }
  else
  {
    numRows = mysql_num_rows(result);
    mysql_free_result(result);

    /* NOTE: for VXWORKS 'Host' the same as 'Name' */
    /*printf("nrow=%d\n",numRows);*/
    if(numRows == 0)
    {
      sprintf(tmp,"INSERT INTO Ports (Name,Host,tcpClient_tcp) VALUES ('%s','%s',%d)",
        myname,myname,portnum);
    }
    else if(numRows == 1)
    {
      sprintf(tmp,"UPDATE Ports SET Host='%s',tcpClient_tcp=%d WHERE Name='%s'",myname,portnum,myname);
    }
    else
    {
      printf("ERROR: unknown nrow=%d",numRows);
      return(ERROR);
    }

    if(mysql_query(dbsock, tmp) != 0)
    {
	  printf("ERROR\n");
      return(ERROR);
    }
    else
    {
      printf("Query >%s< succeeded\n",tmp);
    }
  }

  dbDisconnect(dbsock);


  request_in_progress = 0;
  /* accept new connect requests and spawn tasks to process them */ 
  while(1)
  {
#ifdef VXWORKS
    /* check for free net buffers */
    usrNetStackSysPoolStatus("tcpServer",0);
    usrNetStackDataPoolStatus("tcpServer",0);
#endif

    /* do not accept new request if current one is not finished yet; too
    many requests may create network buffer shortage */
    if(request_in_progress)
    {
      /*printf("wait: request in progress\n");*/
#ifdef VXWORKS
      taskDelay(sysClkRateGet());
#else
      sleep(1);
#endif
      continue;
    }

    if((targ.newFd = accept (sFd, (struct sockaddr *) &clientAddr, &sockAddrSize))
          == ERROR)
    {
      perror ("accept"); 
      close (sFd); 
      return (ERROR); 
    }

    targ.address = inet_ntoa(clientAddr.sin_addr);
    targ.port = ntohs (clientAddr.sin_port);

    sprintf (workName, "tTcpWork%d", ix++);
	/*
usrNetStackSysPoolStatus("tcpServer",1);
usrNetStackDataPoolStatus("tcpServer",1);
	*/
    request_in_progress = 1;
    /* spawn with floating point flag VX_FP_TASK, just in case if some code needs it */
#ifdef VXWORKS
    if(taskSpawn(workName, SERVER_WORK_PRIORITY, VX_FP_TASK/*0*/, SERVER_STACK_SIZE,
       (FUNCPTR) tcpServerWorkTask, &targ, 0, 0, 0, 0, 0, 0, 0, 0, 0)
          == ERROR)
    {
	  perror("taskSpawn"); 
	  close(newFd);
      request_in_progress = 0;
    }
#else
    printf("CODAtcpServer: start work thread\n");
	{
      int ret;
	  pthread_t id;
      pthread_attr_t detached_attr;

      pthread_attr_init(&detached_attr);
      pthread_attr_setdetachstate(&detached_attr, PTHREAD_CREATE_DETACHED);
      pthread_attr_setscope(&detached_attr, PTHREAD_SCOPE_SYSTEM);

      printf("befor: socket=%d address>%s< port=%d\n",
        targ.newFd, targ.address, targ.port); fflush(stdout);

      /* block annoying IP address(es) */
      if(!strncmp((int) inet_ntoa (clientAddr.sin_addr),"129.57.71.",10))
	  {
        printf("WARN: ignore request from %s\n",targ.address);
        close(newFd);
        request_in_progress = 0;
	  }
      else
	  {
        ret = pthread_create(&id, &detached_attr, tcpServerWorkTask, &targ);
        if(ret!=0)
        {
          printf("ERROR: pthread_create(CODAtcpServerWorkTask) returned %d\n",
            ret);
          close(targ.newFd);
          request_in_progress = 0;
        }
	  }
	}
#endif
	/*
usrNetStackSysPoolStatus("tcpServer",2);
usrNetStackDataPoolStatus("tcpServer",2);
	*/

    /* sleep 100 msec before processing next request; we do not want to process
    too many requests per minute to avoid network buffers shortage */
#ifdef VXWORKS
    taskDelay(sysClkRateGet()/10);
#endif
  }

} 

/**************************************************************************** 
* * tcpServerWorkTask - process client requests 
* * This routine reads from the server's socket, and processes client 
* requests. If the client requests a reply message, this routine 
* will send a reply to the client. 
* * RETURNS: N/A. */ 

void
tcpServerWorkTask(TWORK *targ)
	 /*int sFd, char *address, unsigned short port) */
{
  STATUS ret;
  TREQUEST clientRequest;            /* request/message from client */ 
  int nRead;                               /* number of bytes read */ 
  char message[REQUEST_MSG_SIZE];
#ifdef Linux
  int len;
  prctl(PR_SET_NAME,"tcp_server_work");
#endif

#ifdef VXWORKS
  if( (nRead = recv(targ->newFd, (char *) &clientRequest, sizeof (TREQUEST), NULL)) > 0 )
  {
	/*
	printf("MMM 0x%08x 0x%08x\n",nRead,nRead);
    printf ("MESSAGE FROM CLIENT (Internet Address %s, port %d, length %d(%d), replflag %d): Executing %s\n", 
	    address, port, clientRequest.msgLen, nRead, clientRequest.reply, clientRequest.message);
	*/
    if(clientRequest.reply)
    {
    /*
     * Set IO redirection.
     */
      /*printf("redirecting I/O to fd: %d\n",sFd);*/

      ioTaskStdSet(0, STD_ERR, targ->newFd);	/* set std err for execute() */
      ioTaskStdSet(0, STD_OUT, targ->newFd);	/* set std out for execute() */
    }

    execute(clientRequest.message);   /* try Executing the message */
   
    if(clientRequest.reply)
    {
      fflush(stderr);
      fflush(stdout);
    }

    free(targ->address);                   /* free malloc from inet_ntoa() */ 
	/*
    ret = shutdown(sFd,2);
    if(ret==ERROR) printf("ERROR in shutdown()\n");
	*/
	
    ret = close(targ->newFd);
    if(ret==ERROR) printf("ERROR in close()\n");
	
    request_in_progress = 0;
    return;
  } 
  else if(nRead == 0)
  {
    printf("connection closed, exit thread\n");
  }
  else /* error from recv() */ 
  {
    perror("ERROR (recv)"); 
  }

printf("NEVER HERE ??!!\n");
  close(targ->newFd);    /* close server socket connection */ 
  request_in_progress = 0;
  return;

#else /*UNIX*/

  if( (nRead = recv(targ->newFd, (char *) &clientRequest, sizeof (TREQUEST), 0)) > 0 )
  {
    /* convert integers from network byte order */
    clientRequest.msgLen = ntohl(clientRequest.msgLen);
    clientRequest.reply = ntohl(clientRequest.reply);

	/*
    printf ("MESSAGE (nRead=%d, Address>%s<, port=%d): Executing >%s<\n", 
	    nRead, targ->address, targ->port, clientRequest.message);
	*/
    strcpy(message, clientRequest.message);

    /* store it to be used later for debugging */
    strcpy(current_message, message);

    /* try Executing the message (each component must provide codaExecute() function */
    /*do not print: message may contains bad characters, it will be checked inside codaExecute
           printf("Executing >%s< (len=%d)\n",message,strlen(message));*/


fflush(stdout);

/*dup2(targ->newFd,1);*/ /*redirect stdout*/
    /*dup2(targ->newFd,2);*/ /*redirect stderr*/

/*
        len = tee(STDIN_FILENO, STDOUT_FILENO,
                  INT_MAX, SPLICE_F_NONBLOCK);
*/
		/*
 len = tee(STDOUT_FILENO,targ->newFd,INT_MAX,SPLICE_F_NONBLOCK);
		*/
  len = tee(1,2,1024,2);
  if(len<0)
  {
    printf("tee error %d (%d)\n",len,errno);
    perror("tee");
    exit(0);
  }
  else if(len==0)
  {
    printf("ERROR in tee, len=0\n");
  }


/*
#define _GNU_SOURCE
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>
#include <errno.h>
#include <limits.h>
int
main(int argc, char *argv[])
{
    int fd;
    int len, slen;
    assert(argc == 2);
    fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }
    do {
        *
         * tee stdin to stdout.
         *
        len = tee(STDIN_FILENO, STDOUT_FILENO,
                  INT_MAX, SPLICE_F_NONBLOCK);
        if (len < 0) {
            if (errno == EAGAIN)
                continue;
            perror("tee");
            exit(EXIT_FAILURE);
        } else
            if (len == 0)
                break;
        *
         * Consume stdin by splicing it to a file.
         *
        while (len > 0) {
            slen = splice(STDIN_FILENO, NULL, fd, NULL,
                          len, SPLICE_F_MOVE);
            if (slen < 0) {
                perror("splice");
                break;
            }
            len -= slen;
        }
    } while (1);
    close(fd);
    exit(EXIT_SUCCESS);
}
*/


	/*
close(targ->newFd);
	*/

/*
setvbuf(stdout, NULL, _IOLBF, BUFSIZ);
*/
/*
setvbuf(targ->newFd, NULL, _IONBF, BUFSIZ);
*/
/*
fdopen(1,"a");
*/

	/* check if message makes sence */
/*linux_execute(message);*/

  printf("111\n");

  /*dup2(1,targ->newFd);*/

  /*fflush(targ->newFd);*/

/*
You will probably have to int FDX=dup(1), close(1), then set up a forked loop to read from FDX and send to the socket.
*/

  /*fflush(targ->newFd);*/
	
  /*
    dup2(1,1);
    dup2(2,2);
  */
  }
  else if(nRead == 0)
  {
    printf("connection closed, exit thread\n");
  }
  else
  {
    perror("ERROR (recv)"); 
  }

  printf("114\n");

  /*free(targ->address);-stuck here !!!*/ /* free malloc from inet_ntoa() */ 
  close(targ->newFd);  /* close server socket connection */ 

  printf("115\n");

  request_in_progress = 0;

  /* terminate calling thread */
  pthread_exit(NULL);

#endif
}
