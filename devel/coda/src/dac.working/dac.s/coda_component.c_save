/*----------------------------------------------------------------------------*
 *  Copyright (c) 1991, 1992  Southeastern Universities Research Association, *
 *                            Continuous Electron Beam Accelerator Facility   *
 *                                                                            *
 *    This software was developed under a United States Government license    *
 *    described in the NOTICE file included as part of this distribution.     *
 *                                                                            *
 * CEBAF Data Acquisition Group, 12000 Jefferson Ave., Newport News, VA 23606 *
 *      heyes@cebaf.gov   Tel: (804) 249-7030    Fax: (804) 249-7363          *
 *----------------------------------------------------------------------------*
 * Description:
 *	class for general CODA component + tcl init code
 *
 * Author:
 *	Graham Heyes
 *	CEBAF Data Acquisition Group
 *
 * Revision History:
 *      coda_component.c,v
 *      Revision 2.11  1997/02/11 19:25:00  heyes
 *      cvs stuff
 *
 *      Revision 2.10  1997/02/11 18:59:27  heyes
 *      Add revision info + other things
 *
 *      Revision 2.9  1997/01/16 15:30:37  heyes
 *      Increase speed of EB, inc. changes after Dec run.
 *
 *      Revision 2.8  1996/10/31 15:54:22  abbottd
 *      Changed rocp->active levels for polling, output options
 *
 *      Revision 2.7  1996/10/29 19:39:39  abbottd
 *      Fixed bug in coda_destructor for VxWorks
 *
 *      Revision 2.6  1996/10/29 19:03:11  heyes
 *      new rcServer
 *
 *      Revision 2.5  1996/10/17 14:30:05  heyes
 *      fix EB end problem
 *
 *      Revision 2.4  1996/10/08 17:58:59  heyes
 *      working threaded eb
 *
 *      Revision 2.3  1996/09/19 12:29:47  heyes
 *      Made EB into a real EB
 *
 *      Revision 2.2  1996/09/10 15:44:46  heyes
 *      signal handlers etc
 *
 *      Revision 2.1  1996/09/06 17:37:38  heyes 
 *      Fix error recovery
 *
 *      Revision 2.0  1996/09/06 17:26:01  abbottd
 *      Fixed Automatic  uid and gid detection
 *
 *      Revision 1.7  1996/09/04 13:52:20  heyes
 *      add if around gid code to behave better with old DB format
 *
 *      Revision 1.6  1996/09/04 13:49:09  heyes
 *      add gid and pid support
 *
 *      Revision 1.5  1996/08/29 17:03:56  heyes
 *      move include mempart.h to rc.h
 *
 *      Revision 1.4  1996/08/28 19:10:41  heyes
 *      added support for user selection of data destination.
 *
 *      Revision 1.3  1996/08/28 17:47:28  heyes
 *      removed all ddu_close
 *
 *      Revision 1.2  1996/08/28 17:44:56  heyes
 *      ddu_close
 *
 *      Revision 1.1.1.2  1996/08/22 15:23:01  heyes
 *      Imported sources
 *
 *
 *---------------------------------------------------------------------------*/
/* include files follow here */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <tcl.h>


#ifdef VXWORKS

extern char *mystrdup(const char *s);

/*#define NO_CMLOG 1*/

#include <types.h>
#include <errno.h>
#include <taskLib.h>
#include <bootLib.h>
#include <sysLib.h>
#include <time.h>

#include <varargs.h> /*???*/

#else

#include <pthread.h>
#include <sys/resource.h>
#include <signal.h>
#include <sys/types.h>
#include <time.h>
#include <netinet/in.h>

#endif

#include "da.h"
#include "rc.h"
#include "libdb.h"
#include "circbuf.h" /* to get NIMNETBUFS */

#ifdef LINUX
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdarg.h>
#endif


#define CODA_ERROR 1
#define CODA_OK 0

#ifndef VXWORKS
#include <et_private.h>
/* more globals */
static char *et_filename = NULL;  /* for command line */
char et_name[ET_FILENAME_LENGTH];
#endif

/* udp */
static int udp_loop_exit;
static int udpsocket;
static int udpport;
static char udphost[128];

static objClass localobject;

/*
 * Start of coda globals etc... There should be no globals !!!!
 */

/*static*/ char configname[128]; /* Sergey: for CODA configuration name */

/*static*/ char    *mysql_host = NULL;
/*static*/ char    *session = NULL;
static char    *objects = NULL;
static char    *objectN = NULL;
static char    *objectTy = NULL;

static int      interactive = 0;
static int      runWatchdog = 0;
static int      quiet = 1;
static char    *startup_file0 = NULL;
static char    *startup_file = NULL;
static char    *debugString = NULL;
FUNCPTR         process_poll_proc = NULL;
unsigned long *eventNumber;
unsigned long *dataSent;



#ifdef NEW_RC
char gstatistics[100] = "0 0.0 0 0.0";
char gstatus[50] = "initialized";
int gheartbeat = 0;
#endif

#ifdef VXWORKS
/* function prototypes */
int usrNetStackSysPoolStatus(char *title, int flag);
int usrNetStackDataPoolStatus(char *title, int flag);
#endif

/*
 * The following variable points to the Tcl interpreter which is used by all
 * functions in this file.
 */
Tcl_Interp *Main_Interp = NULL;
/* extern */ int Tk_doneFlag__ = 0;
/*
 * * Static variables used by the interactive Tcl/Tk processing
 */
static Tcl_DString command; /* Used to assemble lines of terminal input into Tcl commands. */

long            rcdebug_level__;
int             global_code[32];
char           *global_routine[8][32];
jmp_buf         global_env[8][32];
long            global_env_depth[32];
long            use_recover = 0;
static long     codaDebugLevel = 0;




/*******************************************************/
/*******************************************************/
/* following function provide heartbeat information */
/* heartbeat status array and function prototypes */

static int heartbeat[HB_MAX];
static int heartbeatold[HB_MAX];
static int heartbeatcount[HB_MAX];
static int heartmask[HB_MAX];
static int heartbeaterrorflag[HB_MAX];
static int heartbeaterrormsg[HB_MAX][130];


/* called by main controlling thread once */
int
resetHeartBeats()
{
  int i;
  for(i=0; i<HB_MAX; i++)
  {
    heartbeat[i] = heartbeatold[i] = time(0);
    heartbeatcount[i] = -1; /* do not check */
    heartmask[i] = 0;
    heartbeaterrorflag[i] = 0;
  }
  return(0);
}

/* called by monitored threads;
it sets appropriate bits in 'heartmask' amd sets countdown; 'checkheartbeat'
will decrement countdown counter every second and when it reaches 0 next check
will be performed */
int
setHeartBeat(int system, int bit, int countdown)
{
  if(bit<0 || bit>31)
  {
    printf("ERROR in setHeartBeat - do nothing\n");
    return(-1);
  }
  else
  {
    if(countdown<4) countdown = 4;
    /*printf("setHeartBeat: %d %d %d\n",system,bit,countdown)*/;
  }

  heartbeat[system] = time(0);
  heartbeatcount[system] = countdown;

  if(bit<=0) heartmask[system] = 1;
  else       heartmask[system] |= (1<<bit);

  return(0);
}

/* called by monitored threads */
int
setHeartError(int system, char *msg)
{

  printf("setHeartError: %d >%s<\n",system,msg);

  heartbeaterrorflag[system] = 2;
  strncpy((char *)&heartbeaterrormsg[system][0],msg,128);

  return(0);
}

/* called by main controlling thread in a loop */
int
checkHeartBeats()
{
  int i;
  char tmp[1000];
  /*
  for(i=0; i<HB_MAX; i++) heartbeat[i] = localpmc.heartbeat[i];
  */
  for(i=0; i<HB_MAX; i++)
  {
    if(heartbeaterrorflag[i]>0)
	{

      strcpy(tmp,"err:");
      strcat(tmp,localobject->name);
      strcat(tmp," ");
      strcat(tmp,(char *)&heartbeaterrormsg[i][0]);

      UDP_request(tmp);

      heartbeaterrorflag[i] --;
      if(heartbeaterrorflag[i]==0) UDP_cancel(tmp);
	}
    /*else if(heartbeatcount[i]<0)
	{
      printf("INFO: HeartBeat[%1d]: do not check (%d)\n",
        i,heartbeatcount[i]);
	}*/
    else if(heartbeatcount[i]>0)
    {
      if(heartbeatcount[i]==3)
      {
        heartbeatold[i] = heartbeat[i];
      }
	  /*
      printf("INFO: HeartBeat[%1d]: decrement heartbeatcount=%d(beat=%d,%d)\n",
        i,heartbeatcount[i],heartbeat[i],heartbeatold[i]);
	  */
      heartbeatcount[i] --;

      if(heartbeatcount[i]==0)
	  {
        if(heartbeat[i]==heartbeatold[i])
        {
          sprintf(tmp,"sys %d, mask 0x%08x(%d)",i,heartmask[i],heartmask[i]);
          setHeartError(i, tmp);

          printf("ERROR: HeartBeat[%1d]: heartbeat=%d(%d) heartmask=0x%08x\n",
            i,heartbeat[i],heartbeatold[i],heartmask[i]);
        }
        else
	    {
		  /*
          printf("INFO: HeartBeat[%1d]: heartbeat=%d(%d) heartmask=0x%08x\n",
            i,heartbeat[i],heartbeatold[i],heartmask[i]);
		  */
	    }
	  }
	}
  }
  return(0);
}

/*******************************************************/
/*******************************************************/
/*******************************************************/






/* Routine to check the Endianness of host machine */
int
isBigEndian(void)
{
  unsigned short num, switched_num;
  
  num = (2<<8) + 1;
  switched_num = htons(num);
  if(num == switched_num) return(1);
  else                    return(0);
}

static void
codaInitDebug()
{
  char	*env,
  *tmp,
  *tok;

  env = getenv("CODA_DEBUG");

  if(env )
    {
#ifdef VXWORKS
      debugString = (char *)mystrdup(env);
#else
      debugString = (char *)strdup(env);
#endif
    }

  if (debugString == NULL)
    return;
  
  printf("\n-------------------------------------------------------\n");
  printf("CODA_DEBUG found. debug started with the following:-\n\n");
  tok = (char *)strtok(debugString,":");
  while(tok)
    {
      if (strcmp(tok,"data") == 0)
	{
	  codaDebugLevel |= 1;
	  printf("Debug level : data transport\n");
	}
      if (strcmp(tok,"api") == 0)
	{
	  codaDebugLevel |= 2;
	  printf("Debug level : api\n");
	}
      if (strcmp(tok,"malloc") == 0)
	{
	  codaDebugLevel |= 4;
	  printf("Debug level : fifo\n");
	}
      tok = (char *)strtok(NULL,":");
    }
  printf("\n-------------------------------------------------------\n\n");
}

void
debug_printf(int level, char *fmt,...)
{
  va_list ap;
  int severity;
  /*
printf("debug_printf reached\n");fflush(stdout);
printf("debug_printf: level=%d, fmt >%s<\n",level,fmt);fflush(stdout);
  */
#ifdef VXWORKS
  /* Sergey ?????: va_start(ap);*/
  va_start(ap,fmt);
#else
  va_start(ap,fmt);
#endif 
 
  if (level & codaDebugLevel) {
    fprintf(stderr, "[CODA debug] ");
    
    vfprintf (stderr,fmt, ap);
  }
  /*
printf("debug_printf done\n");fflush(stdout);
  */
}

int pr_time(char *stuff) 
{
  double d1=0.,d2;
#if defined SOLARIS
  struct timespec to;
  clock_gettime(CLOCK_REALTIME,&to);
  d1 = to.tv_sec;
  d2 = to.tv_nsec;
  d1 = d1 + (d2/1000000000.0);
#elif defined LINUX
  struct timeval to;
  gettimeofday(&to,NULL);
  d1 = to.tv_sec;
  d2 = to.tv_usec;
  d1 = d1 + (d2/1000000.0);
#endif
  printf("%f %s\n",d1,stuff);
}
/*
 * C error recovery, we attempt to recover from (normally) fatal system errors.
 */

/**********************************************************
 * System error Recovery - save context to jump to in case
 * of Fatal system error in C code.
 **********************************************************/
 
/*
 * Pop a stored context off the stack (A stack of process contexts is saved, in
 * case of a system level error we can jump back to a safe state. This gives
 * simple error recovery..
 */
int
lastContext ()
{
  /*
#define pthread_self() 1
  if (global_env_depth[pthread_self() & 31] > 0)
    global_env_depth[pthread_self() & 31]--;
  */
  return(0);
}

#ifndef VXWORKS

/*
 * Error recovery Init. . .
 */

void *
signal_thread (void *arg)
{
  sigset_t   signal_set;
  int        sig_number, status;
  int        thr = (int) arg;
  char       *rtn;

  if (global_env_depth[thr]>0) {
    global_env_depth[thr]--;
  }
  rtn = global_routine[global_env_depth[thr]][thr];
  
  sigemptyset(&signal_set);
  sigaddset(&signal_set, SIGSEGV);
  sigaddset(&signal_set, SIGBUS);
  sigaddset(&signal_set, SIGILL);
  sigaddset(&signal_set, SIGFPE);
  sigaddset(&signal_set, SIGTRAP);
  sigaddset(&signal_set, SIGINT);
  sigaddset(&signal_set, SIGTERM);
  
  while (1) {
    sigwait(&signal_set, &sig_number);
    switch (sig_number) {
      case SIGSEGV:
        printf ("ERROR Segmentation fault - presumed fatal in %s\n", rtn);
        fprintf (stdout, "ERROR Segmentation fault - presumed fatal in %s\n", rtn);
        break;
    
      case SIGBUS:
        printf ("ERROR Bus error in %s - presumed fatal\n", rtn);
        break;
		/*
      case SIGILL:
        printf ("ERROR %s, in %s", sys_errlist[errno],rtn);
        perror ("error was-");
        break;
		*/
      case SIGFPE:
        printf ("ERROR Math error (probably 1/0) in %s\n", rtn);
        break;
    
      case SIGTRAP:
        printf ("ERROR Math error (probably 1/0) in %s\n", rtn);
        break;
         
      case SIGINT:
        printf ("ERROR got SIGINT\n");
	exit(-1);
      case SIGTERM:
        debug_printf (2,"killed by: %s", Tcl_SignalMsg (sig_number));
        Tk_doneFlag__ = 1;
        return;
        break;
        
      default:
        printf ("ERROR Unknown signal %d in %s\n", sig_number, rtn);
        return;
    }
   
    fflush(stdout);
    global_code[thr] = sig_number; 
    siglongjmp(global_env[global_env_depth[thr]][thr],sig_number);
  }
}
#endif

void
Recover_Init ()
{
#if !defined(VXWORKS) && !defined(Darwin)
  pthread_t  id;
  sigset_t   signal_set;
  int        status;
  int        thr = pthread_self() & 31;
  
  sigfillset(&signal_set);
  status = pthread_sigmask(SIG_BLOCK, &signal_set, NULL);
  if (status != 0) {
    fprintf (stderr, "Recover_Init: error in setting signal mask, %d\n", status);
    exit (3);
  }

  pthread_create(&id, NULL, signal_thread, (void *) thr);
  bzero(global_env_depth, sizeof(global_env_depth));
#endif
}

/*
 * Tcl_AppInit, init all Tcl packages.
 */
int
Tcl_AppInit(interp)
Tcl_Interp *interp;
{
  /* Tcl Itself */
  if(Tcl_Init(interp) == TCL_ERROR)
  {
    fprintf (stderr, "Tcl_Init failed: %s\n", interp->result);
    return TCL_ERROR;
  }
  if(Tcl_GlobalEval (interp, "set errorInfo \"not availible\"") != TCL_OK)
    return TCL_ERROR;

  /* MSQL database access package 
  if(MSQL_Init (interp) == TCL_ERROR)
  {
    fprintf (stderr, "MSQL_Init failed: %s\n", interp->result);
    return TCL_ERROR;
  }*/

  /* Itcl package */
  if (Itcl_Init (interp) == TCL_ERROR)
  {
    fprintf (stderr, "Itcl_Init failed: %s\n", interp->result);
    return TCL_ERROR;
  }

#ifdef TCL_MEM_DEBUG
  Tcl_InitMemory(interp);
#endif
  return TCL_OK;
}

char *user_flag1 = NULL;
char *user_flag2 = NULL;
unsigned long user_flag3 = 0;
unsigned long user_flag4 = 0;

TCL_PROC (coda_constructor)
{
  Itcl_Object    *obj;

printf("coda_constructor reached\n");fflush(stdout);
  /* Allocate storage for local class information */
  object = (objClass) ckalloc (sizeof (objClassStore));
  bzero ((char *) object, sizeof (objClassStore));

  localobject = object;

  /* Get name of this object and extract tail of name */
  if (Tcl_Eval (interp, "set name [info namespace tail $this]") != TCL_OK)
    return TCL_ERROR;

  /* copy name into class structure */

  object->name = (char *) ckalloc (strlen (interp->result) + 1);
  strcpy (object->name, interp->result);

  /* we need to save the pointer to private object storage */

  Tcl_Eval (interp, "set this");				     /* find out who we are */
  Itcl_FindObject (interp, interp->result, &obj);		     /* find pointer to itcl object */

  object->className = obj->cdefn->name;
  object->interp = interp;

  obj->ClientData = (ClientData) object;			     /* store private data */

  /* tell anyone watching */
  {
    char tmp[400];
    
    sprintf(tmp,"%s {%s} %s {%s}",
	    __FILE__,
	    DAYTIME,
	    CODA_USER,
	    "$Id: coda_component.c,v 2.72 1999/12/09 14:36:25 abbottd Exp $");
    Tcl_SetVar (interp, "tcl_modules",tmp,TCL_LIST_ELEMENT|TCL_APPEND_VALUE|TCL_GLOBAL_ONLY);
  }
  object->codaid = 0;
  /* link C variables to object */

  eventNumber = (unsigned long *) &object->nevents;
  dataSent = (unsigned long *) &object->nlongs;

  Tcl_LinkVar (interp, "CODA::state",(char *) &object->state,TCL_LINK_STRING); 
  Tcl_LinkVar (interp, "CODA::name", (char *) &object->name, TCL_LINK_STRING);
  Tcl_LinkVar (interp, "CODA::nlongs", (char *) &object->nlongs, TCL_LINK_INT);
  Tcl_LinkVar (interp, "CODA::nevents", (char *) &object->nevents, TCL_LINK_INT);
  Tcl_LinkVar (interp, "CODA::codaid", (char *) &object->codaid, TCL_LINK_INT);

  if (Tcl_Eval (interp, "set log_name $name") != TCL_OK)
    return TCL_ERROR;

  printf("CODA %s,Name : %s, Type %s Id : %d\x1b[0m\n",
	 VERSION,
	 object->name,
	 object->className,
	 object->codaid);
  
  /* set state to booted */
  if (Tcl_Eval (interp, "status booted") != TCL_OK)
    return TCL_ERROR;


  printf("INFO: '%s' state now '%s'\n",object->name,object->state);
 
  if (Tcl_VarEval (interp,
		   "database query \"SELECT id FROM process WHERE name='",
		   object->name,
		   "'\"",
		   NULL) != TCL_OK) {
    return TCL_ERROR;
  }
  if (Tcl_VarEval (interp,
		   "set codaid [database get next]",
		   NULL) != TCL_OK) {
    return TCL_ERROR;
  }

  /* tells UDP_start() this is a first call */
  udp_loop_exit = -1;

  return TCL_OK;
}


TCL_PROC (coda_test)
{
  printf("DEBUG: status of object '%s' is '%s'\n",object->name,object->state);
  return TCL_OK;
}

TCL_PROC (coda_destructor)
{
  
  if ((object != NULL) && (object->name != NULL)) {
    printf("WARN: delete called in object '%s'\n",object->name);

    Tcl_UnlinkVar (interp, "CODA::state");
    Tcl_UnlinkVar (interp, "CODA::name");
    Tcl_UnlinkVar (interp, "CODA::nlongs");
    Tcl_UnlinkVar (interp, "CODA::nevents");
    Tcl_UnlinkVar (interp, "CODA::codaid");

    if (Tcl_VarEval (interp,
		     "database query \"UPDATE process SET inuse='no',state='down' WHERE name='",
		     object->name,
		     "'\"",
		     NULL) != TCL_OK) {
      return TCL_ERROR;
    }
  }
  return TCL_OK;
}


/*
 * Initialize the Tcl/Tk interpreter, plus everything else.
 * 
 * This is a highly modified version of "main()" from the file "tkMain.c"
 * in the standard Tcl/Tk distribution.
 */

void
CODA_Init(int argc, char **argv)
{
  Tcl_Interp *interp; /* Interpreter for this application. */
  char       **listArgv, *args, *obj, *p, buf[20];
  int        code, listArgc;

  /*
   * Static variables used for parsing command line options.
   */
  static Tk_ArgvInfo argTable[] = {
    {"-name", TK_ARGV_STRING, 0, (char *) &objectN,
     "Name of object"},
    {"-type", TK_ARGV_STRING, 0, (char *) &objectTy,
     "Type of object"},
    {"-objects", TK_ARGV_STRING, 0, (char *) &objects,
     "Name and type of this object"},
    {"-mysql_host", TK_ARGV_STRING, 0, (char *) &mysql_host,
     "Name of host to connect to for mysql access"},
#ifndef VXWORKS
    {"-et_filename", TK_ARGV_STRING, 0, (char *) &et_filename,
     "Filename of the ET system"},
#endif
    {"-session", TK_ARGV_STRING, 0, (char *) &session,
     "Name of current Session"},
    {"-i", TK_ARGV_CONSTANT, (char *) 1, (char *) &interactive,
     "Interactive mode"},
    {"-w", TK_ARGV_CONSTANT, (char *) 0, (char *) &runWatchdog,
     "Startup Watchdog task"},
    {"-q", TK_ARGV_CONSTANT, (char *) 0, (char *) &quiet,
     "quiet mode"},
    {"-r", TK_ARGV_CONSTANT, (char *) 1, (char *) &use_recover,
     "Error Recover mode"},
    {"-f", TK_ARGV_STRING, (char *) 0, (char *) &startup_file,
     "startup_file"},
    {"-f0", TK_ARGV_STRING, (char *) 0, (char *) &startup_file0,
     "startup_file"},
    {"-debug", TK_ARGV_STRING, (char *) 0, (char *) &debugString,
     "debug mode \"data:api:\""},
    {0, TK_ARGV_END, 0, 0, 0}
  };

  char *argv2[30];
  int argc2;

  printf("CODA_Init reached\n");
#ifndef VXWORKS
  {
    int res;
    struct rlimit rls;

#if !defined(Linux) && !defined(Darwin)    
    res = getrlimit(RLIMIT_VMEM , &rls);
    if (res == 0) {
      debug_printf(2, "CORE limit was %d\n",rls.rlim_cur,rls.rlim_max);
    } else { 
      perror("getrlimit: ");
    }
    res = getrlimit(RLIMIT_AS , &rls);
    if (res == 0) {
      debug_printf(2, "AS limit was %d %d\n",rls.rlim_cur,rls.rlim_max);
    } else { 
      perror("getrlimit: ");
    }
#endif
    res = getrlimit(RLIMIT_DATA , &rls);
    if (res == 0) {
      debug_printf(2, "DATA limit was %d %d\n",rls.rlim_cur,rls.rlim_max);
    } else { 
      perror("getrlimit: ");
    }
    res = getrlimit(RLIMIT_STACK , &rls);
    if (res == 0) {
      debug_printf(2, "STACK limit was %d %d\n",rls.rlim_cur,rls.rlim_max);
    } else { 
      perror("getrlimit: ");
    }
  }
#endif /* not VXWORKS */

  argc2 = argc;
  debug_printf(2, "argv0 %s\n",argv[0]);
  {
    int ix;
    for(ix=0; ix<30; ix++)
    {
      argv2[ix] = argv[ix];
    }
  }
  /*Sergey: moved to roc_component.c: libPartInit();*/

printf("CODA_Init 1\n");fflush(stdout);
  Main_Interp = interp = Tcl_CreateInterp();
printf("CODA_Init 2\n");fflush(stdout);

  /*
   * Parse command-line arguments.
   */
parseError:
  if(Tk_ParseArgv (interp, 0, &argc, argv, argTable, 0) != TCL_OK)
  {
    fprintf (stderr, "%s\n", interp->result);
    exit(3);
  }

  codaInitDebug();
#ifdef VXWORKS
  if (objectN == NULL) {
    objectN = hostname();
  }
#else
  debug_printf(2, "value \"%s\"\n",&argv[0][strlen(argv[0]) - 7]);

  /* UNIX: use executable name to get objectTy (Sergey: isnt beautiful ?) */
  if (!strcmp(&argv[0][strlen(argv[0]) - 7],"coda_eb")) {
    objectTy = strdup("CDEB");
  }
  if (!strcmp(&argv[0][strlen(argv[0]) - 8],"coda_roc")) {
    objectTy = strdup("ROC");
  }
  if (!strcmp(&argv[0][strlen(argv[0]) - 7],"coda_er")) {
    objectTy = strdup("ER");
  }
  if (!strcmp(&argv[0][strlen(argv[0]) - 7],"coda_ts")) {
    objectTy = strdup("TS");
  }
  if (!strcmp(&argv[0][strlen(argv[0]) - 8],"coda_mon")) {
    objectTy = strdup("MON");
  }

#endif

printf("CODA_Init 11\n");fflush(stdout);
  printf("CODA_Init: objectTy >%s<\n",objectTy);fflush(stdout);
printf("CODA_Init 12\n");fflush(stdout);

  if ((objects == NULL) && (objectN !=NULL) && (objectTy !=NULL)) {
    static char temp[100];
    sprintf(temp,"%s %s",objectN, objectTy);
    objects = temp;
  }

  if(session == NULL)
  {
    session = getenv("SESSION");
  }
  printf("CODA_Init: use 'SESSION' as >%s<\n",session);fflush(stdout);

  if (objects == NULL || session == NULL) {
    argc = 2;
    argv[1] = "-help";
    goto parseError;
  }

  {
    static char tmp[300];

    sprintf(tmp,"DD_NAME=%s\0",session);
    putenv(tmp);
  }

#ifndef VXWORKS
  if (et_filename == NULL) {
    sprintf(et_name, "%s%s", "/tmp/et_sys_", session);
  }
  else {
    strncpy(et_name, et_filename, ET_FILENAME_LENGTH - 1);
    et_name[ET_FILENAME_LENGTH - 1] = '\0';
  }
#endif

  if(mysql_host)
  {
    static char tmp[100];
    sprintf(tmp,"MYSQL_HOST=%s",mysql_host);
    debug_printf(2, "MYSQL_HOST=%s\n",mysql_host);
    putenv(tmp);
  }
  else
  {
    if(!(mysql_host = getenv("MYSQL_HOST")))
    {
#ifdef VXWORKS
      mysql_host = mystrdup("localhost");
#else
      mysql_host = strdup("localhost");
#endif
    }
  }

  /*
   * Make command-line arguments available in the Tcl variables "argc"
   * and "argv".  Also set the "geometry" variable from the geometry
   * specified on the command line.
   */
/*printf("11: 0x%08x\n",args);*/
  args = Tcl_Merge (argc - 1, argv + 1);
/*printf("12: 0x%08x\n",args);*/
/*printf("13: >%s<\n",args);*/
  Tcl_SetVar (interp, "argv", args, TCL_GLOBAL_ONLY);
/*printf("14\n");*/
  ckfree (args);
/*printf("15\n");*/
  sprintf (buf, "%d", argc - 1);
  Tcl_SetVar (interp, "argc", buf, TCL_GLOBAL_ONLY);
  Tcl_SetVar (interp, "argv0", argv[0], TCL_GLOBAL_ONLY);

  /*
   * Set the "tcl_interactive" variable.
   */
  if (interactive)
    Tcl_SetVar (interp, "tcl_interactive", "1", TCL_GLOBAL_ONLY);

  Tcl_SetVar (interp, "tcl_modules", "", TCL_GLOBAL_ONLY);
  Tcl_SetVar (interp, "coda_version", VERSION, TCL_GLOBAL_ONLY);

  if(Tcl_AppInit(interp)!=TCL_OK)
  {
    fprintf (stderr, "%s\n", interp->result);
    exit (3);
  }

  /* Set a global Tcl variable here indicating whether
   * the CODA object is running on a Unix or VxWorks platform
   */ 
#ifdef VXWORKS
  Tcl_SetVar(interp,"os_name","vxworks",TCL_GLOBAL_ONLY);
#else
  Tcl_SetVar(interp,"os_name","unix",TCL_GLOBAL_ONLY);
#endif

  Tcl_Eval(interp, "set auto_path \". $auto_path $env(CODA)/common/lib/daq\"");

  if (Tcl_VarEval (interp, "mysql connect database ",mysql_host, NULL) != TCL_OK) {
    fprintf (stderr, "%s\n", interp->result);
    exit (3);
  }
  if (Tcl_VarEval (interp, "database set database $env(EXPID)", NULL) != TCL_OK) {
    fprintf (stderr, "%s\n", interp->result);
    exit (3);
  }
  /* It would be nice here to set the uid and gid of the process to 
     match that of whoever is running RunControl */
  {
    static char list[256];
    if(Tcl_VarEval (interp, 
		     "database query \"select owner from sessions where name='",
		     session,
		     "'\"",
		     NULL) != TCL_OK)
    {
      fprintf (stderr, "%s\n", interp->result);
      fprintf (stderr, "Unable to get owner information\n");
    }
    else
    {
      Tcl_Eval(interp, "database get next");
	    
     /* Gid rid of leading and trailing braces */
      if(strlen(interp->result) > 2)
      {
        strncpy(list,&(interp->result[1]),(strlen(interp->result)-2));
        list[strlen(interp->result)-2] = '\0';
      }
      else
      {
        printf("ERROR: No owner information from database table sessions\n");
        printf("string length of interp->result = %d\n",strlen(interp->result));
        exit(3);
      }
      if(Tcl_SplitList (interp, list, &listArgc, &listArgv) != TCL_OK)
      {
        fprintf (stderr, "%s\n", interp->result);
      }
      else
      {
        if(listArgc == 4)
        {
#ifdef VXWORKS
	  nfsAuthUnixSet(listArgv[0],
			 atoi(listArgv[2]),
			 atoi(listArgv[3]),
			 0,
			 0);
	  nfsAuthUnixShow();
#else
	  /*setuid(atoi(listArgv[2]));
	    setgid(atoi(listArgv[3]));*/
#endif
	} else {
	  printf ("WARNING: Could not get uid and gid info from database\n");
	  printf ("         number of args in the id entry of sessions is %d\n",listArgc);
	}
      }
    }
  }
  
  {
    int listArgc, ix;
    char **listArgv;
    Itcl_Namespace ns;

    if (Tcl_SplitList (interp, objects, &listArgc, &listArgv) != TCL_OK) {
      fprintf (stderr, "%s\n", interp->result);
      exit(3);
    }

    if(CODA_class_Init(interp) != TCL_OK) {
      char *val;
      printf("CODA_class_Init");
      fprintf (stderr, "ERROR:\n      %s\n", interp->result);
      val = Tcl_GetVar(interp, "errorInfo", TCL_GLOBAL_ONLY);
      fprintf (stderr, "TclStack:\n      %s\n",val);
      exit (3);
    }
    
    if (startup_file0) {
      printf("here with %s\n",startup_file0);
      if (Tcl_EvalFile(interp,(char *) startup_file0) != TCL_OK) {
	fprintf (stderr, "startup file 0 :%s\n", interp->result);
	exit(0);
      }
    }
    for(ix=0; ix<listArgc; ix+=2)
    {
      char *class = listArgv[ix+1];
      obj = listArgv[ix];


      printf("session: >%s<\n",session);/*clastest*/
      printf("class:   >%s<\n",class);/*TS*/
      printf("obj:     >%s<\n",obj);/*croctest4*/

printf("CODA_Init 13\n");fflush(stdout);

      if(Tcl_VarEval(interp, class, " ", obj, " ", session, NULL) != TCL_OK)
      {
        char *val;
        fprintf (stderr, "CODA_Init: ERROR:\n      %s\n", interp->result);
        val = Tcl_GetVar(interp, "errorInfo", TCL_GLOBAL_ONLY);
        fprintf (stderr, "TclStack:\n      %s\n",val);
        exit(3);
      }
printf("CODA_Init 14\n");fflush(stdout);
    }  
    {
      char tmp[200];
      sprintf(tmp,"puts -nonewline \"%s::%s> \"",session,obj);
      Tcl_SetVar(interp,"tcl_prompt1",tmp, TCL_GLOBAL_ONLY);
    }
    if (interactive) {
      if (!quiet) {
	printf("This is a Tcl shell for control, debugging and access to internal parameters.\n");
	printf("\n");
	printf("For a list of the names of valid commands type...\n\n");
	
	printf("%s info commands\n\n",obj);
      }
      if (!quiet) {
	printf("For a list of configuration parameters type ...\n\n");
	printf("%s configure\n\n",obj);
	printf("Single parameters can be read via ...\n\n");
	printf("%s cget -[name]\n\n",obj);
	printf("...where [name] can be replaced by a name found using \"configure\"\n");
	printf("The versions of C files used to build this code can be found by...\n\n");
	printf("%s version\n\n",obj);
      }
    }

    ckfree ((char *) listArgv);
  }
  /*
   * Error recovery Init. . .
   */
  Recover_Init ();
  if (startup_file)
    Tcl_EvalFile(interp,(char *) startup_file);

  if (interactive && !quiet) {
    printf("Use all other commands with care.\n");
    printf("\n");
  }
}


void
CODA_Service (objClass object)
{
}


/*
 * ----------------------------------------------------------------------
 * 
 * Prompt --
 * 
 * Issue a prompt on standard output, or invoke a script to issue the prompt.
 * 
 * Results: None.
 * 
 * Side effects: A prompt gets output, and a Tcl script may be evaluated in
 * interp.
 * 
 * ----------------------------------------------------------------------
 */
static void
Prompt(interp, partial)
Tcl_Interp *interp;  /* Interpreter to use for prompting */
int         partial; /* Non-zero means there already exists a partial command,
                        so use the secondary prompt */
{
  char *promptCmd;
  int code;
  /*
printf("Prompt reached\n");
  */
  promptCmd = Tcl_GetVar (interp,
			  partial ? "tcl_prompt2" : "tcl_prompt1", TCL_GLOBAL_ONLY);
  if(promptCmd == NULL)
  {
  defaultPrompt:
    if(!partial)
    {
      fputs ("% ", stdout);
    }
  }
  else
  {
    code = Tcl_Eval (interp, promptCmd);
    if(code != TCL_OK)
    {
      Tcl_AddErrorInfo (interp,
			"\n    (script that generates prompt)");
      fprintf (stderr, "%s\n", interp->result);
      goto defaultPrompt;
    }
  }
  fflush (stdout);
  /*
printf("Prompt done\n");
  */
}

/*
 * ----------------------------------------------------------------------
 * 
 * StdinProc --
 * 
 * This procedure is invoked by the event dispatcher whenever standard input
 * becomes readable.  It grabs the next line of input characters, adds them to
 * a command being assembled, and executes the command if it's complete.
 * 
 * Results: None.
 * 
 * Side effects: Could be almost arbitrary, depending on the command that's typed.
 * 
 * ----------------------------------------------------------------------
 */
static int oldStdin, oldStdout, oldStderr;

/* ARGSUSED */
static void
StdinProc (clientData, mask)
ClientData      clientData;				     /* Not used. */
int             mask;					     /* Not used. */
{
  char            input[4000];
  static int      gotPartial = 0;
  char           *cmd;
  int             code, count;
  /*
printf("StdinProc reached\n");
  */
  count = read (0, input, sizeof (input) - 1);
  if (count <= 0) {
    if (!gotPartial) {
#ifdef VXWORKS
      int fd;
      char cmd[200];
      fd = ioTaskStdGet(0,0);
      printf("close connection file%d\n",fd);
      if (!interactive)
	Tk_DeleteFileHandler (0);
      sprintf(cmd,"close file%d\n",fd);
      Tcl_Eval(Main_Interp,cmd);
      ioTaskStdSet(0,0,oldStdin);
      ioTaskStdSet(0,1,oldStdout);
      ioTaskStdSet(0,2,oldStderr);
      return;
#else
	Tcl_Eval (Main_Interp, "exit");
	exit (6);
#endif
    } else {
      count = 0;
    }
  }
  cmd = Tcl_DStringAppend (&command, input, count);

  if (count != 0) {
    if ((input[count - 1] != '\n') && (input[count - 1] != ';')) {
      gotPartial = 1;
      goto prompt;
    }
    if (!Tcl_CommandComplete (cmd)) {
      gotPartial = 1;
      goto prompt;
    }
  }
  gotPartial = 0;


  /*
   * Disable the stdin file handler while evaluating the command;
   * otherwise if the command re-enters the event loop we might process
   * commands from stdin before the current command is finished.  Among
   * other things, this will trash the text of the command being
   * evaluated.
   */

  Tk_CreateFileHandler (0, 0, StdinProc, (ClientData) 0);
  code = Tcl_RecordAndEval (Main_Interp, cmd, 0);
  Tk_CreateFileHandler (0, TK_READABLE, StdinProc, (ClientData) 0);
  Tcl_DStringFree (&command);
  if (*Main_Interp->result != 0) {
    printf ("%s\n", Main_Interp->result);
  }

  /*
   * Output a prompt.
   */
prompt:
  Prompt (Main_Interp, gotPartial);
}

/*
 * Main program loop...
 */
#ifdef VXWORKS
static int watchFlag;

void codaWatchdog()
{
  while (1) {

    watchFlag = 1;
    taskDelay (60*sysClkRateGet()); /* ten second timeout */

    if (watchFlag) {
      int i;
      for(i=8;i<32;i++) 
	close(i);
      break;
    }
  }
  printf("codaWatchdog done\n");
}


static void watching ()
{
  watchFlag = 0;
  Tk_CreateTimerHandler (2000, (Tk_TimerProc *) watching, (ClientData) NULL);
}
#endif

TCL_PROC(CODAConnectStdio)
{
#ifdef VXWORKS
  FILE           *filePtr;
  int fd;

  oldStdin  = ioTaskStdGet(0,0);
  oldStdout = ioTaskStdGet(0,1);
  oldStderr = ioTaskStdGet(0,2);
  if (Tcl_GetOpenFile (interp, argv[1], 1, 1, &filePtr) != TCL_OK) {
    return TCL_ERROR;
  }
  fd = fileno (filePtr);

  ioTaskStdSet(0,0,fd);
  ioTaskStdSet(0,1,fd);
  ioTaskStdSet(0,2,fd);

  if (!interactive)
  {
    Tk_CreateFileHandler (0, TK_READABLE, StdinProc, (ClientData) 0);
  }

#endif
  return TCL_OK;
}

TCL_PROC(CODADisconnectStdio)
{
#ifdef VXWORKS
  ioTaskStdSet(0,0,oldStdin);
  ioTaskStdSet(0,1,oldStdout);
  ioTaskStdSet(0,2,oldStderr);
#endif
  return TCL_OK;
}


/* Sergey */
int CODAtcpServer(void);


/* main loop */
void
CODA_Execute ()
{
#ifndef VXWORKS
  pthread_t id;
#endif  
  int fd;
  int status;
  
  /*
   * If the following lines are removed then tcl_interactive must be set
   * to 0
   */
#ifdef VXWORKS
  Tk_CreateTimerHandler (2000, (Tk_TimerProc *) watching, (ClientData) NULL);

  /* wait for shell to start */
  do
  {
    taskDelay (sysClkRateGet ());
  }
  while (taskNameToId ("tShell") == ERROR);

  if(runWatchdog)
  {
    printf("\nStart watchdog\n");
    sp(codaWatchdog);
  }
#endif


  /* Sergey: start CODAtcpServer as thread */
#ifdef VXWORKS
  {
    int iTaskStat;

    iTaskStat = taskSpawn("CODATCPSRV", 150, 0, 200000, CODAtcpServer,
                          0, 0, 0,0,0,0,0,0,0,0);
    printf("taskSpawn(\"CODATCPSRV\") returns %d\n",iTaskStat);
  }
#else
  {
    pthread_attr_t attr;

    pthread_attr_init(&attr); /* initialize attr with default attributes */
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);

    pthread_create(&id, &attr, CODAtcpServer, NULL);
  }
#endif


  if(interactive)
  {
    
#ifdef VXWORKS
    printf("\nThis is VxWorks so disallow Tcl exit\n");
    Tcl_Eval(Main_Interp,"proc exit {} {puts \"exit not allowed\"}");
    printf("Readout controller ready to roll...\n");
#endif

    Tk_CreateFileHandler (0, TK_READABLE, StdinProc, (ClientData) 0);
    Prompt (Main_Interp, 0);

  }

  Tcl_DStringInit (&command);
  
  /*
   * Process Tk events until the last window is destroyed, then die
   * gracefully.  This function never returns.
   */
  {
    int res;
    recoverContext ("main program loop",res);


#ifndef VXWORKS
    while(!Tk_doneFlag__)
    {
#else
    while(1)
    {
#endif

      (void)Tk_DoOneEvent(0);

/*printf("while 3\n");*/
    }
      
#ifdef VXWORKS
    Tcl_DStringFree(&command);
    Tcl_DeleteInterp(Main_Interp);
#else
    Tcl_Eval(Main_Interp, "exit");
    exit(1);
#endif
    exit (5);
    }
    
  }
  
/*
 *-------------------------------------------------------------------------*
 *   Routine to take a Data buffer in CODA format and perform a
 *   a byte swap based on the data type in the Bank structure headers.
 *
 *   Data is maniputlated in the existing buffer so that function
 *   irreversably mangles the data. If there is an error in the Bank
 *   structure the function returns -1, otherwize it returns 0;
 *   
 *-------------------------------------------------------------------------*
 */
int
CODA_bswap(cbuf, nlongs)
  long *cbuf;
  int nlongs;
{
    int ii, jj, ix;
    int tlen, blen, dtype;
    long lwd;
    short shd;
    char cd;
    char *cp;
    short *sp;
    long *lp;

    ii = 0;
    while (ii<nlongs) {
      lp = (long *)&cbuf[ii];
      blen = cbuf[ii] - 1;
      dtype = ((cbuf[ii+1])&0xff00)>>8;
      lwd = LSWAP(*lp);    /* Swap the length      */
      *lp++ = lwd;         
      lwd = LSWAP(*lp);    /* Swap the bank header */
      *lp++ = lwd;       
      ii += 2;
      if(dtype != DT_BANK) {
	switch(dtswap[dtype]) {
	case 0:
	  /* No swap */
	  ii += blen;
	  break;
	case 1:
	  /* short swap */
	  sp = (short *)&cbuf[ii];
	  for(jj=0; jj<(blen<<1); jj++) {
	    shd = SSWAP(*sp);
	    *sp++ = shd;
	  }
	  ii += blen;
	  break;
	case 2:
          /* long swap */
	  lp = (long *)&cbuf[ii];
	  for(jj=0; jj<blen; jj++) {
	    lwd = LSWAP(*lp);
	    *lp++ = lwd;
	  }
	  ii += blen;
	  break;
	case 3:
	  /* double swap */
	  lp = (long *)&cbuf[ii];
	  for(jj=0; jj<blen; jj++) {
	    lwd = LSWAP(*lp);
	    *lp++ = lwd;
	  }
	  ii += blen;
	  break;
	default:
	  /* No swap */
	  ii += blen;
	}
      }
    }
 return(0);
}


/**************************************/
/**************************************/
/**************************************/
/**************************************/
/**************************************/
/* Sergey: CLAS stuff */


/* returns session name */

void
getSessionName(char *sessionName, int lname)
{
  int len;

  len = strlen(session);
  /*printf("getSessionName: len %d, available %d\n",len,lname-1);*/
  len = len < (lname-1) ? len : (lname-1);
  /*printf("getSessionName: returns %d symbols\n",len);*/

  strncpy(sessionName,session,len);
  sessionName[len] = '\0';
  /*printf("getSessionName: return session name >%s<\n",sessionName);*/

  return;
}


/***************************************************/
/***************************************************/
/***************************************************/
/* UDP functions - attempt to replace TCL code !!! */


#include <sys/types.h>
#include <sys/socket.h>

#ifdef VXWORKS
static SEM_ID udp_lock;
#else
static pthread_mutex_t udp_lock;
#endif


typedef struct udpstruct
{
  int  active;          /* if 1 - send message; if 0 - do not send */
  int  timeinterval;    /* how often to send (sec) (not in use yet) */
  char message[1024];   /* message to be sent */

} UDPSTRUCT;

#define MAXUDPS 2
static UDPSTRUCT udpstr[MAXUDPS];

#ifdef NEW_RC
void
statcalc()
{
  char tmp[1000];
  int nevents, nlongs;
  time_t newtime, timediff;
  float event_rate, data_rate;
  static int oldevents, oldlongs;
  static time_t oldtime;

  nevents = *eventNumber;
  nlongs = *dataSent;

  newtime = time(0); /* time in seconds */

  event_rate = data_rate = 0.0;
  if(oldtime > 0)
  {
    timediff = newtime - oldtime;
    if(timediff != 0)
    {
      event_rate = (nevents - oldevents)/timediff;
	  data_rate = 4*(nlongs - oldlongs)/timediff;
    }
  }

  oldlongs = nlongs;
  oldevents = nevents;
  oldtime = newtime;

  sprintf(tmp," %d %9.3f %d %12.3f",nevents,event_rate,nlongs,data_rate);

  /* update the global variable */
  memset(gstatistics,' ', sizeof(gstatistics));
  strcpy(gstatistics,tmp);

  return;
}
#endif


/* create a connection to given host and port; returns socket number
or 0 if connection was not established; host and port usually obtained
from 'process' table of database where name is session name (clasprod etc) */
int
UDP_establish(char *host, int port)
{
  struct hostent *hp, *gethostbyname();
  struct sockaddr_in sin;
  int s, slen;
  int socketnum;

  /* */
  bzero((char *)&sin, sizeof(sin));

  /* for vxworks - in libtklite.a; should we move it somewhere ??? */
  hp = gethostbyname(host);
  if(hp == 0 && (sin.sin_addr.s_addr = inet_addr(host)) == -1)
  {
	printf("UDP_establish: unknown host >%s<\n",host);
	return(0);
  }
  if(hp != 0) bcopy(hp->h_addr, &sin.sin_addr, hp->h_length);
  sin.sin_port = htons(port);
  sin.sin_family = AF_INET;

  /* create a socket (use 'SOCK_STREAM' for TCP, 'SOCK_DGRAM' for UDP */
  s = socket(AF_INET, SOCK_DGRAM, 0);
  if(s < 0)
  {
    printf("UDP_establish: cannot open socket\n");
    return(0);
  }
  else
  {
    socketnum = s;
    printf("UDP_establish: socket # %d\n",socketnum);
  }


  /**********************/
  /* set socket options */
  /**********************/

  /* socket buffer size */

  slen = 48000/*29200*/;
  if(setsockopt (s, SOL_SOCKET, SO_SNDBUF, &slen, sizeof(slen)) < 0)
  {
	printf("UDP_establish: setsockopt SO_SNDBUF failed\n");
	return(0);
  }

  {
    int nbytes, lbytes;

    nbytes = 0;
    lbytes = 4;

    getsockopt(s, SOL_SOCKET, SO_SNDBUF, (int *) &nbytes, &lbytes); 
    printf("UDP_establish: socket buffer size is %d(0x%08x) bytes\n",
      nbytes,nbytes);
  }

  {
    int optval, lbytes;

	optval = 1; /* 1-yes, 0-no */
	/*make sence for TCP only, not for UDP
    if(setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval)) < 0)
	{
	  printf("UDP_establish: setsockopt SO_KEEPALIVE failed\n");
	  return(0);
	}

    optval = 0;
    lbytes = 4;
    getsockopt(s, SOL_SOCKET, SO_KEEPALIVE, (int *) &optval, &lbytes);
    printf("UDP_establish: keepAlive is %d\n",optval);
	*/
  }

#ifdef VXWORKS_needheaderfiles
  {
    int optval = 0;
    if(setsockopt (s, IPPROTO_TCP, TCP_NODELAY, &optval, sizeof (optval)) < 0)
    {
	  printf("UDP_establish: setsockopt TCP_NODELAY failed\n");
      return(0);
    }
  }
#endif

  /* connect */
  if(connect(s, (const struct sockaddr *)&sin, sizeof (sin)) < 0)
  {
    printf("UDP_establish: connect failed: host %s port %d\n",
      inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
fflush(stdout);
exit(0);
	return(0);
  }

  printf("UDP_establish: socket %d is ready: host %s port %d\n",
      socketnum, inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));



#ifdef VXWORKS
  udp_lock = semBCreate(SEM_Q_FIFO, SEM_FULL);
  if(udp_lock == NULL)
  {
    logMsg("UDP_establish: ERROR: could not allocate a semaphore\n",1,2,3,4,5,6);
    return(0);
  }
#else
  pthread_mutex_init(&udp_lock, NULL);
#endif

  return(socketnum);
}


int
UDP_close(int socket)
{
  int retsocket;

  /* wait a while to let a few messages to be send */
#ifdef VXWORKS
    taskDelay(300);
#else
    sleep(3);
#endif

  /* reset all messages first to cleanup static structure */
  UDP_reset();

#ifdef VXWORKS
  /*semFlush(udp_lock);*/
  semGive(udp_lock);
  semDelete(udp_lock);
#else
  pthread_mutex_unlock(&udp_lock);
  pthread_mutex_destroy(&udp_lock);
#endif

  if(socket != 0)
  {
    if(shutdown(socket, 2)==0)
    {
      printf("UDP_close: socket #%d connection closed\n",socket);
      close(socket);
      retsocket = 0;
    }
    else
    {
      printf("UDP_close: ERROR in socket #%d connection closing\n",
        socket);
      retsocket = socket;
    }
  }

  return(retsocket);
}

/* request 'standard' UDP message to be send */
int
UDP_standard_request(char *name, char *state)
{
  char tmp[1000];

  strcpy(tmp,"sta:");
  strcat(tmp,name);
  strcat(tmp," ");
  strcat(tmp,state);

  printf("UDP_standard_request >%s<",tmp);
  printf("\n");
  printf("UDP_standard_request >%s<",tmp);
  printf("\n");
  printf("UDP_standard_request >%s<",tmp);
  printf("\n");
  printf("UDP_standard_request >%s<",tmp);
  printf("\n");
  printf("UDP_standard_request >%s<",tmp);
  printf("\n");
  printf("UDP_standard_request >%s<",tmp);
  printf("\n");

  UDP_request(tmp);

  return(0);
}

/* remove all UDP messages */
int
UDP_reset()
{
  int i;

#ifdef VXWORKS
  semTake(udp_lock, WAIT_FOREVER);
#else
  pthread_mutex_lock(&udp_lock);
#endif

  printf("UDP_reset reached\n");
  /* cancel all messages */
  for(i=0; i<MAXUDPS; i++)
  {
    printf("UDP_cancel: cancel >%s<\n",udpstr[i].message);
    udpstr[i].active = 0;
    udpstr[i].message[0] = '\0'; /* just in case */
  }

#ifdef VXWORKS
  semGive(udp_lock);
#else
  pthread_mutex_unlock(&udp_lock);
#endif

  return(0);
}

/* cancel UDP message */
int
UDP_cancel(char *str)
{
  int i;

#ifdef VXWORKS
  semTake(udp_lock, WAIT_FOREVER);
#else
  pthread_mutex_lock(&udp_lock);
#endif

  /* cancel all messages with identical key (first 4 characters) */
  for(i=0; i<MAXUDPS; i++)
  {
    if(!strncmp(udpstr[i].message, str, 4))
    {
      printf("UDP_cancel: cancel >%s<\n",udpstr[i].message);
      udpstr[i].active = 0;
      udpstr[i].message[0] = '\0'; /* just in case */
      /*break;*/ /*scan whole structure in case if more then one message*/
    }
  }

#ifdef VXWORKS
  semGive(udp_lock);
#else
  pthread_mutex_unlock(&udp_lock);
#endif

  return(0);
}

/* request UDP message to be send */
int
UDP_request(char *str)
{
  int i, found;

  /* cancel all messages with the same key (first 4 characters) */
  UDP_cancel(str);

#ifdef VXWORKS
  semTake(udp_lock, WAIT_FOREVER);
#else
  pthread_mutex_lock(&udp_lock);
#endif

  found = 0;
  for(i=0; i<MAXUDPS; i++)
  {
    if(udpstr[i].active == 0)
    {
      found = 1;
      udpstr[i].active = 1;
      strcpy(udpstr[i].message, str);
      break;
    }
  }

#ifdef VXWORKS
  semGive(udp_lock);
#else
  pthread_mutex_unlock(&udp_lock);
#endif

  if(found) return(0);

  printf("UDP_request: no empty slots, message was not accepted\n");
  return(1);
}


/* returns number of data bytes written or -1 if error */
/* 'str' must be string */
int
UDP_send(int socket)
{
  char tmp[1000], tmpp[1000];
  int i, nevents, nlongs;
  time_t newtime, timediff;
  float event_rate, data_rate;
  static int oldevents, oldlongs;
  static time_t oldtime;

  int nbytes, cc, rembytes;
  char *buffer2;

#ifdef VXWORKS
  semTake(udp_lock, WAIT_FOREVER);
#else
  pthread_mutex_lock(&udp_lock);
#endif

  for(i=0; i<MAXUDPS; i++)
  {
    if(udpstr[i].active==0) continue;

    /* for the message started from 'sta:' update statistic info */
    if( !strncmp(udpstr[i].message,"sta:",4) )
    {
      nevents = *eventNumber;
      nlongs = *dataSent;

      newtime = time(0); /* time in seconds */

      event_rate = data_rate = 0.0;
      if(oldtime > 0)
      {
        timediff = newtime - oldtime;
        if(timediff != 0)
        {
          event_rate = (nevents - oldevents)/timediff;
	      data_rate = 4*(nlongs - oldlongs)/timediff;
        }
      }

      oldlongs = nlongs;
      oldevents = nevents;
      oldtime = newtime;

      strcpy(tmp,udpstr[i].message);
#ifdef NEW_RC
      /* Attention: do not remove the last space after the data_rate */
      sprintf(tmpp," %d %9.3f %d %12.3f ",nevents,event_rate,nlongs,data_rate);
#else
      sprintf(tmpp," %d %9.3f %d %12.3f",nevents,event_rate,nlongs,data_rate);
#endif
      strcat(tmp,tmpp);
	
    }
    else
    {
      strcpy(tmp,udpstr[i].message);
    }

/* print for UNIX only 
#ifndef VXWORKS
printf("UDP_send >%s<",tmp);
printf(" udpport=%d\n",udpport);
#endif
*/

    nbytes = strlen(tmp);
    if(nbytes == 0)
    {
      printf("UDP_send: no data - return\n");
      goto exit3;
    }

    nbytes++; /* add one char for the end of string sign */
    rembytes = nbytes;
    buffer2 = tmp;
    while(rembytes)
    {
retry3:

      cc = write(socket,buffer2,rembytes);
	  /*cc = send(socket,buffer2,rembytes,NULL);*/
/*printf("2: %d %d\n",rembytes,cc);*/

      if(cc == -1)
      {
        if(errno == EWOULDBLOCK)
        {
          printf("Operation would block 2: retry ...\n");
          goto retry3;
        }

        if(errno==ENOBUFS) printf("No buffer space available (errno=%d)\n",errno);
        else if(errno==EPIPE) printf("Broken pipe (errno=%d)\n",errno);
        else if(errno==ECONNREFUSED)
        {
          /*if rcServer dies, mv2400/mv5500/mv6100 reports following message,
          while mv5100 does not !!!; I think mv5100 is right and others are
          wrong, but must figure it out ... */
          /*printf("Connection refused (errno=%d)\n",errno);*/
          ;
        }
        else printf("Unknown error errno=%d\n",errno);




/* !!! if errno==61(ECONNREFUSED), must try to reestablish connection (rcServer died) */



/*
netStackDataPoolShow - not enough buffers !!!
netStackSysPoolShow
*/
        nbytes = -1;
        goto exit3;
      }

      buffer2 += cc;
      rembytes -= cc;
      if(rembytes!=0) printf("WARN: UDP_send: rembytes=%d\n",rembytes);
    }

exit3:
    ;

  } /* for() */

#ifdef VXWORKS
  semGive(udp_lock);
#else
  pthread_mutex_unlock(&udp_lock);
#endif

  return(nbytes);
}

void
UDP_show()
{
  int i;

  for(i=0; i<MAXUDPS; i++)
  {
    if(udpstr[i].active)
      printf("udpstr[%1d].message >%s<\n",i,udpstr[i].message);
  }
}


int
codaUpdateStatus(char *status)
{
  objClass object = localobject;
  MYSQL *dbsock;
  char tmp[1000];

  /* update database */
/*printf("codaUpdateStatus: dbConnecting ..\n");*/
  dbsock = dbConnect(getenv("MYSQL_HOST"), getenv("EXPID"));
/*printf("codaUpdateStatus: dbConnect done\n");*/
  sprintf(tmp,"UPDATE process SET state='%s' WHERE name='%s'",
    status,localobject->name);
  printf("codaUpdateStatus: >%s<\n",tmp);
  if(mysql_query(dbsock, tmp) != 0)
  {
    printf("codaUpdateStatus: ERROR\n");
    return(CODA_ERROR);
  }
/*printf("codaUpdateStatus: dbDisconnecting ..\n");*/
  dbDisconnect(getenv("MYSQL_HOST"), dbsock);
/*printf("codaUpdateStatus: dbDisconnect done\n");*/
  
  /* update request record */
  UDP_standard_request(localobject->name,status);

  /* TODO: need also to keep status in some local variable .. */
  /*tcpState ? rocp->state ? */

#ifdef NEW_RC
  /* update the global variable */
  memset(gstatus,' ', sizeof(gstatus));
  strcpy(gstatus, status);
#endif

  return(CODA_OK);
}


/* that function sends our status to rcServer every second */
void
UDP_loop()
{
  printf("UDP_loop started\n");fflush(stdout);
  printf("UDP_loop started\n");fflush(stdout);
  printf("UDP_loop started\n");fflush(stdout);
  printf("UDP_loop started\n");fflush(stdout);
  printf("UDP_loop started\n");fflush(stdout);

  udpsocket = UDP_establish(udphost, udpport);

  /* initialize heartbeats */
  resetHeartBeats();

  while(1)
  {
    if(udp_loop_exit)
    {
      break;
    }

#ifdef NEW_RC
    gheartbeat = time(0);
#endif

    /* this is appropriate place to check if all others are running fine */
    checkHeartBeats();

    UDP_send(udpsocket);

    /* wait 1 sec */
#ifdef VXWORKS
    taskDelay(100);
#else
    sleep(1);
#endif

  }

  UDP_close(udpsocket);
  udp_loop_exit = 0;

#ifndef VXWORKS
  printf("UDP_loop: calls pthread_exit\n");
  pthread_exit(NULL);
#endif

  return;
}

/* start thread to report our status to rcServer's UDP port */
int
UDP_start(MYSQL *dbsock)
{
  char tmpp[1000];
#ifdef NEW_RC
  char udpstaf[100];
  char portstr[100];
  char *token;
#endif


#ifdef NEW_RC
  /* define if new runcontrol is in use; if so, port number will be set to negative value */
  sprintf(tmpp,"SELECT port FROM process WHERE name='%s'",session);
  if(dbGetInt(dbsock, tmpp, &udpport)==CODA_ERROR) return(CODA_ERROR);
  if(udpport <= 0)
  {
    sprintf(tmpp,"SELECT clone FROM process WHERE name='%s'",localobject->name);
    if(dbGetStr(dbsock, tmpp, udpstaf)==CODA_ERROR) return(CODA_ERROR);
  
    token = strtok(udpstaf,":");
    strcpy(udphost,token); 

    token = strtok(NULL,":");
    strcpy(portstr, token);
    udpport = atoi(portstr);
  
    printf("new_rc download: UDP host is >%s< port id %d component = %s\n",
      udphost,udpport,localobject->name);
  }
  else
  {
    sprintf(tmpp,"SELECT host FROM process WHERE name='%s'",session);
    if(dbGetStr(dbsock, tmpp, udphost)==CODA_ERROR) return(CODA_ERROR);
    printf("download: UDP host is >%s< port id %d\n",udphost,udpport);
  }

#else

  sprintf(tmpp,"SELECT host FROM process WHERE name='%s'",session);
  if(dbGetStr(dbsock, tmpp, udphost)==CODA_ERROR) return(CODA_ERROR);

  sprintf(tmpp,"SELECT port FROM process WHERE name='%s'",session);
  if(dbGetInt(dbsock, tmpp, &udpport)==CODA_ERROR) return(CODA_ERROR);

  printf("download: UDP host is >%s< port id %d\n",udphost,udpport);

#endif

  /* if it is NOT first call, exit UDP loop and start new one */
  if(udp_loop_exit != -1)
  {
    udp_loop_exit = 1;
    while(udp_loop_exit)
    {
      printf("download: wait for udp_loop to exit ..\n");
#ifdef VXWORKS
      taskDelay(100);
#else
      sleep(1);
#endif
    }
    printf("download: udp_loop exited\n");
  }

  /* wait 3 sec to make sure udp_loop is exited */
#ifdef VXWORKS
  taskDelay(300);
#else
  sleep(3);
#endif

  /* just in case */
  udp_loop_exit = 0;


#ifdef VXWORKS
  {
    int iTaskStat;
    /*taskSpawn(name,pri,opt,stk,adr,args) 10 args required */
    iTaskStat = taskSpawn("UDP_LOOP", 110, 0, 200000, UDP_loop,
                          0,0,0,0,0,0,0,0,0,0);
    printf("taskSpawn(\"udp_loop\") returns %d\n",iTaskStat);
  }
#else
  {
    int res;
    pthread_t thread1;
    pthread_attr_t detached_attr;

    pthread_attr_init(&detached_attr);
    pthread_attr_setdetachstate(&detached_attr, PTHREAD_CREATE_DETACHED);
    pthread_attr_setscope(&detached_attr, PTHREAD_SCOPE_SYSTEM);

    res = pthread_create( (unsigned int *) &thread1, &detached_attr,
		   (void *(*)(void *)) UDP_loop, (void *) NULL);

    printf("pthread_create returned %d\n",res);fflush(stdout);
    perror("pthread_create");
  }
#endif

  return(0);
}





/***************************************************/
/***************************************************/
/***************************************************/
/* CODAtcpServer functions - attempt to replace DP code !!! */

#ifdef VXWORKS

#include <vxWorks.h>
#include <sockLib.h>
#include <inetLib.h>
#include <taskLib.h>
#include <stdioLib.h>
#include <strLib.h>
#include <ioLib.h>
#include <fioLib.h>

#else

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define TRUE 1
#define FALSE 0
#define OK 0
#define ERROR -1
#define STD_IN stdin

#endif

#include "libtcp.h" 

/* readiness flag */
static int coda_request_in_progress;
/* function declarations */ 
void CODAtcpServerWorkTask(TWORK *targ); 

/**************************************************************************** 
* * CODAtcpServer - accept and process requests over a TCP socket 
* * This routine creates a TCP socket, and accepts connections over the socket 
* from clients. Each client connection is handled by spawning a separate 
* task to handle client requests. 
* * This routine may be invoked as follows: 
* -> sp CODAtcpServer
* task spawned: id = 0x3a6f1c, name = t1 
* value = 3829532 = 0x3a6f1c 
* -> MESSAGE FROM CLIENT (Internet Address 150.12.0.10, port 1027): 
* Hello out there 
* * RETURNS: Never, or ERROR if a resources could not be allocated. */ 

int
CODAtcpServer(void)
{
  struct sockaddr_in serverAddr; /* in (it's me) */
  struct sockaddr_in clientAddr; /* from */
  int sockAddrSize;              /* size of socket address structure */ 
  int sFd;                       /* socket file descriptor */ 
  int ix = 0;                    /* counter for work task names */
  int portnum = SERVER_PORT_NUM; /* desired port number; can be changed if that number in use enc */
  char workName[16];             /* name of work task */ 
  static TWORK targ;
  MYSQL *dbsock;
  char tmp[1000], temp[100];

  /* some cleanup */
  sockAddrSize = sizeof(struct sockaddr_in);
  bzero((char *)&serverAddr, sockAddrSize); 
  bzero((char *)&clientAddr, sockAddrSize); 

  /* creates an endpoint for communication and returns a socket file descriptor */
  if((sFd = socket(AF_INET, SOCK_STREAM, 0)) == ERROR)
  {
    perror("socket"); 
    return(ERROR); 
  } 

  /* set up the local address */ 
  serverAddr.sin_family = AF_INET;
  serverAddr.sin_port = htons(portnum); /* set desired port number */
  serverAddr.sin_addr.s_addr = htonl(INADDR_ANY); /* create a TCP-based socket (???) */ 

  /* bind socket to local address */
  while(bind(sFd, (struct sockaddr *)&serverAddr, sockAddrSize) == ERROR)
  {
    perror("bind");

    /* try another port (just increment on one) */
    portnum ++;
    if((portnum-SERVER_PORT_NUM) > 10)
    {
      close(sFd); 
      return(ERROR);
    }

    serverAddr.sin_port = htons(portnum);
  }
  printf("bind on port %d\n",portnum);

  /* create queue for client connection requests */ 
  if(listen(sFd, SERVER_MAX_CONNECTIONS) == ERROR)
  {
    perror("listen"); 
    close(sFd); 
    return(ERROR); 
  }

  /* update database with port number */
  dbsock = dbConnect(getenv("MYSQL_HOST"), getenv("EXPID"));
  sprintf(temp,"%d",portnum);

  /* use 'inuse' field; replace 'inuse' by 'port' when DP_ask not in use !!! */
  sprintf(tmp,"UPDATE process SET inuse='%s' WHERE name='%s'",
    temp,localobject->name);

  printf("DB update: >%s<\n",tmp);
  if(mysql_query(dbsock, tmp) != 0)
  {
    printf("DB update: ERROR\n");
    return(ERROR);
  }
  dbDisconnect(getenv("MYSQL_HOST"), dbsock);

  coda_request_in_progress = 0;
  /* accept new connect requests and spawn tasks to process them */ 
  while(1)
  {
#ifdef VXWORKS
    /* check for free net buffers */
    usrNetStackSysPoolStatus("CODAtcpServer",0);
    usrNetStackDataPoolStatus("CODAtcpServer",0);
#endif

    /* do not accept new request if current one is not finished yet; too
    many requests may create network buffer shortage */
    if(coda_request_in_progress)
    {
      printf("wait: coda request in progress\n");
#ifdef VXWORKS
      taskDelay(100);
#else
      sleep(1);
#endif
      continue;
    }

    /*printf("Waiting at 'accept' ..\n"); fflush(stdout);*/
    if((targ.newFd = accept(sFd, (struct sockaddr *)&clientAddr, &sockAddrSize))
          == ERROR)
    {
      perror("accept"); 
      close(sFd); 
      return(ERROR); 
    }
    /*printf(".. 'accept' !!\n"); fflush(stdout);*/

    targ.address = inet_ntoa(clientAddr.sin_addr);
	/*
printf("WorkTask: alloc 0x%08x\n",targ.address);fflush(stdout);
printf("WorkTask: alloc 0x%08x\n",targ.address);fflush(stdout);
printf("WorkTask: alloc 0x%08x\n",targ.address);fflush(stdout);
printf("WorkTask: alloc 0x%08x\n",targ.address);fflush(stdout);
printf("WorkTask: alloc 0x%08x\n",targ.address);fflush(stdout);
	*/
    targ.port = ntohs (clientAddr.sin_port);

    coda_request_in_progress = 1;
#ifdef VXWORKS
    sprintf(workName,"twork%04d",ix++);
    if(taskSpawn(workName, 150/*SERVER_WORK_PRIORITY*/, 0, SERVER_STACK_SIZE,
       (FUNCPTR) CODAtcpServerWorkTask, &targ,
	   0, 0, 0, 0, 0, 0, 0, 0, 0)
          == ERROR)
    {
	  perror("taskSpawn"); 
	  close(targ.newFd); 
      coda_request_in_progress = 0;
    }
#else
    printf("CODAtcpServer: start work thread\n");
	{
      int ret;
	  pthread_t id;
      pthread_attr_t detached_attr;

      pthread_attr_init(&detached_attr);
      pthread_attr_setdetachstate(&detached_attr, PTHREAD_CREATE_DETACHED);
      pthread_attr_setscope(&detached_attr, PTHREAD_SCOPE_SYSTEM);

      printf("befor: socket=%d address>%s< port=%d\n",
        targ.newFd,targ.address,targ.port); fflush(stdout);
      ret = pthread_create(&id, &detached_attr, CODAtcpServerWorkTask, &targ);
      if(ret!=0)
      {
        printf("ERROR: pthread_create(CODAtcpServerWorkTask) returned %d\n",
          ret);
        close(targ.newFd);
        coda_request_in_progress = 0;
      }
	}
#endif
 
  }

  /* here we will remove port number from DB ??? */ 
  /* or do it in destructor ?? */

  return;
}

/**************************************************************************** 
* * CODAtcpServerWorkTask - process client requests 
* * This routine reads from the server's socket, and processes client 
* requests.
* * RETURNS: N/A. */ 


extern int codaExecute(char *message);

void
CODAtcpServerWorkTask(TWORK *targ) 
{
  TREQUEST clientRequest;            /* request/message from client */ 
  int nRead;                               /* number of bytes read */
  char message[REQUEST_MSG_SIZE];
  int itmp;

  /*setHeartBeat(HB_TCP,0,2);*/

  /*
  printf("CODAtcpServerWorkTask: socket=%d address>%s< port=%d\n",
    targ->newFd,targ->address,targ->port); fflush(stdout);
  */

#ifdef VXWORKS

#ifdef NEW_RC
  nRead = read(targ->newFd, (char *)&clientRequest.reply, 4);
  nRead = read(targ->newFd, (char *)&clientRequest.msgLen, 4);
  nRead = fioRead(targ->newFd, (char *)&clientRequest.message,
                  clientRequest.msgLen+1);
  if(nRead == (clientRequest.msgLen+1))
  {
#else
  nRead = fioRead(targ->newFd, (char *)&clientRequest, sizeof(TREQUEST));
  if(nRead == sizeof(TREQUEST))
  {
#endif
	/*
    printf ("MESSAGE (nRead=%d, Address>%s<, port=%d): Executing >%s<\n", 
	    nRead, targ->address, targ->port, clientRequest.message);
	*/
    strcpy(message, clientRequest.message);

    /* try Executing the message (each component must provide codaExecute() function */
	/*
    printf("Executing >%s<\n",message);
	*/
	/*setHeartBeat(HB_TCP,1,2);*/
    codaExecute(message);
	/*setHeartBeat(HB_TCP,2,2);*/

    free(targ->address); /* free malloc from inet_ntoa() */ 
  }
  else
  {
#ifdef NEW_RC
    printf("Error: nRead=%d, must be %d\n",nRead,clientRequest.msgLen+1);
#else
    printf("Error: nRead=%d, must be %d\n",nRead,sizeof(TREQUEST));
#endif
    fflush(stdout);

	/* do NOT free() here, error was observed:
CODAtcpServerWorkTask: socket=17 address>129.57.68.21< port=40181
Error: nRead=-1, must be 1032
0x8268e0 (twork0008): memPartFree: invalid block 0x86f910 in partition 0x250254.
	 */
  }
  /*
printf("WorkTask: free 0x%08x\n",targ->address);fflush(stdout);
printf("WorkTask: free 0x%08x\n",targ->address);fflush(stdout);
printf("WorkTask: free 0x%08x\n",targ->address);fflush(stdout);
printf("WorkTask: free 0x%08x\n",targ->address);fflush(stdout);
printf("WorkTask: free 0x%08x\n",targ->address);fflush(stdout);
  */
  close(targ->newFd);    /* close server socket connection */ 
  coda_request_in_progress = 0;


#else /* UNIX */


#ifdef NEW_RC
  nRead = read(targ->newFd, (char *)&clientRequest.reply, 4);
  nRead = read(targ->newFd, (char *)&clientRequest.msgLen, 4);

  /* convert integers from network byte order */
  clientRequest.msgLen = ntohl(clientRequest.msgLen);
  clientRequest.reply = ntohl(clientRequest.reply);

printf("XXX: msgLen=%d nRead=%d\n",clientRequest.msgLen,nRead);
  nRead = read(targ->newFd, (char *)&clientRequest.message,
                  clientRequest.msgLen+1);
  if(nRead == (clientRequest.msgLen+1))
  {
#else
  nRead = read(targ->newFd, (char *)&clientRequest, sizeof(TREQUEST));

  /* convert integers from network byte order */
  clientRequest.msgLen = ntohl(clientRequest.msgLen);
  clientRequest.reply = ntohl(clientRequest.reply);

  if(nRead == sizeof(TREQUEST))
  {  
#endif
    printf ("MESSAGE (nRead=%d, Address>%s<, port=%d): Executing >%s<\n", 
	    nRead, targ->address, targ->port, clientRequest.message);

    strcpy(message, clientRequest.message);


    /* try Executing the message (each component must provide codaExecute() function */
	/*sergey: NEED TO check if message make sence !!! (length is not zero at least ..)*/
    printf("Executing >%s< (len=%d)\n",message,strlen(message));

    codaExecute(message);

  }
  else
  {
#ifdef NEW_RC
    printf("Error(new rc): nRead=%d, must be %d\n",nRead,clientRequest.msgLen+1);
#else
    printf("Error(old rc): nRead=%d, must be %d\n",nRead,sizeof(TREQUEST));
#endif
  }

  /*free(targ->address);-stuck here !!!*/ /* free malloc from inet_ntoa() */ 
  close(targ->newFd);  /* close server socket connection */ 

  coda_request_in_progress = 0;

  /* terminate calling thread */
  pthread_exit(NULL);

#endif
  /*setHeartBeat(HB_TCP,0,-1);*/

  return;
}


/**************************/
/* some service functions */

/* flag=0: use ' ' as dividers */
/* flag=1: use {} as dividers */
int
listSplit1(char *list, int flag,
           int *argc, char argv[LISTARGV1][LISTARGV2])
{
  int i, i1, i2, len, k, ll;

  len = strlen(list);

  k = 0;
  *argc = 0;
  while(k<len)
  {
    i1 = i2 = -1;
    for(i=k; i<len; i++)
    {
      if(flag)
	  {
        if(list[i]=='{')
        {
          i1 = i;
          break;
        }
	  }
      else
      {
        i1 = i;
        while(list[i1]==' ') i1 ++; /* remove leading spaces if any */
        break;
      }
    }
    if(i1 == -1)
    {
      return(0);
    }
    if(flag) i1 ++; /* next char after { */

    for(i=i1; i<len; i++)
    {
      if(flag)
	  {
        if(list[i]=='}')
        {
          i2 = i;
          break;
        }
	  }
      else
      {
        if(i>=(len-1))
        {
          i2 = i+1;
          break;
        }
        else if(list[i]==' ')
        {
          i2 = i;
          break;
        }
      }
    }
    if(i2 == -1)
    {
      return(0);
    }
    i2 --; /* previous char before '}'  or ' ' */

    /* check for argv overflow */
    if( (*argc) >= LISTARGV1)
    {
      /*logMsg("listSplit1: too many strings in the list - earlear return\n",
        1,2,3,4,5,6);*/
      return(1);
    }
    if( (i2-i1+2) > LISTARGV2)
    {
      /*logMsg("listSplit1: too long strings in the list - earlear return\n",
        1,2,3,4,5,6);*/
      return(2);
    }

    ll = i2-i1+1;
    memcpy((char *)&argv[*argc][0], (char *)&list[i1], ll);

    argv[*argc][ll] = '\0';

    /*logMsg("i1=%d i2=%d >%s<\n",i1,i2,argv[*argc],4,5,6);*/
    (*argc) ++;

    if(flag) k = i2 + 2;
    else     k = i2 + 1;
  }

  return(0);
}


#ifdef Linux

/* Linux and Darwin do not have gethrtime() */

hrtime_t gethrtime(void)
{
  /* TO DO !!! */
  return(1);
}

#endif


/******************************************/
/* buffer pool information - VxWorks only */
/******************************************/


#ifdef VXWORKS

/* see netBufLib.h */

/* return the number of times failed to find space */
/* flag: 1 - before, 2 - after */
int
usrNetStackSysPoolStatus(char *title, int flag)
{
  int i;
  NET_POOL *mySysPtr = ( NET_POOL *)_pNetSysPool; /*system mbuf pool (global)*/
  CL_POOL  *myPoolPtr[CL_TBL_SIZE]; /* point at each pool cluster */
  /*
  printf("=======================================\n");
  printf("=======================================\n");
  printf("mbufs   = %d\n",mySysPtr->pPoolStat->mNum);
  printf("failed  = %d\n",mySysPtr->pPoolStat->mDrops);
  printf("waited  = %d\n",mySysPtr->pPoolStat->mWait);
  printf("drained = %d\n",mySysPtr->pPoolStat->mDrain);
  */

  if(flag==1)      printf("netSys(befor):  ");
  else if(flag==2) printf("netSys(after):  ");
  if(flag)
  {
    printf("%4d %4d %4d %4d -",
      mySysPtr->pPoolStat->mNum,
      mySysPtr->pPoolStat->mDrops,
      mySysPtr->pPoolStat->mWait,
      mySysPtr->pPoolStat->mDrain);
  }

  /* print out data pool mbuf usage */
  for(i=0; i<CL_TBL_SIZE; i++)
  {
    myPoolPtr[i] = (CL_POOL *) mySysPtr->clTbl[i];

    /* only interested in non-zero entries */
    if( (NULL == myPoolPtr[i]) || (NULL == myPoolPtr[i]->clSize) ) break ;
    if(flag) printf(" %4d",myPoolPtr[i]->clNumFree);
	/*
    printf("%d %d %d %d\n" ,
               myPoolPtr[i]->clSize ,
               myPoolPtr[i]->clNum ,
               myPoolPtr[i]->clNumFree,
               myPoolPtr[i]->clUsage
          );
	*/
    if(myPoolPtr[i]->clNumFree < MINNETBUFS)
	{
      printf("\nWARN(%s): too few %3d-byte sys  net buffers (%3d)\n",
        title,myPoolPtr[i]->clSize,myPoolPtr[i]->clNumFree);
	}
  }
  if(flag) printf("\n");
  /*
  printf("=======================================\n");
  printf("=======================================\n");
  */
  return(mySysPtr->pPoolStat->mDrops);
}

int
usrNetStackDataPoolStatus(char *title, int flag)
{
  int i;
  NET_POOL *myDataPtr = ( NET_POOL *) _pNetDpool; /*data mbuf pool (global)*/
  CL_POOL  *myPoolPtr[CL_TBL_SIZE]; /* point at each pool cluster */
  /*
  printf("=======================================\n");
  printf("=======================================\n");
  printf("mbufs   = %d\n",myDataPtr->pPoolStat->mNum);
  printf("failed  = %d\n",myDataPtr->pPoolStat->mDrops);
  printf("waited  = %d\n",myDataPtr->pPoolStat->mWait);
  printf("drained = %d\n",myDataPtr->pPoolStat->mDrain);
  */
  if(flag==1)      printf("netData(befor): ");
  else if(flag==2) printf("netData(after): ");
  if(flag)
  {
    printf("%4d %4d %4d %4d -",
      myDataPtr->pPoolStat->mNum,
      myDataPtr->pPoolStat->mDrops,
      myDataPtr->pPoolStat->mWait,
      myDataPtr->pPoolStat->mDrain);
  }

  /* print out data pool mbuf usage */
  for(i=0; i<CL_TBL_SIZE; i++)
  {
    myPoolPtr[i] = (CL_POOL *) myDataPtr->clTbl[i];

    /* only interested in non-zero entries */
    if( (NULL == myPoolPtr[i]) || (NULL == myPoolPtr[i]->clSize) ) break ;
    if(flag) printf(" %4d",myPoolPtr[i]->clNumFree);
	/*
    printf("%d %d %d %d\n" ,
               myPoolPtr[i]->clSize ,
               myPoolPtr[i]->clNum ,
               myPoolPtr[i]->clNumFree,
               myPoolPtr[i]->clUsage
          );
	*/
    if(myPoolPtr[i]->clNumFree < MINNETBUFS)
	{
      printf("\nWARN(%s): too few %3d-byte data net buffers (%3d)\n",
        title,myPoolPtr[i]->clSize,myPoolPtr[i]->clNumFree);
	}
  }
  if(flag) printf("\n");
  /*
  printf("=======================================\n");
  printf("=======================================\n");
  */
  return;
}

#endif


/* codaExecute: was type-specific, trying to make it generic */

/**************************************************************************/
/******************* RunControl interface function ************************/
/**************************************************************************/

/* following messages must be recognized:
 download
 prestart
 end
 pause
 go
 exit
 status
 */

/* example of tcpClient's command:

     ./tcpClient EB5 'download test_ts2'

*/

int codaDownload(char *confname);
int codaPrestart();
int codaGo();
int codaEnd();
int codaPause();
int codaExit();



int
codaExecute(char *command)
{
  int i, j, len, len1;
  char message[128], confname[128];

  len = strlen(command);

  /* check if command length make sence */
  if(len > 1000)
  {
    printf("codaExecute: ERROR: len=%d - do nothing\n",len);
    return;
  }

  /* check if command contains ascii codes only */
  for(i=0; i<len; i++)
  {
    if( !isascii(command[i]) )
	{
      printf("codaExecute: ERROR: non-ascii code [%d]=%d - do nothing\n",
        i,command[i]);
      return;
	}
  }

  /* remove leading spaces */
  for(i=0; i<len; i++)
  {
    j = i;
    if(command[j]!=' ') break;
  }

  strcpy(message,(char *)&command[j]);
  len = strlen(message);
  printf("codaExecute reached, message >%s<, len=%d\n",message,len);

  if( !strncmp(message, "download", 8) )
  {
    printf("codaExecute: 'download' transition\n");

    len1 = strlen("download");
    len = strlen(message);
    for(i=len1; i<len; i++)
    {
      j = i;
      if(message[j]!=' ') break; /* remove leading spaces */
    }
    strcpy(confname,(char *)&message[j]);
    len = strlen(confname);
    printf("--> confname >%s<, len=%d\n",confname,len);

    codaDownload(confname);
  }
  else if( !strncmp(message, "prestart", 8) )
  {
    printf("codaExecute: 'prestart' transition\n");
    codaPrestart();
  }
  else if( !strncmp(message, "end", 3) )
  {
    printf("codaExecute: 'end' transition\n");
    codaEnd();
  }
  else if( !strncmp(message, "pause", 5) )
  {
    printf("codaExecute: 'pause' transition\n");
    codaPause();
  }
  else if( !strncmp(message, "go", 2) )
  {
    printf("codaExecute: 'go' transition\n");
    codaGo();
  }
  else if( !strncmp(message, "exit", 4) )
  {
    printf("codaExecute: 'exit' transition\n");
    codaExit();
  }
  else
  {
    printf("codaExecute: ERROR: unknown request >%s<\n",message);
  }
  printf("codaExecute done\n");

  return;
}


