

#define USE_ALTRO


/* urol1.c - UNIX first readout list (polling mode) */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>

#ifndef VXWORKS
#include <sys/types.h>
#include <time.h>
#endif

#include "circbuf.h"

void davetrig(unsigned long, unsigned long);
void davetrig_done();

/*****************************/
/* former 'crl' control keys */

/* readout list UROL1 */
#define ROL_NAME__ "UROL1_PCI"

/* if use TS */
#define TRIG_SUPV

/* polling */
#define POLLING_MODE


/* need in one place in trigger_dispatch.h; must be undefined in rol1 */
#undef EVENT_MODE


/*???*/
/* 0: External Mode   1: Trigger Supervisor Mode 
#define TS_MODE  0
#define IRQ_SOURCE  0x10
*/

#define INIT_NAME urol1_pci__init

#include "rol.h"

/* PCI readout */
#include "PCI_source.h"

/************************/
/************************/

#include "coda.h"
#include "tt.h"

static char *rcname = "RC00";

long decrement;     /* local decrement counter */
extern long nevent; /* local event counter */
long mynev;

static int scan_flag; /* word to accumulate errors, will be reported at physics sync event */
static int evnum0, evnum0prev;;
static int evnum1, evnum1prev;

#ifdef USE_ALTRO
#define NBINS 100
#define TIME_BIN_WIDTH 100 /* time bin width in nanosec */
#define NWCHANNEL  100000 /* must be bigger then # of bins + time + .. */
#define NOUTPUTBUF 300000
static int channel = 0;
#endif

#define SYNC 0x20000000

static void
__download()
{
  int poolsize;

#ifdef POLLING_MODE
  rol->poll = 1;
#endif

  /*PCI stuff*/
  pcitirInit();
  /*PCI stuff*/


  printf(">>>>>>>>>>>>>>>>>>>>>>>>>> ROCID = %d <<<<<<<<<<<<<<<<\n",rol->pid);

  printf("rol1: downloading DDL table ...\n");
  clonbanks_();
  printf("rol1: ... done.\n");

  printf("INFO: User Download 1 Executed\n");

  return;
}

static void
__prestart()
{
  unsigned long jj, adc_id, sl;
  char *env;

  /* Clear some global variables etc for a clean start */
  CTRIGINIT;
  *(rol->nevents) = 0;

  /* init trig source PCI */
  PCI_INIT;

  /* Register a sync trigger source (up to 32 sources) */
  CTRIGRSS(PCI, 1, davetrig, davetrig_done); /* second arg=1 - what is that ? */

  /* Register a physics event type (up to 16 types) */
  CRTTYPE(1, PCI, 1);
  CRTTYPE(2, PCI, 1);
  CRTTYPE(3, PCI, 1);
  CRTTYPE(4, PCI, 1);
  CRTTYPE(5, PCI, 1);
  CRTTYPE(6, PCI, 1);
  CRTTYPE(7, PCI, 1);
  CRTTYPE(8, PCI, 1);
  CRTTYPE(9, PCI, 1);
  printf("11\n");


  /*PCI stuff*/
  TIRPCI_SetL1AWidth(hDev, 10, 1);
  printf("12\n");
  TIRPCI_ClearScaler(hDev);
  printf("13\n");
  TIRPCI_PrintStatus(hDev,2);
  /*PCI stuff*/

  printf("14\n");


  rol->poll = 1;


  sprintf((char *)&rcname[2],"%02d",rol->pid);
  printf("rcname >%4.4s<\n",rcname);


#ifdef USE_ALTRO

  if(rol->pid==31)
  {
    ;
    /*system("/misc/clas/devel/coda/src/scripts/bonus_firmware.tcl 0.2.254");*/ /*left upper*/
    /*system("/misc/clas/devel/coda/src/scripts/bonus_firmware.tcl 0.2.252");*/ /*left bottom*/
  }

  if(rol->pid==0)
  {
    ;
    /*system("/misc/clas/devel/coda/src/scripts/bonus_firmware.tcl 1.3.242");*/ /*right upper*/
    /*system("/misc/clas/devel/coda/src/scripts/bonus_firmware.tcl 1.3.241");*/ /*right bottom*/
  }


  rorcDownload();
  rorcReadTable(rol->pid);

  /* parameters: rorc channel, the number of fecs, fec slot list */

  if(rol->pid==31)
  {
    /*left upper, channel 0*/
  /*int fecs[14] = {1,3,5,17,18,20};*/
    int fecs[14] = {1,3,5,17,18,20};
	rorcPrestart(7165, channel, 6, fecs, 80);
  }
  if(rol->pid==31)
  {
    /*left bottom, channel 1*/
  /*int fecs[14] = {1,3,5,16,18,20};*/
    int fecs[14] = {1,3,5,16,18,20};
	rorcPrestart(7165, channel+1, 6, fecs, 80);
  }

  if(rol->pid==0)
  {
    /*right upper, channel 0*/
    int fecs[14] = {0,3,4,16,18,20};
    rorcPrestart(6038, channel, 6, fecs, 80);
  }
  if(rol->pid==0)
  {
    /*right bottom, channel 1*/
    int fecs[14] = {0,4,6,16,19,22};
    rorcPrestart(6038, channel+1, 6, fecs, 80);
  }


#endif


  printf("INFO: User Prestart 1 executed\n");

  /* from parser (do we need that in rol2 ???) */
  *(rol->nevents) = 0;
  rol->recNb = 0;

  return;
}

static void
__pause()
{
  CDODISABLE(PCI,1,0);

  printf("INFO: User Pause 1 Executed\n");

  return;
}

static void
__go()
{
  char *env;

  scan_flag = 0;
  evnum0prev=0;
  evnum1prev=0;

#ifdef USE_ALTRO
  rorcGo(channel);
  rorcGo(channel+1);
#endif

  CDOENABLE(PCI,1,0);

  mynev = 0;

  printf("INFO: User Go 1 Executed\n");

  return;
}

static void
__end()
{
  int ii, total_count, rem_count;

  CDODISABLE(PCI,1,0);

#ifdef USE_ALTRO
  rorcEnd(channel);
  rorcEnd(channel+1);
#endif

  /*PCI stuff*/
  TIRPCI_PrintStatus(hDev,2);
  /*PCI stuff*/

  printf("INFO: User End 1 Executed\n");

  return;
}



void
davetrig(unsigned long EVTYPE, unsigned long EVSOURCE)
{
  long EVENT_LENGTH;
  int ii, len, len1, len2, type, lock_key, *tmp;
  int *adrlen, *bufin, *bufout, i, ind, ind2, ncol, nrow;
  unsigned long *secondword, *jw, *buf, *dabufp1, *dabufp2;
  DANODE *outEvent;
  unsigned int data;
  int ret;
  int max_words_from_channel;
#ifdef USE_ALTRO
  int roldabufp1[NOUTPUTBUF];
  int roldabufp2[NOUTPUTBUF];
#endif

  /*
printf("PCI trig reached\n");
sleep(1);
  */

  /*PCI stuff*/
  TIRPCI_SetOutput(hDev, 3);
  /*PCI stuff*/

  rol->dabufp = (long *) 0;
  /*open event type EVTYPE of BT_UI4*/
  CEOPEN(EVTYPE, BT_UI4);

  /*PCI stuff*/
  ii = TIRPCI_Read_tdr(hDev);
  /*PCI stuff*/

  jw = rol->dabufp;
  jw[-2] = 1;
  secondword = rol->dabufp - 1; /* pointer to the second CODA header word */
  
  /*printf("syncFlag=%d EVTYPE=%d\n",syncFlag,EVTYPE);fflush(stdout);*/
  
#ifdef TRIG_SUPV
  if((syncFlag<0)||(syncFlag>1)) /*illegal */
  {
    printf("111\n");
  }
  else if((syncFlag==0)&&(EVTYPE==0)) /*illegal */
  {
    printf("112\n");
  }
  else if((syncFlag==1)&&(EVTYPE==0)) /* force_sync (scaler) events */
  {
    printf("scaler event\n");fflush(stdout);
  }
  else /* physics and physics_sync events */
#endif
  {

#ifdef USE_ALTRO
    /* open data bank */
    if((ind = bosMopen_(jw, rcname, 0, 1, 0)) <=0)
    {
      printf("bosMopen_ Error: %d\n",ind);
    }
    rol->dabufp += NHEAD;

    len = len1 = len2 = 0;
	/*
if(rol->pid==31) goto skip0;
	*/
    len1 = rorcGetEvent(channel,NOUTPUTBUF,roldabufp1);
	if(len1<=0)
	{
      scan_flag |= 0x1;
      printf("ERROR: length ch0=%6d\n",len1);
      evnum0prev = 0;
	}
    else
	{
      evnum0 = roldabufp1[2];
      if(evnum0==(evnum0prev+2))
	  {
		;
		/*
        printf("WARN ch0: evnums are %6d(prev %6d)\n",evnum0,evnum0prev);
while(1) ;
		*/
	  }
      evnum0prev = evnum0;
	}
skip0:

    len2 = rorcGetEvent(channel+1,NOUTPUTBUF,roldabufp2);
	if(len2<=0)
	{
      scan_flag |= 0x2;
      printf("ERROR: length ch1=%6d\n",len2);
      evnum1prev = 0;
	}
    else
	{
      evnum1 = roldabufp2[2];
      if(evnum1==(evnum1prev+2))
	  {
		;
		/*
        printf("WARN ch1: evnums are %6d(prev %6d)\n",evnum1,evnum1prev);
while(1) ;
		*/
	  }
      evnum1prev = evnum1;
	}

	/*
ret=RCU_MEBCNT_Read(&data);
printf("RCU_MEBCNT_Read: ret=%d 0-3=%d 4-7=%d 8-9=%d\n",ret,data&0xf,(data>>4)&0xf,(data>>8)&0x3);
ret=RCU_AUXTRGCNT_Read(&data);
printf("RCU_AUXTRGCNT_Read: ret=%d 0-19=%d\n",ret,data&0xfffff);
ret=RCU_TTCL2ACNT_Read(&data);
printf("RCU_TTCL2ACNT_Read: ret=%d 0-19=%d\n",ret,data&0xfffff);
ret=RCU_TTCL2RCNT_Read(&data);
printf("RCU_TTCL2RCNT_Read: ret=%d 0-19=%d\n",ret,data&0xfffff);
	*/
	/*
{
  int nsamples = 100;
  printf("len1=%d len2=%d (expect %d)\n",len1,len2,((nsamples+2+2)/3+1)*128*6+17);
}
*/

    max_words_from_channel = (((MAX_EVENT_LENGTH-1000)/2)/4);
	/*
if(rol->pid==31) goto skip01;
	*/
    if(len1 > 0)
	{
      if(len1 > max_words_from_channel)
	  {
        printf("WARN: ch 0 event too big (%d words), will copy only %d words\n",
			   len1,max_words_from_channel); fflush(stdout);
        len1 = max_words_from_channel;
	  }
	}
skip01:

    if(len2 > 0)
	{
      if(len2 > max_words_from_channel)
	  {
        printf("WARN: ch 1 event too big (%d words), will copy only %d words\n",
			   len2,max_words_from_channel); fflush(stdout);
        len2 = max_words_from_channel;
	  }
	}


    len = len1 + len2;
	/*
if(rol->pid==31) goto skip02;
	*/
    if(len1>0) for(i=0; i<len1; i++) *rol->dabufp++ =  roldabufp1[i];
skip02:

    if(len2>0) for(i=0; i<len2; i++) *rol->dabufp++ =  roldabufp2[i];



	
    if(bosMclose_(jw,ind,1,len) == 0)
    {
      printf("ERROR in bosMclose_ - space is not enough !!!\n");
    }

#else

    /* open data bank */
    if((ind = bosMopen_(jw, rcname, 0, 1, 0)) <=0)
    {
      printf("bosMopen_ Error: %d\n",ind);
    }
    rol->dabufp += NHEAD;
    len = 1000;
    for(ii=0; ii<len; ii++)
    {
      *rol->dabufp++ = ii;
    }
    if(bosMclose_(jw,ind,1,len) == 0)
    {
      printf("ERROR in bosMclose_ - space is not enough !!!\n");
    }

#endif





    if(syncFlag==1)
    {
      printf("PHYSICS SYNC EVENT REACHED, recent event numbers are %d and %d\n",evnum0,evnum1);fflush(stdout);

      if(scan_flag!=0) printf("PHYSICS SYNC EVENT ERROR: scan_flag=0x%08x\n",scan_flag);
	  /*
if(rol->pid==31) goto skip03;
	  */
      
      while( (len1=rorcGetEvent(channel,NOUTPUTBUF,roldabufp1)) != 0)
      {
        printf("SYNC ERROR: len1=%d\n",len1);
        scan_flag |= 0x10;
      }

skip03:

      while( (len2=rorcGetEvent(channel+1,NOUTPUTBUF,roldabufp2)) != 0)
      {
        printf("SYNC ERROR: len2=%d\n",len2);
        scan_flag |= 0x20;
      }


      ind2 = bosMopen_(jw,"PTRN",rol->pid,1,1);
      jw[ind2+1] = SYNC + scan_flag;
      rol->dabufp += bosMclose_(jw,ind2,1,1);

      scan_flag = 0;
    }




  }


  CECLOSE;

  /*PCI stuff*/
  TIRPCI_ClearOutput(hDev, 1);
  /*PCI stuff*/
  /*
printf("PCI trig done, EVTYPE=%d\n",EVTYPE);
  */
  return;
}
  
void
davetrig_done()
{
  /*PCI stuff*/
  TIRPCI_ClearOutput(hDev, 2);
  /*PCI stuff*/

  return;
}

void
__done()
{
  /* from parser */
  poolEmpty = 0; /* global Done, Buffers have been freed */

  CDOACK(PCI,1,0);

  return;
}
  
static void
__status()
{
  return;
}  
